Initialize the program!
Verify Test Cases
All passed!
Done Verification
Generating repair candidates!
Processing prog.c
Total 5129 different repair schemas!!!!
Total 10959 different repair candidate templates for scoring!!!
Trying different candidates!
BasicTester pointer: 0xaca0fc0
StringConstTester pointer: 0xae1b638
CondTester pointer: 0xaa38218
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:67
--Src File: prog.c
Fragment 0:
if ((l->head->next == l->head) && !(__abst_hole(l, l->head->next, l->head, l->head->element, l->head->previous, l->size)))
    return 1;


CondTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    
//Patch 0:
if ((l->head->next == l->head) && !(__is_neg(6, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:72
--Src File: prog.c
Fragment 0:
if ((ln1->next == l->head) && !(__abst_hole(l, ln1, ln1->next, l->head, ln2, l->head->next, l->head->element, l->head->previous, ln1->element, ln1->previous, l->size)))
    return 1;
else
    ln1 = ln1->next;


CondTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        
//Patch 0:
if ((ln1->next == l->head) && !(__is_neg(11, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(ln1->element), sizeof (ln1->element), &(ln1->previous), sizeof (ln1->previous), &(l->size), sizeof (l->size))))
    return 1;
else
    ln1 = ln1->next;

//CodeSeg 1:
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:72
--Src File: prog.c
Fragment 0:
if ((ln1->next == l->head) || (__abst_hole(l, ln1, ln1->next, l->head, ln2, l->head->next, l->head->element, l->head->previous, ln1->element, ln1->previous, l->size)))
    return 1;
else
    ln1 = ln1->next;


CondTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        
//Patch 0:
if ((ln1->next == l->head) || (__is_neg(11, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(ln1->element), sizeof (ln1->element), &(ln1->previous), sizeof (ln1->previous), &(l->size), sizeof (l->size))))
    return 1;
else
    ln1 = ln1->next;

//CodeSeg 1:
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((argc < 2) && !(__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     
//Patch 0:
if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((argc < 2) || (__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     
//Patch 0:
if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:125
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) && !(__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     
//Patch 0:
if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:125
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) || (__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     
//Patch 0:
if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:173
--Src File: prog.c
Fragment 0:
if ((hasLoopPrev(l) == 0) && !(__abst_hole(l, rm, l->head, f, node, n4, l->size, n3, n2, n1, status, argv, argc))) {
    printf("%s", "HAS LOOP");
    return 0;
}


CondTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    
//Patch 0:
if ((hasLoopPrev(l) == 0) && !(__is_neg(13, &(l), sizeof (l), &(rm), sizeof (rm), &(l->head), sizeof (l->head), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(l->size), sizeof (l->size), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc)))) {
    printf("%s", "HAS LOOP");
    return 0;
}

//CodeSeg 1:
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:173
--Src File: prog.c
Fragment 0:
if ((hasLoopPrev(l) == 0) || (__abst_hole(l, rm, l->head, f, node, n4, l->size, n3, n2, n1, status, argv, argc))) {
    printf("%s", "HAS LOOP");
    return 0;
}


CondTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    
//Patch 0:
if ((hasLoopPrev(l) == 0) || (__is_neg(13, &(l), sizeof (l), &(rm), sizeof (rm), &(l->head), sizeof (l->head), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(l->size), sizeof (l->size), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc)))) {
    printf("%s", "HAS LOOP");
    return 0;
}

//CodeSeg 1:
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:110
--Src File: prog.c
Fragment 0:
if ((strcmp(e->element, rm) != 0) && !(__abst_hole(rm, e, e->element, l, (*l)->head, e->next, (*l)->head->next, e->next->previous, e->previous, (*l)->head->element, (*l)->head->previous, (*l)->size, e->next->element, e->next->next))) {
    e = e->next;
    continue;
}


CondTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        
//Patch 0:
if ((strcmp(e->element, rm) != 0) && !(__is_neg(14, &(rm), sizeof (rm), &(e), sizeof (e), &(e->element), sizeof (e->element), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(e->next), sizeof (e->next), &((*l)->head->next), sizeof ((*l)->head->next), &(e->next->previous), sizeof (e->next->previous), &(e->previous), sizeof (e->previous), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*l)->size), sizeof ((*l)->size), &(e->next->element), sizeof (e->next->element), &(e->next->next), sizeof (e->next->next)))) {
    e = e->next;
    continue;
}

//CodeSeg 1:
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 10
Counter: 11
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:168
--Src File: prog.c
Fragment 0:
if ((hasLoopNext(l) == 0) && !(__abst_hole(l, f, node, l->head, n4, n3, rm, n2, n1, status, l->size, argv, argc))) {
    printf("%s", "HAS LOOP");
    return 0;
}


CondTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    
//Patch 0:
if ((hasLoopNext(l) == 0) && !(__is_neg(13, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(n4), sizeof (n4), &(n3), sizeof (n3), &(rm), sizeof (rm), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc)))) {
    printf("%s", "HAS LOOP");
    return 0;
}

//CodeSeg 1:

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:11
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:168
--Src File: prog.c
Fragment 0:
if ((hasLoopNext(l) == 0) || (__abst_hole(l, f, node, l->head, n4, n3, rm, n2, n1, status, l->size, argv, argc))) {
    printf("%s", "HAS LOOP");
    return 0;
}


CondTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    
//Patch 0:
if ((hasLoopNext(l) == 0) || (__is_neg(13, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(n4), sizeof (n4), &(n3), sizeof (n3), &(rm), sizeof (rm), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc)))) {
    printf("%s", "HAS LOOP");
    return 0;
}

//CodeSeg 1:

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:110
--Src File: prog.c
Fragment 0:
if ((strcmp(e->element, rm) != 0) || (__abst_hole(rm, e, e->element, l, (*l)->head, e->next, (*l)->head->next, e->next->previous, e->previous, (*l)->head->element, (*l)->head->previous, (*l)->size, e->next->element, e->next->next))) {
    e = e->next;
    continue;
}


CondTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        
//Patch 0:
if ((strcmp(e->element, rm) != 0) || (__is_neg(14, &(rm), sizeof (rm), &(e), sizeof (e), &(e->element), sizeof (e->element), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(e->next), sizeof (e->next), &((*l)->head->next), sizeof ((*l)->head->next), &(e->next->previous), sizeof (e->next->previous), &(e->previous), sizeof (e->previous), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*l)->size), sizeof ((*l)->size), &(e->next->element), sizeof (e->next->element), &(e->next->next), sizeof (e->next->next)))) {
    e = e->next;
    continue;
}

//CodeSeg 1:
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:13
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:97
--Src File: prog.c
Fragment 0:
if ((ln2->previous == l->head || ln2->previous->previous == l->head) && !(__abst_hole(l, ln2, l->head, ln2->previous, ln2->previous->previous, ln1, ln1->previous, l->head->previous, l->head->element, l->head->next, ln1->element, ln1->next, l->size, ln2->element, ln2->next, ln2->previous->element, ln2->previous->next)))
    return 1;
else
    ln2 = ln2->previous->previous;


CondTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        
//Patch 0:
if ((ln2->previous == l->head || ln2->previous->previous == l->head) && !(__is_neg(17, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->previous), sizeof (ln2->previous), &(ln2->previous->previous), sizeof (ln2->previous->previous), &(ln1), sizeof (ln1), &(ln1->previous), sizeof (ln1->previous), &(l->head->previous), sizeof (l->head->previous), &(l->head->element), sizeof (l->head->element), &(l->head->next), sizeof (l->head->next), &(ln1->element), sizeof (ln1->element), &(ln1->next), sizeof (ln1->next), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next), sizeof (ln2->next), &(ln2->previous->element), sizeof (ln2->previous->element), &(ln2->previous->next), sizeof (ln2->previous->next))))
    return 1;
else
    ln2 = ln2->previous->previous;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:14
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:101
--Src File: prog.c
Fragment 0:
if ((ln1 == ln2) && !(__abst_hole(ln1, ln2, ln2->previous, ln2->previous->previous, l, ln1->previous, ln1->element, ln1->next, ln2->element, ln2->next, ln2->previous->element, ln2->previous->next)))
    return 0;


CondTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        
//Patch 0:
if ((ln1 == ln2) && !(__is_neg(12, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->previous), sizeof (ln2->previous), &(ln2->previous->previous), sizeof (ln2->previous->previous), &(l), sizeof (l), &(ln1->previous), sizeof (ln1->previous), &(ln1->element), sizeof (ln1->element), &(ln1->next), sizeof (ln1->next), &(ln2->element), sizeof (ln2->element), &(ln2->next), sizeof (ln2->next), &(ln2->previous->element), sizeof (ln2->previous->element), &(ln2->previous->next), sizeof (ln2->previous->next))))
    return 0;

//CodeSeg 1:
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:15
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:162
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "H") == 0) && !(__abst_hole(l, node, n4, l->head, n3, f, n2, n1, status, rm, l->head->next, n4->element, l->size, argv, argc, n4->next, n4->previous, l->head->element, l->head->previous)))
    node = l->head;


CondTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         
//Patch 0:
if ((strcmp(x, "H") == 0) && !(__is_neg(19, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(rm), sizeof (rm), &(l->head->next), sizeof (l->head->next), &(n4->element), sizeof (n4->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n4->next), sizeof (n4->next), &(n4->previous), sizeof (n4->previous), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous))))
    node = l->head;

//CodeSeg 1:
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:162
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "H") == 0) || (__abst_hole(l, node, n4, l->head, n3, f, n2, n1, status, rm, l->head->next, n4->element, l->size, argv, argc, n4->next, n4->previous, l->head->element, l->head->previous)))
    node = l->head;


CondTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         
//Patch 0:
if ((strcmp(x, "H") == 0) || (__is_neg(19, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(rm), sizeof (rm), &(l->head->next), sizeof (l->head->next), &(n4->element), sizeof (n4->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n4->next), sizeof (n4->next), &(n4->previous), sizeof (n4->previous), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous))))
    node = l->head;

//CodeSeg 1:
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:101
--Src File: prog.c
Fragment 0:
if ((ln1 == ln2) || (__abst_hole(ln1, ln2, ln2->previous, ln2->previous->previous, l, ln1->previous, ln1->element, ln1->next, ln2->element, ln2->next, ln2->previous->element, ln2->previous->next)))
    return 0;


CondTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        
//Patch 0:
if ((ln1 == ln2) || (__is_neg(12, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->previous), sizeof (ln2->previous), &(ln2->previous->previous), sizeof (ln2->previous->previous), &(l), sizeof (l), &(ln1->previous), sizeof (ln1->previous), &(ln1->element), sizeof (ln1->element), &(ln1->next), sizeof (ln1->next), &(ln2->element), sizeof (ln2->element), &(ln2->next), sizeof (ln2->next), &(ln2->previous->element), sizeof (ln2->previous->element), &(ln2->previous->next), sizeof (ln2->previous->next))))
    return 0;

//CodeSeg 1:
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:160
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N4") == 0) && !(__abst_hole(node, n3, n4, l, n2, n1, f, status, rm, n4->element, n3->element, argv, argc, n3->next, n3->previous, n4->next, n4->previous)))
    node = n4;


CondTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         
//Patch 0:
if ((strcmp(x, "N4") == 0) && !(__is_neg(17, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(n1), sizeof (n1), &(f), sizeof (f), &(status), sizeof (status), &(rm), sizeof (rm), &(n4->element), sizeof (n4->element), &(n3->element), sizeof (n3->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n3->next), sizeof (n3->next), &(n3->previous), sizeof (n3->previous), &(n4->next), sizeof (n4->next), &(n4->previous), sizeof (n4->previous))))
    node = n4;

//CodeSeg 1:
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:19
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:160
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N4") == 0) || (__abst_hole(node, n3, n4, l, n2, n1, f, status, rm, n4->element, n3->element, argv, argc, n3->next, n3->previous, n4->next, n4->previous)))
    node = n4;


CondTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         
//Patch 0:
if ((strcmp(x, "N4") == 0) || (__is_neg(17, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(n1), sizeof (n1), &(f), sizeof (f), &(status), sizeof (status), &(rm), sizeof (rm), &(n4->element), sizeof (n4->element), &(n3->element), sizeof (n3->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n3->next), sizeof (n3->next), &(n3->previous), sizeof (n3->previous), &(n4->next), sizeof (n4->next), &(n4->previous), sizeof (n4->previous))))
    node = n4;

//CodeSeg 1:
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 20
Counter: 21
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:97
--Src File: prog.c
Fragment 0:
if ((ln2->previous == l->head || ln2->previous->previous == l->head) || (__abst_hole(l, ln2, l->head, ln2->previous, ln2->previous->previous, ln1, ln1->previous, l->head->previous, l->head->element, l->head->next, ln1->element, ln1->next, l->size, ln2->element, ln2->next, ln2->previous->element, ln2->previous->next)))
    return 1;
else
    ln2 = ln2->previous->previous;


CondTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        
//Patch 0:
if ((ln2->previous == l->head || ln2->previous->previous == l->head) || (__is_neg(17, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->previous), sizeof (ln2->previous), &(ln2->previous->previous), sizeof (ln2->previous->previous), &(ln1), sizeof (ln1), &(ln1->previous), sizeof (ln1->previous), &(l->head->previous), sizeof (l->head->previous), &(l->head->element), sizeof (l->head->element), &(l->head->next), sizeof (l->head->next), &(ln1->element), sizeof (ln1->element), &(ln1->next), sizeof (ln1->next), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next), sizeof (ln2->next), &(ln2->previous->element), sizeof (ln2->previous->element), &(ln2->previous->next), sizeof (ln2->previous->next))))
    return 1;
else
    ln2 = ln2->previous->previous;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:158
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N3") == 0) && !(__abst_hole(node, n2, n3, n1, n4, l, status, f, rm, n3->element, n2->element, argv, argc, n2->next, n2->previous, n3->next, n3->previous)))
    node = n3;


CondTester, a patch instance with id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         
//Patch 0:
if ((strcmp(x, "N3") == 0) && !(__is_neg(17, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(status), sizeof (status), &(f), sizeof (f), &(rm), sizeof (rm), &(n3->element), sizeof (n3->element), &(n2->element), sizeof (n2->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n2->next), sizeof (n2->next), &(n2->previous), sizeof (n2->previous), &(n3->next), sizeof (n3->next), &(n3->previous), sizeof (n3->previous))))
    node = n3;

//CodeSeg 1:
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:22
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:158
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N3") == 0) || (__abst_hole(node, n2, n3, n1, n4, l, status, f, rm, n3->element, n2->element, argv, argc, n2->next, n2->previous, n3->next, n3->previous)))
    node = n3;


CondTester, a patch instance with id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         
//Patch 0:
if ((strcmp(x, "N3") == 0) || (__is_neg(17, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(status), sizeof (status), &(f), sizeof (f), &(rm), sizeof (rm), &(n3->element), sizeof (n3->element), &(n2->element), sizeof (n2->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n2->next), sizeof (n2->next), &(n2->previous), sizeof (n2->previous), &(n3->next), sizeof (n3->next), &(n3->previous), sizeof (n3->previous))))
    node = n3;

//CodeSeg 1:
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:23
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:156
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N2") == 0) && !(__abst_hole(node, n1, n2, n3, n4, status, rm, l, f, n2->element, n1->element, argv, argc, n1->next, n1->previous, n2->next, n2->previous)))
    node = n2;


CondTester, a patch instance with id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         
//Patch 0:
if ((strcmp(x, "N2") == 0) && !(__is_neg(17, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n4), sizeof (n4), &(status), sizeof (status), &(rm), sizeof (rm), &(l), sizeof (l), &(f), sizeof (f), &(n2->element), sizeof (n2->element), &(n1->element), sizeof (n1->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->previous), sizeof (n1->previous), &(n2->next), sizeof (n2->next), &(n2->previous), sizeof (n2->previous))))
    node = n2;

//CodeSeg 1:
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:156
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N2") == 0) || (__abst_hole(node, n1, n2, n3, n4, status, rm, l, f, n2->element, n1->element, argv, argc, n1->next, n1->previous, n2->next, n2->previous)))
    node = n2;


CondTester, a patch instance with id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         
//Patch 0:
if ((strcmp(x, "N2") == 0) || (__is_neg(17, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n4), sizeof (n4), &(status), sizeof (status), &(rm), sizeof (rm), &(l), sizeof (l), &(f), sizeof (f), &(n2->element), sizeof (n2->element), &(n1->element), sizeof (n1->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->previous), sizeof (n1->previous), &(n2->next), sizeof (n2->next), &(n2->previous), sizeof (n2->previous))))
    node = n2;

//CodeSeg 1:
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:25
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:67
--Src File: prog.c
Fragment 0:
if ((l->head->next == l->head) || (__abst_hole(l, l->head->next, l->head, l->head->element, l->head->previous, l->size)))
    return 1;


CondTester, a patch instance with id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    
//Patch 0:
if ((l->head->next == l->head) || (__is_neg(6, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:26
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:93
--Src File: prog.c
Fragment 0:
if ((ln1->previous == l->head) && !(__abst_hole(l, ln1, ln1->previous, l->head, ln2, l->head->previous, l->head->element, l->head->next, ln1->element, ln1->next, l->size)))
    return 1;
else
    ln1 = ln1->previous;


CondTester, a patch instance with id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        
//Patch 0:
if ((ln1->previous == l->head) && !(__is_neg(11, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->previous), sizeof (ln1->previous), &(l->head), sizeof (l->head), &(ln2), sizeof (ln2), &(l->head->previous), sizeof (l->head->previous), &(l->head->element), sizeof (l->head->element), &(l->head->next), sizeof (l->head->next), &(ln1->element), sizeof (ln1->element), &(ln1->next), sizeof (ln1->next), &(l->size), sizeof (l->size))))
    return 1;
else
    ln1 = ln1->previous;

//CodeSeg 1:
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:27
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:93
--Src File: prog.c
Fragment 0:
if ((ln1->previous == l->head) || (__abst_hole(l, ln1, ln1->previous, l->head, ln2, l->head->previous, l->head->element, l->head->next, ln1->element, ln1->next, l->size)))
    return 1;
else
    ln1 = ln1->previous;


CondTester, a patch instance with id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        
//Patch 0:
if ((ln1->previous == l->head) || (__is_neg(11, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->previous), sizeof (ln1->previous), &(l->head), sizeof (l->head), &(ln2), sizeof (ln2), &(l->head->previous), sizeof (l->head->previous), &(l->head->element), sizeof (l->head->element), &(l->head->next), sizeof (l->head->next), &(ln1->element), sizeof (ln1->element), &(ln1->next), sizeof (ln1->next), &(l->size), sizeof (l->size))))
    return 1;
else
    ln1 = ln1->previous;

//CodeSeg 1:
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:28
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:154
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N1") == 0) && !(__abst_hole(node, n1, n2, status, rm, n3, n4, f, l, n1->element, argv, argc, n1->next, n1->previous)))
    node = n1;


CondTester, a patch instance with id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         
//Patch 0:
if ((strcmp(x, "N1") == 0) && !(__is_neg(14, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(rm), sizeof (rm), &(n3), sizeof (n3), &(n4), sizeof (n4), &(f), sizeof (f), &(l), sizeof (l), &(n1->element), sizeof (n1->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->previous), sizeof (n1->previous))))
    node = n1;

//CodeSeg 1:
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:29
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:154
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N1") == 0) || (__abst_hole(node, n1, n2, status, rm, n3, n4, f, l, n1->element, argv, argc, n1->next, n1->previous)))
    node = n1;


CondTester, a patch instance with id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         
//Patch 0:
if ((strcmp(x, "N1") == 0) || (__is_neg(14, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(rm), sizeof (rm), &(n3), sizeof (n3), &(n4), sizeof (n4), &(f), sizeof (f), &(l), sizeof (l), &(n1->element), sizeof (n1->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->previous), sizeof (n1->previous))))
    node = n1;

//CodeSeg 1:
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 30
Counter: 31
Batcher Size:30
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:148
--Src File: prog.c
Fragment 0:
if ((status == -1) && !(__abst_hole(status, rm, f, l, node, n1, n4, n2, n3, argv, argc))) {
    rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));
    strcpy(rm, x);
    status = 0;
    continue;
}


CondTester, a patch instance with id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        
//Patch 0:
if ((status == -1) && !(__is_neg(11, &(status), sizeof (status), &(rm), sizeof (rm), &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(argv), sizeof (argv), &(argc), sizeof (argc)))) {
    rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));
    strcpy(rm, x);
    status = 0;
    continue;
}

//CodeSeg 1:
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:31
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:148
--Src File: prog.c
Fragment 0:
if ((status == -1) || (__abst_hole(status, rm, f, l, node, n1, n4, n2, n3, argv, argc))) {
    rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));
    strcpy(rm, x);
    status = 0;
    continue;
}


CondTester, a patch instance with id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        
//Patch 0:
if ((status == -1) || (__is_neg(11, &(status), sizeof (status), &(rm), sizeof (rm), &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(argv), sizeof (argv), &(argc), sizeof (argc)))) {
    rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));
    strcpy(rm, x);
    status = 0;
    continue;
}

//CodeSeg 1:
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 32
Counter: 33
Batcher Size:32
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:76
--Src File: prog.c
Fragment 0:
if ((ln2->next == l->head || ln2->next->next == l->head) && !(__abst_hole(l, ln2, l->head, ln2->next, ln2->next->next, ln1, ln1->next, l->head->next, l->head->element, l->head->previous, ln1->element, ln1->previous, l->size, ln2->element, ln2->previous, ln2->next->element, ln2->next->previous)))
    return 1;
else
    ln2 = ln2->next->next;


CondTester, a patch instance with id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        
//Patch 0:
if ((ln2->next == l->head || ln2->next->next == l->head) && !(__is_neg(17, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(ln1->element), sizeof (ln1->element), &(ln1->previous), sizeof (ln1->previous), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->previous), sizeof (ln2->previous), &(ln2->next->element), sizeof (ln2->next->element), &(ln2->next->previous), sizeof (ln2->next->previous))))
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:33
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:80
--Src File: prog.c
Fragment 0:
if ((ln1 == ln2) && !(__abst_hole(ln1, ln2, ln2->next, ln2->next->next, l, ln1->next, ln1->element, ln1->previous, ln2->element, ln2->previous, ln2->next->element, ln2->next->previous)))
    return 0;


CondTester, a patch instance with id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((ln1 == ln2) && !(__is_neg(12, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln1->previous), sizeof (ln1->previous), &(ln2->element), sizeof (ln2->element), &(ln2->previous), sizeof (ln2->previous), &(ln2->next->element), sizeof (ln2->next->element), &(ln2->next->previous), sizeof (ln2->next->previous))))
    return 0;

//CodeSeg 1:
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:34
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:80
--Src File: prog.c
Fragment 0:
if ((ln1 == ln2) || (__abst_hole(ln1, ln2, ln2->next, ln2->next->next, l, ln1->next, ln1->element, ln1->previous, ln2->element, ln2->previous, ln2->next->element, ln2->next->previous)))
    return 0;


CondTester, a patch instance with id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((ln1 == ln2) || (__is_neg(12, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln1->previous), sizeof (ln1->previous), &(ln2->element), sizeof (ln2->element), &(ln2->previous), sizeof (ln2->previous), &(ln2->next->element), sizeof (ln2->next->element), &(ln2->next->previous), sizeof (ln2->next->previous))))
    return 0;

//CodeSeg 1:
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:35
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:88
--Src File: prog.c
Fragment 0:
if ((l->head->previous == l->head) && !(__abst_hole(l, l->head->previous, l->head, l->head->element, l->head->next, l->size)))
    return 1;


CondTester, a patch instance with id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    
//Patch 0:
if ((l->head->previous == l->head) && !(__is_neg(6, &(l), sizeof (l), &(l->head->previous), sizeof (l->head->previous), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->head->next), sizeof (l->head->next), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:36
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:88
--Src File: prog.c
Fragment 0:
if ((l->head->previous == l->head) || (__abst_hole(l, l->head->previous, l->head, l->head->element, l->head->next, l->size)))
    return 1;


CondTester, a patch instance with id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    
//Patch 0:
if ((l->head->previous == l->head) || (__is_neg(6, &(l), sizeof (l), &(l->head->previous), sizeof (l->head->previous), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->head->next), sizeof (l->head->next), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:37
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:76
--Src File: prog.c
Fragment 0:
if ((ln2->next == l->head || ln2->next->next == l->head) || (__abst_hole(l, ln2, l->head, ln2->next, ln2->next->next, ln1, ln1->next, l->head->next, l->head->element, l->head->previous, ln1->element, ln1->previous, l->size, ln2->element, ln2->previous, ln2->next->element, ln2->next->previous)))
    return 1;
else
    ln2 = ln2->next->next;


CondTester, a patch instance with id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        
//Patch 0:
if ((ln2->next == l->head || ln2->next->next == l->head) || (__is_neg(17, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(ln1->element), sizeof (ln1->element), &(ln1->previous), sizeof (ln1->previous), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->previous), sizeof (ln2->previous), &(ln2->next->element), sizeof (ln2->next->element), &(ln2->next->previous), sizeof (ln2->next->previous))))
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:38
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:146
--Src File: prog.c
Fragment 0:
if ((x[0] == '"') && !(__abst_hole(f, status, l, rm, n4, n3, node, n1, n2, argv, argc)))
    continue;


CondTester, a patch instance with id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') && !(__is_neg(11, &(f), sizeof (f), &(status), sizeof (status), &(l), sizeof (l), &(rm), sizeof (rm), &(n4), sizeof (n4), &(n3), sizeof (n3), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 39
Counter: 40
Batcher Size:39
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:146
--Src File: prog.c
Fragment 0:
if ((x[0] == '"') || (__abst_hole(f, status, l, rm, n4, n3, node, n1, n2, argv, argc)))
    continue;


CondTester, a patch instance with id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') || (__is_neg(11, &(f), sizeof (f), &(status), sizeof (status), &(l), sizeof (l), &(rm), sizeof (rm), &(n4), sizeof (n4), &(n3), sizeof (n3), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 40
Counter: 41
Batcher Size:40
Preprocess the following candidate with CondTester:
Priority 12473
At location prog.c:45
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, e, (*e)->previous, (*l)->head, (*l)->head->next, (*e)->next, (*e)->next->previous, (*e)->previous->next, (*l)->size, (*l)->head->element, (*l)->head->previous, (*e)->next->element, (*e)->next->next, (*e)->element, (*e)->previous->element, (*e)->previous->previous)))
    return;
(*e)->previous = (*l)->head;


CondTester, a patch instance with id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
if ((__is_neg(16, &(l), sizeof (l), &(e), sizeof (e), &((*e)->previous), sizeof ((*e)->previous), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*e)->next), sizeof ((*e)->next), &((*e)->next->previous), sizeof ((*e)->next->previous), &((*e)->previous->next), sizeof ((*e)->previous->next), &((*l)->size), sizeof ((*l)->size), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*e)->next->element), sizeof ((*e)->next->element), &((*e)->next->next), sizeof ((*e)->next->next), &((*e)->element), sizeof ((*e)->element), &((*e)->previous->element), sizeof ((*e)->previous->element), &((*e)->previous->previous), sizeof ((*e)->previous->previous))))
    return;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 41
Counter: 42
Batcher Size:41
Preprocess the following candidate with CondTester:
Priority 12457
At location prog.c:109
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, e, (*l)->head, rm, (*l)->head->next, e->element, e->next, e->previous, (*l)->head->element, (*l)->head->previous, (*l)->size)))
    return 0;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }


CondTester, a patch instance with id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(e), sizeof (e), &((*l)->head), sizeof ((*l)->head), &(rm), sizeof (rm), &((*l)->head->next), sizeof ((*l)->head->next), &(e->element), sizeof (e->element), &(e->next), sizeof (e->next), &(e->previous), sizeof (e->previous), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*l)->size), sizeof ((*l)->size))))
    return 0;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 42
Counter: 43
Batcher Size:42
Preprocess the following candidate with CondTester:
Priority 12457
At location prog.c:109
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, e, (*l)->head, rm, (*l)->head->next, e->element, e->next, e->previous, (*l)->head->element, (*l)->head->previous, (*l)->size)))
    return 1;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }


CondTester, a patch instance with id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(e), sizeof (e), &((*l)->head), sizeof ((*l)->head), &(rm), sizeof (rm), &((*l)->head->next), sizeof ((*l)->head->next), &(e->element), sizeof (e->element), &(e->next), sizeof (e->next), &(e->previous), sizeof (e->previous), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*l)->size), sizeof ((*l)->size))))
    return 1;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 43
Counter: 44
Batcher Size:43
Preprocess the following candidate with CondTester:
Priority 12454
At location prog.c:88
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->head->previous, l->head, l->head->element, l->head->next, l->size)))
    return 0;
if (l->head->previous == l->head)
    return 1;


CondTester, a patch instance with id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(l->head->previous), sizeof (l->head->previous), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->head->next), sizeof (l->head->next), &(l->size), sizeof (l->size))))
    return 0;
if (l->head->previous == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 44
Counter: 45
Batcher Size:44
Preprocess the following candidate with CondTester:
Priority 12454
At location prog.c:88
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->head->previous, l->head, l->head->element, l->head->next, l->size)))
    return 1;
if (l->head->previous == l->head)
    return 1;


CondTester, a patch instance with id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(l->head->previous), sizeof (l->head->previous), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->head->next), sizeof (l->head->next), &(l->size), sizeof (l->size))))
    return 1;
if (l->head->previous == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 45
Counter: 46
Batcher Size:45
Preprocess the following candidate with CondTester:
Priority 12452
At location prog.c:67
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->head->next, l->head, l->head->element, l->head->previous, l->size)))
    return 0;
if (l->head->next == l->head)
    return 1;


CondTester, a patch instance with id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(l->size), sizeof (l->size))))
    return 0;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 46
Counter: 47
Batcher Size:46
Preprocess the following candidate with CondTester:
Priority 12452
At location prog.c:67
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->head->next, l->head, l->head->element, l->head->previous, l->size)))
    return 1;
if (l->head->next == l->head)
    return 1;


CondTester, a patch instance with id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(l->size), sizeof (l->size))))
    return 1;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 47
Counter: 48
Batcher Size:47
Preprocess the following candidate with CondTester:
Priority 12440
At location prog.c:37
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n)))
    return;
*n = malloc(sizeof(struct Entry));


CondTester, a patch instance with id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    
//Patch 0:
if ((__is_neg(1, &(n), sizeof (n))))
    return;
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 48
Counter: 49
Batcher Size:48
Preprocess the following candidate with CondTester:
Priority 12418
At location prog.c:25
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l)))
    return;
*l = malloc(sizeof(struct List));


CondTester, a patch instance with id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
if ((__is_neg(1, &(l), sizeof (l))))
    return;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 49
Counter: 50
Batcher Size:49
Preprocess the following candidate with CondTester:
Priority 12413
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return -1;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return -1;
if (argc < 2)
    return 0;

//CodeSeg 1:
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 50
Counter: 51
Batcher Size:50
Preprocess the following candidate with CondTester:
Priority 12413
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 0;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 51
Counter: 52
Batcher Size:51
Preprocess the following candidate with CondTester:
Priority 12413
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 1;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 1;
if (argc < 2)
    return 0;

//CodeSeg 1:
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 52
Counter: 53
Batcher Size:52
Preprocess the following candidate with CondTester:
Priority 12413
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 2;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 2;
if (argc < 2)
    return 0;

//CodeSeg 1:
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 53
Counter: 54
Batcher Size:53
Preprocess the following candidate with CondTester:
Priority 12413
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 20;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 20;
if (argc < 2)
    return 0;

//CodeSeg 1:
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 54
Counter: 55
Batcher Size:54
Preprocess the following candidate with CondTester:
Priority 9994
At location prog.c:180
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->element, l, n->previous->element, n->previous, l->head, l->head->next, n->next, rm, l->size, f, node, n4, n3, n2, n1, status, argv, argc, l->head->element, l->head->previous, n->previous->next, n->previous->previous)))
    return -1;
printf("%s ", n->element);


CondTester, a patch instance with id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        
//Patch 0:
if ((__is_neg(23, &(n), sizeof (n), &(n->element), sizeof (n->element), &(l), sizeof (l), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(l->head), sizeof (l->head), &(l->head->next), sizeof (l->head->next), &(n->next), sizeof (n->next), &(rm), sizeof (rm), &(l->size), sizeof (l->size), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous))))
    return -1;
printf("%s ", n->element);

//CodeSeg 1:
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 55
Counter: 56
Batcher Size:55
Preprocess the following candidate with CondTester:
Priority 9994
At location prog.c:180
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->element, l, n->previous->element, n->previous, l->head, l->head->next, n->next, rm, l->size, f, node, n4, n3, n2, n1, status, argv, argc, l->head->element, l->head->previous, n->previous->next, n->previous->previous)))
    return 0;
printf("%s ", n->element);


CondTester, a patch instance with id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        
//Patch 0:
if ((__is_neg(23, &(n), sizeof (n), &(n->element), sizeof (n->element), &(l), sizeof (l), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(l->head), sizeof (l->head), &(l->head->next), sizeof (l->head->next), &(n->next), sizeof (n->next), &(rm), sizeof (rm), &(l->size), sizeof (l->size), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous))))
    return 0;
printf("%s ", n->element);

//CodeSeg 1:
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 56
Counter: 57
Batcher Size:56
Preprocess the following candidate with CondTester:
Priority 9994
At location prog.c:180
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->element, l, n->previous->element, n->previous, l->head, l->head->next, n->next, rm, l->size, f, node, n4, n3, n2, n1, status, argv, argc, l->head->element, l->head->previous, n->previous->next, n->previous->previous)))
    return 1;
printf("%s ", n->element);


CondTester, a patch instance with id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        
//Patch 0:
if ((__is_neg(23, &(n), sizeof (n), &(n->element), sizeof (n->element), &(l), sizeof (l), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(l->head), sizeof (l->head), &(l->head->next), sizeof (l->head->next), &(n->next), sizeof (n->next), &(rm), sizeof (rm), &(l->size), sizeof (l->size), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous))))
    return 1;
printf("%s ", n->element);

//CodeSeg 1:
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 57
Counter: 58
Batcher Size:57
Preprocess the following candidate with CondTester:
Priority 9994
At location prog.c:180
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->element, l, n->previous->element, n->previous, l->head, l->head->next, n->next, rm, l->size, f, node, n4, n3, n2, n1, status, argv, argc, l->head->element, l->head->previous, n->previous->next, n->previous->previous)))
    return 2;
printf("%s ", n->element);


CondTester, a patch instance with id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        
//Patch 0:
if ((__is_neg(23, &(n), sizeof (n), &(n->element), sizeof (n->element), &(l), sizeof (l), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(l->head), sizeof (l->head), &(l->head->next), sizeof (l->head->next), &(n->next), sizeof (n->next), &(rm), sizeof (rm), &(l->size), sizeof (l->size), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous))))
    return 2;
printf("%s ", n->element);

//CodeSeg 1:
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 58
Counter: 59
Batcher Size:58
Preprocess the following candidate with CondTester:
Priority 9994
At location prog.c:180
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->element, l, n->previous->element, n->previous, l->head, l->head->next, n->next, rm, l->size, f, node, n4, n3, n2, n1, status, argv, argc, l->head->element, l->head->previous, n->previous->next, n->previous->previous)))
    break;
printf("%s ", n->element);


CondTester, a patch instance with id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        
//Patch 0:
if ((__is_neg(23, &(n), sizeof (n), &(n->element), sizeof (n->element), &(l), sizeof (l), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(l->head), sizeof (l->head), &(l->head->next), sizeof (l->head->next), &(n->next), sizeof (n->next), &(rm), sizeof (rm), &(l->size), sizeof (l->size), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous))))
    break;
printf("%s ", n->element);

//CodeSeg 1:
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 59
Counter: 60
Batcher Size:59
Preprocess the following candidate with CondTester:
Priority 9994
At location prog.c:180
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->element, l, n->previous->element, n->previous, l->head, l->head->next, n->next, rm, l->size, f, node, n4, n3, n2, n1, status, argv, argc, l->head->element, l->head->previous, n->previous->next, n->previous->previous)))
    return 20;
printf("%s ", n->element);


CondTester, a patch instance with id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        
//Patch 0:
if ((__is_neg(23, &(n), sizeof (n), &(n->element), sizeof (n->element), &(l), sizeof (l), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(l->head), sizeof (l->head), &(l->head->next), sizeof (l->head->next), &(n->next), sizeof (n->next), &(rm), sizeof (rm), &(l->size), sizeof (l->size), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous))))
    return 20;
printf("%s ", n->element);

//CodeSeg 1:
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 60
Counter: 61
Batcher Size:60
Preprocess the following candidate with CondTester:
Priority 9993
At location prog.c:110
--Src File: prog.c
Fragment 0:
if ((__abst_hole(rm, e, e->element, l, (*l)->head, e->next, (*l)->head->next, e->next->previous, e->previous, (*l)->head->element, (*l)->head->previous, (*l)->size, e->next->element, e->next->next)))
    return 0;
if (strcmp(e->element, rm) != 0) {
    e = e->next;
    continue;
}


CondTester, a patch instance with id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        
//Patch 0:
if ((__is_neg(14, &(rm), sizeof (rm), &(e), sizeof (e), &(e->element), sizeof (e->element), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(e->next), sizeof (e->next), &((*l)->head->next), sizeof ((*l)->head->next), &(e->next->previous), sizeof (e->next->previous), &(e->previous), sizeof (e->previous), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*l)->size), sizeof ((*l)->size), &(e->next->element), sizeof (e->next->element), &(e->next->next), sizeof (e->next->next))))
    return 0;
if (strcmp(e->element, rm) != 0) {
    e = e->next;
    continue;
}

//CodeSeg 1:
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 61
Counter: 62
Batcher Size:61
Preprocess the following candidate with CondTester:
Priority 9993
At location prog.c:110
--Src File: prog.c
Fragment 0:
if ((__abst_hole(rm, e, e->element, l, (*l)->head, e->next, (*l)->head->next, e->next->previous, e->previous, (*l)->head->element, (*l)->head->previous, (*l)->size, e->next->element, e->next->next)))
    return 1;
if (strcmp(e->element, rm) != 0) {
    e = e->next;
    continue;
}


CondTester, a patch instance with id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        
//Patch 0:
if ((__is_neg(14, &(rm), sizeof (rm), &(e), sizeof (e), &(e->element), sizeof (e->element), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(e->next), sizeof (e->next), &((*l)->head->next), sizeof ((*l)->head->next), &(e->next->previous), sizeof (e->next->previous), &(e->previous), sizeof (e->previous), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*l)->size), sizeof ((*l)->size), &(e->next->element), sizeof (e->next->element), &(e->next->next), sizeof (e->next->next))))
    return 1;
if (strcmp(e->element, rm) != 0) {
    e = e->next;
    continue;
}

//CodeSeg 1:
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 62
Counter: 63
Batcher Size:62
Preprocess the following candidate with CondTester:
Priority 9993
At location prog.c:110
--Src File: prog.c
Fragment 0:
if ((__abst_hole(rm, e, e->element, l, (*l)->head, e->next, (*l)->head->next, e->next->previous, e->previous, (*l)->head->element, (*l)->head->previous, (*l)->size, e->next->element, e->next->next)))
    break;
if (strcmp(e->element, rm) != 0) {
    e = e->next;
    continue;
}


CondTester, a patch instance with id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        
//Patch 0:
if ((__is_neg(14, &(rm), sizeof (rm), &(e), sizeof (e), &(e->element), sizeof (e->element), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(e->next), sizeof (e->next), &((*l)->head->next), sizeof ((*l)->head->next), &(e->next->previous), sizeof (e->next->previous), &(e->previous), sizeof (e->previous), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*l)->size), sizeof ((*l)->size), &(e->next->element), sizeof (e->next->element), &(e->next->next), sizeof (e->next->next))))
    break;
if (strcmp(e->element, rm) != 0) {
    e = e->next;
    continue;
}

//CodeSeg 1:
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 63
Counter: 64
Batcher Size:63
Preprocess the following candidate with CondTester:
Priority 9989
At location prog.c:93
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln1, ln1->previous, l->head, ln2, l->head->previous, l->head->element, l->head->next, ln1->element, ln1->next, l->size)))
    break;
if (ln1->previous == l->head)
    return 1;
else
    ln1 = ln1->previous;


CondTester, a patch instance with id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->previous), sizeof (ln1->previous), &(l->head), sizeof (l->head), &(ln2), sizeof (ln2), &(l->head->previous), sizeof (l->head->previous), &(l->head->element), sizeof (l->head->element), &(l->head->next), sizeof (l->head->next), &(ln1->element), sizeof (ln1->element), &(ln1->next), sizeof (ln1->next), &(l->size), sizeof (l->size))))
    break;
if (ln1->previous == l->head)
    return 1;
else
    ln1 = ln1->previous;

//CodeSeg 1:
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 64
Counter: 65
Batcher Size:64
Preprocess the following candidate with CondTester:
Priority 9989
At location prog.c:93
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln1, ln1->previous, l->head, ln2, l->head->previous, l->head->element, l->head->next, ln1->element, ln1->next, l->size)))
    return 0;
if (ln1->previous == l->head)
    return 1;
else
    ln1 = ln1->previous;


CondTester, a patch instance with id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->previous), sizeof (ln1->previous), &(l->head), sizeof (l->head), &(ln2), sizeof (ln2), &(l->head->previous), sizeof (l->head->previous), &(l->head->element), sizeof (l->head->element), &(l->head->next), sizeof (l->head->next), &(ln1->element), sizeof (ln1->element), &(ln1->next), sizeof (ln1->next), &(l->size), sizeof (l->size))))
    return 0;
if (ln1->previous == l->head)
    return 1;
else
    ln1 = ln1->previous;

//CodeSeg 1:
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 65
Counter: 66
Batcher Size:65
Preprocess the following candidate with CondTester:
Priority 9989
At location prog.c:93
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln1, ln1->previous, l->head, ln2, l->head->previous, l->head->element, l->head->next, ln1->element, ln1->next, l->size)))
    return 1;
if (ln1->previous == l->head)
    return 1;
else
    ln1 = ln1->previous;


CondTester, a patch instance with id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->previous), sizeof (ln1->previous), &(l->head), sizeof (l->head), &(ln2), sizeof (ln2), &(l->head->previous), sizeof (l->head->previous), &(l->head->element), sizeof (l->head->element), &(l->head->next), sizeof (l->head->next), &(ln1->element), sizeof (ln1->element), &(ln1->next), sizeof (ln1->next), &(l->size), sizeof (l->size))))
    return 1;
if (ln1->previous == l->head)
    return 1;
else
    ln1 = ln1->previous;

//CodeSeg 1:
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 66
Counter: 67
Batcher Size:66
Preprocess the following candidate with CondTester:
Priority 9982
At location prog.c:72
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln1, ln1->next, l->head, ln2, l->head->next, l->head->element, l->head->previous, ln1->element, ln1->previous, l->size)))
    return 0;
if (ln1->next == l->head)
    return 1;
else
    ln1 = ln1->next;


CondTester, a patch instance with id 66:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(ln1->element), sizeof (ln1->element), &(ln1->previous), sizeof (ln1->previous), &(l->size), sizeof (l->size))))
    return 0;
if (ln1->next == l->head)
    return 1;
else
    ln1 = ln1->next;

//CodeSeg 1:
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 67
Counter: 68
Batcher Size:67
Preprocess the following candidate with CondTester:
Priority 9982
At location prog.c:72
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln1, ln1->next, l->head, ln2, l->head->next, l->head->element, l->head->previous, ln1->element, ln1->previous, l->size)))
    return 1;
if (ln1->next == l->head)
    return 1;
else
    ln1 = ln1->next;


CondTester, a patch instance with id 67:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(ln1->element), sizeof (ln1->element), &(ln1->previous), sizeof (ln1->previous), &(l->size), sizeof (l->size))))
    return 1;
if (ln1->next == l->head)
    return 1;
else
    ln1 = ln1->next;

//CodeSeg 1:
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 68
Counter: 69
Batcher Size:68
Preprocess the following candidate with CondTester:
Priority 9982
At location prog.c:72
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln1, ln1->next, l->head, ln2, l->head->next, l->head->element, l->head->previous, ln1->element, ln1->previous, l->size)))
    break;
if (ln1->next == l->head)
    return 1;
else
    ln1 = ln1->next;


CondTester, a patch instance with id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->head->previous), sizeof (l->head->previous), &(ln1->element), sizeof (ln1->element), &(ln1->previous), sizeof (ln1->previous), &(l->size), sizeof (l->size))))
    break;
if (ln1->next == l->head)
    return 1;
else
    ln1 = ln1->next;

//CodeSeg 1:
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 69
Counter: 70
Batcher Size:69
Preprocess the following candidate with CondTester:
Priority 9962
At location prog.c:149
--Src File: prog.c
Fragment 0:
if ((__abst_hole(rm, status, f, l, node, n1, n2, n4, n3, argv, argc)))
    return -1;
rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));


CondTester, a patch instance with id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            
//Patch 0:
if ((__is_neg(11, &(rm), sizeof (rm), &(status), sizeof (status), &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n4), sizeof (n4), &(n3), sizeof (n3), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return -1;
rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));

//CodeSeg 1:
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 70
Counter: 71
Batcher Size:70
Preprocess the following candidate with CondTester:
Priority 9962
At location prog.c:149
--Src File: prog.c
Fragment 0:
if ((__abst_hole(rm, status, f, l, node, n1, n2, n4, n3, argv, argc)))
    return 0;
rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));


CondTester, a patch instance with id 70:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            
//Patch 0:
if ((__is_neg(11, &(rm), sizeof (rm), &(status), sizeof (status), &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n4), sizeof (n4), &(n3), sizeof (n3), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));

//CodeSeg 1:
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 71
Counter: 72
Batcher Size:71
Preprocess the following candidate with CondTester:
Priority 9962
At location prog.c:149
--Src File: prog.c
Fragment 0:
if ((__abst_hole(rm, status, f, l, node, n1, n2, n4, n3, argv, argc)))
    return 1;
rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));


CondTester, a patch instance with id 71:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            
//Patch 0:
if ((__is_neg(11, &(rm), sizeof (rm), &(status), sizeof (status), &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n4), sizeof (n4), &(n3), sizeof (n3), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));

//CodeSeg 1:
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 72
Counter: 73
Batcher Size:72
Preprocess the following candidate with CondTester:
Priority 9962
At location prog.c:149
--Src File: prog.c
Fragment 0:
if ((__abst_hole(rm, status, f, l, node, n1, n2, n4, n3, argv, argc)))
    return 2;
rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));


CondTester, a patch instance with id 72:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            
//Patch 0:
if ((__is_neg(11, &(rm), sizeof (rm), &(status), sizeof (status), &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n4), sizeof (n4), &(n3), sizeof (n3), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));

//CodeSeg 1:
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 73
Counter: 74
Batcher Size:73
Preprocess the following candidate with CondTester:
Priority 9962
At location prog.c:149
--Src File: prog.c
Fragment 0:
if ((__abst_hole(rm, status, f, l, node, n1, n2, n4, n3, argv, argc)))
    return 20;
rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));


CondTester, a patch instance with id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            
//Patch 0:
if ((__is_neg(11, &(rm), sizeof (rm), &(status), sizeof (status), &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n4), sizeof (n4), &(n3), sizeof (n3), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));

//CodeSeg 1:
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 74
Counter: 75
Batcher Size:74
Preprocess the following candidate with CondTester:
Priority 9962
At location prog.c:149
--Src File: prog.c
Fragment 0:
if ((__abst_hole(rm, status, f, l, node, n1, n2, n4, n3, argv, argc)))
    break;
rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));


CondTester, a patch instance with id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            
//Patch 0:
if ((__is_neg(11, &(rm), sizeof (rm), &(status), sizeof (status), &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n4), sizeof (n4), &(n3), sizeof (n3), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    break;
rm = (char *)malloc(sizeof(char) * (strlen(x) + 1));

//CodeSeg 1:
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 75
Counter: 76
Batcher Size:75
Preprocess the following candidate with CondTester:
Priority 9948
At location prog.c:146
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, status, l, rm, n4, n3, node, n1, n2, argv, argc)))
    return -1;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 75:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(11, &(f), sizeof (f), &(status), sizeof (status), &(l), sizeof (l), &(rm), sizeof (rm), &(n4), sizeof (n4), &(n3), sizeof (n3), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return -1;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 76
Counter: 77
Batcher Size:76
Preprocess the following candidate with CondTester:
Priority 9948
At location prog.c:146
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, status, l, rm, n4, n3, node, n1, n2, argv, argc)))
    return 0;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 76:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(11, &(f), sizeof (f), &(status), sizeof (status), &(l), sizeof (l), &(rm), sizeof (rm), &(n4), sizeof (n4), &(n3), sizeof (n3), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 77
Counter: 78
Batcher Size:77
Preprocess the following candidate with CondTester:
Priority 9948
At location prog.c:146
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, status, l, rm, n4, n3, node, n1, n2, argv, argc)))
    return 1;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(11, &(f), sizeof (f), &(status), sizeof (status), &(l), sizeof (l), &(rm), sizeof (rm), &(n4), sizeof (n4), &(n3), sizeof (n3), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 78
Counter: 79
Batcher Size:78
Preprocess the following candidate with CondTester:
Priority 9948
At location prog.c:146
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, status, l, rm, n4, n3, node, n1, n2, argv, argc)))
    return 2;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(11, &(f), sizeof (f), &(status), sizeof (status), &(l), sizeof (l), &(rm), sizeof (rm), &(n4), sizeof (n4), &(n3), sizeof (n3), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 79
Counter: 80
Batcher Size:79
Preprocess the following candidate with CondTester:
Priority 9948
At location prog.c:146
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, status, l, rm, n4, n3, node, n1, n2, argv, argc)))
    return 20;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 79:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(11, &(f), sizeof (f), &(status), sizeof (status), &(l), sizeof (l), &(rm), sizeof (rm), &(n4), sizeof (n4), &(n3), sizeof (n3), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 80
Counter: 81
Batcher Size:80
Preprocess the following candidate with CondTester:
Priority 9948
At location prog.c:146
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, status, l, rm, n4, n3, node, n1, n2, argv, argc)))
    break;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(11, &(f), sizeof (f), &(status), sizeof (status), &(l), sizeof (l), &(rm), sizeof (rm), &(n4), sizeof (n4), &(n3), sizeof (n3), &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    break;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 81
Counter: 82
Batcher Size:81
Preprocess the following candidate with CondTester:
Priority 9905
At location prog.c:111
--Src File: prog.c
Fragment 0:
if ((__abst_hole(e, e->next, rm, e->element, l, e->next->previous, e->previous, e->next->element, e->next->next)))
    return 0;
e = e->next;


CondTester, a patch instance with id 81:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            
//Patch 0:
if ((__is_neg(9, &(e), sizeof (e), &(e->next), sizeof (e->next), &(rm), sizeof (rm), &(e->element), sizeof (e->element), &(l), sizeof (l), &(e->next->previous), sizeof (e->next->previous), &(e->previous), sizeof (e->previous), &(e->next->element), sizeof (e->next->element), &(e->next->next), sizeof (e->next->next))))
    return 0;
e = e->next;

//CodeSeg 1:
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 82
Counter: 83
Batcher Size:82
Preprocess the following candidate with CondTester:
Priority 9905
At location prog.c:111
--Src File: prog.c
Fragment 0:
if ((__abst_hole(e, e->next, rm, e->element, l, e->next->previous, e->previous, e->next->element, e->next->next)))
    return 1;
e = e->next;


CondTester, a patch instance with id 82:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            
//Patch 0:
if ((__is_neg(9, &(e), sizeof (e), &(e->next), sizeof (e->next), &(rm), sizeof (rm), &(e->element), sizeof (e->element), &(l), sizeof (l), &(e->next->previous), sizeof (e->next->previous), &(e->previous), sizeof (e->previous), &(e->next->element), sizeof (e->next->element), &(e->next->next), sizeof (e->next->next))))
    return 1;
e = e->next;

//CodeSeg 1:
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 83
Counter: 84
Batcher Size:83
Preprocess the following candidate with CondTester:
Priority 9905
At location prog.c:111
--Src File: prog.c
Fragment 0:
if ((__abst_hole(e, e->next, rm, e->element, l, e->next->previous, e->previous, e->next->element, e->next->next)))
    break;
e = e->next;


CondTester, a patch instance with id 83:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            
//Patch 0:
if ((__is_neg(9, &(e), sizeof (e), &(e->next), sizeof (e->next), &(rm), sizeof (rm), &(e->element), sizeof (e->element), &(l), sizeof (l), &(e->next->previous), sizeof (e->next->previous), &(e->previous), sizeof (e->previous), &(e->next->element), sizeof (e->next->element), &(e->next->next), sizeof (e->next->next))))
    break;
e = e->next;

//CodeSeg 1:
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 84
Counter: 85
Batcher Size:84
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:45
--Src File: prog.c
Fragment 0:
(*e)->next = (*(l))->head->next;
(*e)->previous = (*l)->head;


BasicTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*e)->next = (*(l))->head->next;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 85
Counter: 86
Batcher Size:85
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:109
--Src File: prog.c
Fragment 0:
e = (e);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }


BasicTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
e = (e);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 86
Counter: 87
Batcher Size:86
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:25
--Src File: prog.c
Fragment 0:
(*l)->head->element = "H";
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->element = "H";
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 87
Counter: 88
Batcher Size:87
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:37
--Src File: prog.c
Fragment 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Entry));


BasicTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    
//Patch 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 88
Counter: 89
Batcher Size:88
Preprocess the following candidate with StringConstTester:
Priority 7496
At location prog.c:182
--Src File: prog.c
Fragment 0:
printf((__abst_hole()), n->next->element);


StringConstTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
printf(("%s##uni*##"), n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 89
Counter: 90
Batcher Size:89
Preprocess the following candidate with StringConstTester:
Priority 7495
At location prog.c:181
--Src File: prog.c
Fragment 0:
printf((__abst_hole()), n->previous->element);


StringConstTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        
//Patch 0:
printf(("%s##uni*##"), n->previous->element);

//CodeSeg 1:
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 90
Counter: 91
Batcher Size:90
Preprocess the following candidate with StringConstTester:
Priority 7494
At location prog.c:180
--Src File: prog.c
Fragment 0:
printf((__abst_hole()), n->element);


StringConstTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        
//Patch 0:
printf(("%s##uni*##"), n->element);

//CodeSeg 1:
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 91
Counter: 92
Batcher Size:91
Preprocess the following candidate with BasicTester:
Priority 7473
At location prog.c:45
--Src File: prog.c
Fragment 0:
(*l)->size = (1);
(*e)->previous = (*l)->head;


BasicTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*l)->size = (1);
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 92
Counter: 93
Batcher Size:92
Preprocess the following candidate with BasicTester:
Priority 7473
At location prog.c:45
--Src File: prog.c
Fragment 0:
(*e)->previous->next = *e;
(*e)->previous = (*l)->head;


BasicTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*e)->previous->next = *e;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 93
Counter: 94
Batcher Size:93
Preprocess the following candidate with BasicTester:
Priority 7473
At location prog.c:45
--Src File: prog.c
Fragment 0:
(*e)->next = (*l)->head->next;
(*e)->previous = (*l)->head;


BasicTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*e)->next = (*l)->head->next;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 94
Counter: 95
Batcher Size:94
Preprocess the following candidate with BasicTester:
Priority 7473
At location prog.c:45
--Src File: prog.c
Fragment 0:
printf("%s", "HAS LOOP");
(*e)->previous = (*l)->head;


BasicTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
printf("%s", "HAS LOOP");
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 95
Counter: 96
Batcher Size:95
Preprocess the following candidate with BasicTester:
Priority 7473
At location prog.c:45
--Src File: prog.c
Fragment 0:
(*l)->size = (*l)->size + 1;
(*e)->previous = (*l)->head;


BasicTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*l)->size = (*l)->size + 1;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 96
Counter: 97
Batcher Size:96
Preprocess the following candidate with BasicTester:
Priority 7473
At location prog.c:45
--Src File: prog.c
Fragment 0:
(*l)->size = (0);
(*e)->previous = (*l)->head;


BasicTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*l)->size = (0);
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 97
Counter: 98
Batcher Size:97
Preprocess the following candidate with BasicTester:
Priority 7473
At location prog.c:45
--Src File: prog.c
Fragment 0:
(*l)->size = (*(l))->size + 1;
(*e)->previous = (*l)->head;


BasicTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*l)->size = (*(l))->size + 1;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 98
Counter: 99
Batcher Size:98
Preprocess the following candidate with BasicTester:
Priority 7473
At location prog.c:45
--Src File: prog.c
Fragment 0:
(*e)->previous->next = *(e);
(*e)->previous = (*l)->head;


BasicTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*e)->previous->next = *(e);
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 99
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(16, &(l), sizeof (l), &(e), sizeof (e), &((*e)->previous), sizeof ((*e)->previous), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*e)->next), sizeof ((*e)->next), &((*e)->next->previous), sizeof ((*e)->next->previous), &((*e)->previous->next), sizeof ((*e)->previous->next), &((*l)->size), sizeof ((*l)->size), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*e)->next->element), sizeof ((*e)->next->element), &((*e)->next->next), sizeof ((*e)->next->next), &((*e)->element), sizeof ((*e)->element), &((*e)->previous->element), sizeof ((*e)->previous->element), &((*e)->previous->previous), sizeof ((*e)->previous->previous))))
        return;
    (*e)->previous = (*l)->head;
    }
    else if (__get_mutant()==1) {
    (*e)->next = (*(l))->head->next;
    (*e)->previous = (*l)->head;
    }
    else if (__get_mutant()==2) {
    (*l)->size = (1);
    (*e)->previous = (*l)->head;
    }
    else if (__get_mutant()==3) {
    (*e)->previous->next = *e;
    (*e)->previous = (*l)->head;
    }
    else if (__get_mutant()==4) {
    (*e)->next = (*l)->head->next;
    (*e)->previous = (*l)->head;
    }
    else if (__get_mutant()==5) {
    printf("%s", "HAS LOOP");
    (*e)->previous = (*l)->head;
    }
    else if (__get_mutant()==6) {
    (*l)->size = (*l)->size + 1;
    (*e)->previous = (*l)->head;
    }
    else if (__get_mutant()==7) {
    (*l)->size = (0);
    (*e)->previous = (*l)->head;
    }
    else if (__get_mutant()==8) {
    (*l)->size = (*(l))->size + 1;
    (*e)->previous = (*l)->head;
    }
    else if (__get_mutant()==9) {
    (*e)->previous->next = *(e);
    (*e)->previous = (*l)->head;
    }
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
if ((__is_neg(16, &(l), sizeof (l), &(e), sizeof (e), &((*e)->previous), sizeof ((*e)->previous), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*e)->next), sizeof ((*e)->next), &((*e)->next->previous), sizeof ((*e)->next->previous), &((*e)->previous->next), sizeof ((*e)->previous->next), &((*l)->size), sizeof ((*l)->size), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*e)->next->element), sizeof ((*e)->next->element), &((*e)->next->next), sizeof ((*e)->next->next), &((*e)->element), sizeof ((*e)->element), &((*e)->previous->element), sizeof ((*e)->previous->element), &((*e)->previous->previous), sizeof ((*e)->previous->previous))))
    return;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*e)->next = (*(l))->head->next;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*l)->size = (1);
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*e)->previous->next = *e;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*e)->next = (*l)->head->next;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
printf("%s", "HAS LOOP");
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*l)->size = (*l)->size + 1;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*l)->size = (0);
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*l)->size = (*(l))->size + 1;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*e)->previous->next = *(e);
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
Counter: 100
Batcher Size:89
Preprocess the following candidate with BasicTester:
Priority 7473
At location prog.c:45
--Src File: prog.c
Fragment 0:
(*e)->previous = (*l)->head;
(*e)->previous = (*l)->head;


BasicTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*e)->previous = (*l)->head;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 100
Counter: 101
Batcher Size:90
Preprocess the following candidate with BasicTester:
Priority 7473
At location prog.c:45
--Src File: prog.c
Fragment 0:
(*e)->next->previous = *e;
(*e)->previous = (*l)->head;


BasicTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*e)->next->previous = *e;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 101
Counter: 102
Batcher Size:91
Preprocess the following candidate with BasicTester:
Priority 7473
At location prog.c:45
--Src File: prog.c
Fragment 0:
(*e)->previous = (*(l))->head;
(*e)->previous = (*l)->head;


BasicTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*e)->previous = (*(l))->head;
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 102
Counter: 103
Batcher Size:92
Preprocess the following candidate with BasicTester:
Priority 7473
At location prog.c:45
--Src File: prog.c
Fragment 0:
(*e)->next->previous = *(e);
(*e)->previous = (*l)->head;


BasicTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    
//Patch 0:
(*e)->next->previous = *(e);
(*e)->previous = (*l)->head;

//CodeSeg 1:
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 103
Counter: 104
Batcher Size:93
Preprocess the following candidate with StringConstTester:
Priority 7460
At location prog.c:185
--Src File: prog.c
Fragment 0:
printf((__abst_hole()), l->size);


StringConstTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    
//Patch 0:
printf((" %##uni*##"), l->size);

//CodeSeg 1:
    return 0;

}

Spawn 1 instances, now Total 104
Counter: 105
Batcher Size:94
Preprocess the following candidate with BasicTester:
Priority 7457
At location prog.c:109
--Src File: prog.c
Fragment 0:
e->next->previous = e->previous;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }


BasicTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
e->next->previous = e->previous;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 105
Counter: 106
Batcher Size:95
Preprocess the following candidate with BasicTester:
Priority 7457
At location prog.c:109
--Src File: prog.c
Fragment 0:
printf("%s ", (e)->previous->element);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }


BasicTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
printf("%s ", (e)->previous->element);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 106
Counter: 107
Batcher Size:96
Preprocess the following candidate with BasicTester:
Priority 7457
At location prog.c:109
--Src File: prog.c
Fragment 0:
printf("%s", "HAS LOOP");
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }


BasicTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
printf("%s", "HAS LOOP");
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 107
Counter: 108
Batcher Size:97
Preprocess the following candidate with BasicTester:
Priority 7457
At location prog.c:109
--Src File: prog.c
Fragment 0:
newNode(&(e));
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }


BasicTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
newNode(&(e));
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 108
Counter: 109
Batcher Size:98
Preprocess the following candidate with BasicTester:
Priority 7457
At location prog.c:109
--Src File: prog.c
Fragment 0:
printf("%s ", (e)->element);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }


BasicTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
printf("%s ", (e)->element);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 109
Counter: 110
Batcher Size:99
Preprocess the following candidate with BasicTester:
Priority 7457
At location prog.c:109
--Src File: prog.c
Fragment 0:
printf("%s ", (e)->next->element);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }


BasicTester, a patch instance with id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
printf("%s ", (e)->next->element);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 110
Counter: 111
Batcher Size:100
Preprocess the following candidate with BasicTester:
Priority 7457
At location prog.c:109
--Src File: prog.c
Fragment 0:
e->next->previous = (e);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }


BasicTester, a patch instance with id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
e->next->previous = (e);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 111
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(11, &(l), sizeof (l), &(e), sizeof (e), &((*l)->head), sizeof ((*l)->head), &(rm), sizeof (rm), &((*l)->head->next), sizeof ((*l)->head->next), &(e->element), sizeof (e->element), &(e->next), sizeof (e->next), &(e->previous), sizeof (e->previous), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*l)->size), sizeof ((*l)->size))))
        return 0;
    while (e != (*l)->head)
        {
            if (strcmp(e->element, rm) != 0) {
                e = e->next;
                continue;
            }
            e->next->previous = e->previous;
            return 0;
        }
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(11, &(l), sizeof (l), &(e), sizeof (e), &((*l)->head), sizeof ((*l)->head), &(rm), sizeof (rm), &((*l)->head->next), sizeof ((*l)->head->next), &(e->element), sizeof (e->element), &(e->next), sizeof (e->next), &(e->previous), sizeof (e->previous), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*l)->size), sizeof ((*l)->size))))
        return 1;
    while (e != (*l)->head)
        {
            if (strcmp(e->element, rm) != 0) {
                e = e->next;
                continue;
            }
            e->next->previous = e->previous;
            return 0;
        }
    }
    else if (__get_mutant()==2) {
    e = (e);
    while (e != (*l)->head)
        {
            if (strcmp(e->element, rm) != 0) {
                e = e->next;
                continue;
            }
            e->next->previous = e->previous;
            return 0;
        }
    }
    else if (__get_mutant()==3) {
    e->next->previous = e->previous;
    while (e != (*l)->head)
        {
            if (strcmp(e->element, rm) != 0) {
                e = e->next;
                continue;
            }
            e->next->previous = e->previous;
            return 0;
        }
    }
    else if (__get_mutant()==4) {
    printf("%s ", (e)->previous->element);
    while (e != (*l)->head)
        {
            if (strcmp(e->element, rm) != 0) {
                e = e->next;
                continue;
            }
            e->next->previous = e->previous;
            return 0;
        }
    }
    else if (__get_mutant()==5) {
    printf("%s", "HAS LOOP");
    while (e != (*l)->head)
        {
            if (strcmp(e->element, rm) != 0) {
                e = e->next;
                continue;
            }
            e->next->previous = e->previous;
            return 0;
        }
    }
    else if (__get_mutant()==6) {
    newNode(&(e));
    while (e != (*l)->head)
        {
            if (strcmp(e->element, rm) != 0) {
                e = e->next;
                continue;
            }
            e->next->previous = e->previous;
            return 0;
        }
    }
    else if (__get_mutant()==7) {
    printf("%s ", (e)->element);
    while (e != (*l)->head)
        {
            if (strcmp(e->element, rm) != 0) {
                e = e->next;
                continue;
            }
            e->next->previous = e->previous;
            return 0;
        }
    }
    else if (__get_mutant()==8) {
    printf("%s ", (e)->next->element);
    while (e != (*l)->head)
        {
            if (strcmp(e->element, rm) != 0) {
                e = e->next;
                continue;
            }
            e->next->previous = e->previous;
            return 0;
        }
    }
    else if (__get_mutant()==9) {
    e->next->previous = (e);
    while (e != (*l)->head)
        {
            if (strcmp(e->element, rm) != 0) {
                e = e->next;
                continue;
            }
            e->next->previous = e->previous;
            return 0;
        }
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(e), sizeof (e), &((*l)->head), sizeof ((*l)->head), &(rm), sizeof (rm), &((*l)->head->next), sizeof ((*l)->head->next), &(e->element), sizeof (e->element), &(e->next), sizeof (e->next), &(e->previous), sizeof (e->previous), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*l)->size), sizeof ((*l)->size))))
    return 0;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(e), sizeof (e), &((*l)->head), sizeof ((*l)->head), &(rm), sizeof (rm), &((*l)->head->next), sizeof ((*l)->head->next), &(e->element), sizeof (e->element), &(e->next), sizeof (e->next), &(e->previous), sizeof (e->previous), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->head->previous), sizeof ((*l)->head->previous), &((*l)->size), sizeof ((*l)->size))))
    return 1;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
e = (e);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
e->next->previous = e->previous;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
printf("%s ", (e)->previous->element);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
printf("%s", "HAS LOOP");
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
newNode(&(e));
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
printf("%s ", (e)->element);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
printf("%s ", (e)->next->element);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
e->next->previous = (e);
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
Counter: 112
Batcher Size:91
Preprocess the following candidate with BasicTester:
Priority 7457
At location prog.c:109
--Src File: prog.c
Fragment 0:
e->next->previous = (e)->previous;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }


BasicTester, a patch instance with id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
e->next->previous = (e)->previous;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 112
Counter: 113
Batcher Size:92
Preprocess the following candidate with BasicTester:
Priority 7457
At location prog.c:109
--Src File: prog.c
Fragment 0:
e = (e)->next;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }


BasicTester, a patch instance with id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
e = (e)->next;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 113
Counter: 114
Batcher Size:93
Preprocess the following candidate with BasicTester:
Priority 7457
At location prog.c:109
--Src File: prog.c
Fragment 0:
e = e->next;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }


BasicTester, a patch instance with id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    
//Patch 0:
e = e->next;
while (e != (*l)->head)
    {
        if (strcmp(e->element, rm) != 0) {
            e = e->next;
            continue;
        }
        e->next->previous = e->previous;
        return 0;
    }

//CodeSeg 1:
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 114
Counter: 115
Batcher Size:94
Preprocess the following candidate with StringConstTester:
Priority 7455
At location prog.c:177
--Src File: prog.c
Fragment 0:
printf((__abst_hole()), removeEntry(&l, rm));


StringConstTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    
//Patch 0:
printf(("%d##uni*##"), removeEntry(&l, rm));

//CodeSeg 1:
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 115
Counter: 116
Batcher Size:95
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:88
--Src File: prog.c
Fragment 0:
if (l->head->previous == l->head)
    return 1;
if (l->head->previous == l->head)
    return 1;


BasicTester, a patch instance with id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    
//Patch 0:
if (l->head->previous == l->head)
    return 1;
if (l->head->previous == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 116
Counter: 117
Batcher Size:96
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:88
--Src File: prog.c
Fragment 0:
newList(&(l));
if (l->head->previous == l->head)
    return 1;


BasicTester, a patch instance with id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    
//Patch 0:
newList(&(l));
if (l->head->previous == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 117
Counter: 118
Batcher Size:97
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:88
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
if (l->head->previous == l->head)
    return 1;


BasicTester, a patch instance with id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    
//Patch 0:
printf(" %d", (l)->size);
if (l->head->previous == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 118
Counter: 119
Batcher Size:98
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:88
--Src File: prog.c
Fragment 0:
printf("%s", "HAS LOOP");
if (l->head->previous == l->head)
    return 1;


BasicTester, a patch instance with id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    
//Patch 0:
printf("%s", "HAS LOOP");
if (l->head->previous == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 119
Counter: 120
Batcher Size:99
Preprocess the following candidate with BasicTester:
Priority 7452
At location prog.c:67
--Src File: prog.c
Fragment 0:
printf("%s", "HAS LOOP");
if (l->head->next == l->head)
    return 1;


BasicTester, a patch instance with id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    
//Patch 0:
printf("%s", "HAS LOOP");
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 120
Counter: 121
Batcher Size:100
Preprocess the following candidate with BasicTester:
Priority 7452
At location prog.c:67
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
if (l->head->next == l->head)
    return 1;


BasicTester, a patch instance with id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    
//Patch 0:
printf(" %d", (l)->size);
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 121
Counter: 122
Batcher Size:101
Preprocess the following candidate with BasicTester:
Priority 7452
At location prog.c:67
--Src File: prog.c
Fragment 0:
newList(&(l));
if (l->head->next == l->head)
    return 1;


BasicTester, a patch instance with id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    
//Patch 0:
newList(&(l));
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 122
Counter: 123
Batcher Size:102
Preprocess the following candidate with BasicTester:
Priority 7452
At location prog.c:67
--Src File: prog.c
Fragment 0:
if (l->head->next == l->head)
    return 1;
if (l->head->next == l->head)
    return 1;


BasicTester, a patch instance with id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    
//Patch 0:
if (l->head->next == l->head)
    return 1;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 123
Counter: 124
Batcher Size:103
Preprocess the following candidate with BasicTester:
Priority 7440
At location prog.c:37
--Src File: prog.c
Fragment 0:
*n = malloc(sizeof(struct Entry));
*n = malloc(sizeof(struct Entry));


BasicTester, a patch instance with id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    
//Patch 0:
*n = malloc(sizeof(struct Entry));
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 124
Counter: 125
Batcher Size:104
Preprocess the following candidate with BasicTester:
Priority 7440
At location prog.c:37
--Src File: prog.c
Fragment 0:
printf("%s", "HAS LOOP");
*n = malloc(sizeof(struct Entry));


BasicTester, a patch instance with id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    
//Patch 0:
printf("%s", "HAS LOOP");
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 125
Counter: 126
Batcher Size:105
Preprocess the following candidate with BasicTester:
Priority 7440
At location prog.c:37
--Src File: prog.c
Fragment 0:
(*n)->previous = ((void *)0);
*n = malloc(sizeof(struct Entry));


BasicTester, a patch instance with id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    
//Patch 0:
(*n)->previous = ((void *)0);
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 126
Counter: 127
Batcher Size:106
Preprocess the following candidate with BasicTester:
Priority 7418
At location prog.c:25
--Src File: prog.c
Fragment 0:
(*l)->head->previous = (*l)->head;
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->previous = (*l)->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 127
Counter: 128
Batcher Size:107
Preprocess the following candidate with BasicTester:
Priority 7418
At location prog.c:25
--Src File: prog.c
Fragment 0:
(*l)->head->previous = (*(l))->head;
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->previous = (*(l))->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 128
Counter: 129
Batcher Size:108
Preprocess the following candidate with BasicTester:
Priority 7418
At location prog.c:25
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*(l))->head;
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*(l))->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 129
Counter: 130
Batcher Size:109
Preprocess the following candidate with BasicTester:
Priority 7418
At location prog.c:25
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*l)->head;
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*l)->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 130
Counter: 131
Batcher Size:110
Preprocess the following candidate with BasicTester:
Priority 7418
At location prog.c:25
--Src File: prog.c
Fragment 0:
printf("%s", "HAS LOOP");
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
printf("%s", "HAS LOOP");
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 131
Counter: 132
Batcher Size:111
Preprocess the following candidate with BasicTester:
Priority 7418
At location prog.c:25
--Src File: prog.c
Fragment 0:
*l = malloc(sizeof(struct List));
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
*l = malloc(sizeof(struct List));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 132
Counter: 133
Batcher Size:112
Preprocess the following candidate with BasicTester:
Priority 7418
At location prog.c:25
--Src File: prog.c
Fragment 0:
(*l)->size = (0);
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->size = (0);
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 133
Counter: 134
Batcher Size:113
Preprocess the following candidate with BasicTester:
Priority 7418
At location prog.c:25
--Src File: prog.c
Fragment 0:
(*l)->size = 0;
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->size = 0;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 134
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(1, &(l), sizeof (l))))
        return;
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==1) {
    (*l)->head->element = "H";
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==2) {
    (*l)->head->previous = (*l)->head;
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==3) {
    (*l)->head->previous = (*(l))->head;
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==4) {
    (*l)->head->next = (*(l))->head;
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==5) {
    (*l)->head->next = (*l)->head;
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==6) {
    printf("%s", "HAS LOOP");
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==7) {
    *l = malloc(sizeof(struct List));
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==8) {
    (*l)->size = (0);
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==9) {
    (*l)->size = 0;
    *l = malloc(sizeof(struct List));
    }
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
if ((__is_neg(1, &(l), sizeof (l))))
    return;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->element = "H";
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->previous = (*l)->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->previous = (*(l))->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*(l))->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*l)->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
printf("%s", "HAS LOOP");
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
*l = malloc(sizeof(struct List));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->size = (0);
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    
//Patch 0:
(*l)->size = 0;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
Counter: 135
Batcher Size:104
Preprocess the following candidate with BasicTester:
Priority 7413
At location prog.c:123
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;


BasicTester, a patch instance with id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     
//Patch 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 135
Counter: 136
Batcher Size:105
Preprocess the following candidate with BasicTester:
Priority 7413
At location prog.c:123
--Src File: prog.c
Fragment 0:
printf("%s", "HAS LOOP");
if (argc < 2)
    return 0;


BasicTester, a patch instance with id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     
//Patch 0:
printf("%s", "HAS LOOP");
if (argc < 2)
    return 0;

//CodeSeg 1:
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 136
Counter: 137
Batcher Size:106
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:117
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(e, rm, l)))
    return 0;


CondTester, a patch instance with id 84:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        
//Patch 0:
if (!(__is_neg(3, &(e), sizeof (e), &(rm), sizeof (rm), &(l), sizeof (l))))
    return 0;

//CodeSeg 1:
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 137
Counter: 138
Batcher Size:107
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:117
--Src File: prog.c
Fragment 0:
if ((__abst_hole(e, rm, l)))
    return 0;
return 0;


CondTester, a patch instance with id 85:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        
//Patch 0:
if ((__is_neg(3, &(e), sizeof (e), &(rm), sizeof (rm), &(l), sizeof (l))))
    return 0;
return 0;

//CodeSeg 1:
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 138
Counter: 139
Batcher Size:108
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:117
--Src File: prog.c
Fragment 0:
if ((__abst_hole(e, rm, l)))
    return 1;
return 0;


CondTester, a patch instance with id 86:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        
//Patch 0:
if ((__is_neg(3, &(e), sizeof (e), &(rm), sizeof (rm), &(l), sizeof (l))))
    return 1;
return 0;

//CodeSeg 1:
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 139
Counter: 140
Batcher Size:109
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:117
--Src File: prog.c
Fragment 0:
if ((__abst_hole(e, rm, l)))
    break;
return 0;


CondTester, a patch instance with id 87:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        
//Patch 0:
if ((__is_neg(3, &(e), sizeof (e), &(rm), sizeof (rm), &(l), sizeof (l))))
    break;
return 0;

//CodeSeg 1:
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 140
Counter: 141
Batcher Size:110
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:115
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(e, e->next->previous, e->next, e->previous, rm, e->element, l, e->next->element, e->next->next)))
    e->next->previous = e->previous;


CondTester, a patch instance with id 88:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        
//Patch 0:
if (!(__is_neg(9, &(e), sizeof (e), &(e->next->previous), sizeof (e->next->previous), &(e->next), sizeof (e->next), &(e->previous), sizeof (e->previous), &(rm), sizeof (rm), &(e->element), sizeof (e->element), &(l), sizeof (l), &(e->next->element), sizeof (e->next->element), &(e->next->next), sizeof (e->next->next))))
    e->next->previous = e->previous;

//CodeSeg 1:
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 141
Counter: 142
Batcher Size:111
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:115
--Src File: prog.c
Fragment 0:
if ((__abst_hole(e, e->next->previous, e->next, e->previous, rm, e->element, l, e->next->element, e->next->next)))
    break;
e->next->previous = e->previous;


CondTester, a patch instance with id 89:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        
//Patch 0:
if ((__is_neg(9, &(e), sizeof (e), &(e->next->previous), sizeof (e->next->previous), &(e->next), sizeof (e->next), &(e->previous), sizeof (e->previous), &(rm), sizeof (rm), &(e->element), sizeof (e->element), &(l), sizeof (l), &(e->next->element), sizeof (e->next->element), &(e->next->next), sizeof (e->next->next))))
    break;
e->next->previous = e->previous;

//CodeSeg 1:
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 142
Counter: 143
Batcher Size:112
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:115
--Src File: prog.c
Fragment 0:
memset(e->next, 0, sizeof (*(e->next)));
e->next->previous = e->previous;


BasicTester, a patch instance with id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        
//Patch 0:
memset(e->next, 0, sizeof (*(e->next)));
e->next->previous = e->previous;

//CodeSeg 1:
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 143
Counter: 144
Batcher Size:113
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:115
--Src File: prog.c
Fragment 0:
if ((__abst_hole(e, e->next->previous, e->next, e->previous, rm, e->element, l, e->next->element, e->next->next)))
    return 0;
e->next->previous = e->previous;


CondTester, a patch instance with id 90:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        
//Patch 0:
if ((__is_neg(9, &(e), sizeof (e), &(e->next->previous), sizeof (e->next->previous), &(e->next), sizeof (e->next), &(e->previous), sizeof (e->previous), &(rm), sizeof (rm), &(e->element), sizeof (e->element), &(l), sizeof (l), &(e->next->element), sizeof (e->next->element), &(e->next->next), sizeof (e->next->next))))
    return 0;
e->next->previous = e->previous;

//CodeSeg 1:
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 144
Counter: 145
Batcher Size:114
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:115
--Src File: prog.c
Fragment 0:
if ((__abst_hole(e, e->next->previous, e->next, e->previous, rm, e->element, l, e->next->element, e->next->next)))
    return 1;
e->next->previous = e->previous;


CondTester, a patch instance with id 91:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        
//Patch 0:
if ((__is_neg(9, &(e), sizeof (e), &(e->next->previous), sizeof (e->next->previous), &(e->next), sizeof (e->next), &(e->previous), sizeof (e->previous), &(rm), sizeof (rm), &(e->element), sizeof (e->element), &(l), sizeof (l), &(e->next->element), sizeof (e->next->element), &(e->next->next), sizeof (e->next->next))))
    return 1;
e->next->previous = e->previous;

//CodeSeg 1:
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 145
Counter: 146
Batcher Size:115
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:115
--Src File: prog.c
Fragment 0:
memset(e, 0, sizeof (*(e)));
e->next->previous = e->previous;


BasicTester, a patch instance with id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        
//Patch 0:
memset(e, 0, sizeof (*(e)));
e->next->previous = e->previous;

//CodeSeg 1:
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 146
Counter: 147
Batcher Size:116
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:155
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(node, n1, n2, n3, status, rm, n4, l, f, n1->element, argv, argc, n1->next, n1->previous)))
        return -1;
    node = n1;
}


CondTester, a patch instance with id 92:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             
//Patch 0:
{
    if ((__is_neg(14, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(status), sizeof (status), &(rm), sizeof (rm), &(n4), sizeof (n4), &(l), sizeof (l), &(f), sizeof (f), &(n1->element), sizeof (n1->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->previous), sizeof (n1->previous))))
        return -1;
    node = n1;
}

//CodeSeg 1:
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 147
Counter: 148
Batcher Size:117
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:155
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(node, n1, n2, n3, status, rm, n4, l, f, n1->element, argv, argc, n1->next, n1->previous)))
        return 0;
    node = n1;
}


CondTester, a patch instance with id 93:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             
//Patch 0:
{
    if ((__is_neg(14, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(status), sizeof (status), &(rm), sizeof (rm), &(n4), sizeof (n4), &(l), sizeof (l), &(f), sizeof (f), &(n1->element), sizeof (n1->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->previous), sizeof (n1->previous))))
        return 0;
    node = n1;
}

//CodeSeg 1:
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 148
Counter: 149
Batcher Size:118
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:155
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(node, n1, n2, n3, status, rm, n4, l, f, n1->element, argv, argc, n1->next, n1->previous)))
        return 1;
    node = n1;
}


CondTester, a patch instance with id 94:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             
//Patch 0:
{
    if ((__is_neg(14, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(status), sizeof (status), &(rm), sizeof (rm), &(n4), sizeof (n4), &(l), sizeof (l), &(f), sizeof (f), &(n1->element), sizeof (n1->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->previous), sizeof (n1->previous))))
        return 1;
    node = n1;
}

//CodeSeg 1:
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 149
Counter: 150
Batcher Size:119
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:155
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(node, n1, n2, n3, status, rm, n4, l, f, n1->element, argv, argc, n1->next, n1->previous)))
        return 2;
    node = n1;
}


CondTester, a patch instance with id 95:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             
//Patch 0:
{
    if ((__is_neg(14, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(status), sizeof (status), &(rm), sizeof (rm), &(n4), sizeof (n4), &(l), sizeof (l), &(f), sizeof (f), &(n1->element), sizeof (n1->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->previous), sizeof (n1->previous))))
        return 2;
    node = n1;
}

//CodeSeg 1:
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 150
Counter: 151
Batcher Size:120
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:155
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(node, n1, n2, n3, status, rm, n4, l, f, n1->element, argv, argc, n1->next, n1->previous)))
        break;
    node = n1;
}


CondTester, a patch instance with id 96:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             
//Patch 0:
{
    if ((__is_neg(14, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(status), sizeof (status), &(rm), sizeof (rm), &(n4), sizeof (n4), &(l), sizeof (l), &(f), sizeof (f), &(n1->element), sizeof (n1->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->previous), sizeof (n1->previous))))
        break;
    node = n1;
}

//CodeSeg 1:
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 151
Counter: 152
Batcher Size:121
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:155
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(node, n1, n2, n3, status, rm, n4, l, f, n1->element, argv, argc, n1->next, n1->previous)))
        return 20;
    node = n1;
}


CondTester, a patch instance with id 97:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             
//Patch 0:
{
    if ((__is_neg(14, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(status), sizeof (status), &(rm), sizeof (rm), &(n4), sizeof (n4), &(l), sizeof (l), &(f), sizeof (f), &(n1->element), sizeof (n1->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->previous), sizeof (n1->previous))))
        return 20;
    node = n1;
}

//CodeSeg 1:
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 152
Counter: 153
Batcher Size:122
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:155
--Src File: prog.c
Fragment 0:
{
    if (!(__abst_hole(node, n1, n2, n3, status, rm, n4, l, f, n1->element, argv, argc, n1->next, n1->previous)))
        node = n1;
}


CondTester, a patch instance with id 98:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             
//Patch 0:
{
    if (!(__is_neg(14, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(status), sizeof (status), &(rm), sizeof (rm), &(n4), sizeof (n4), &(l), sizeof (l), &(f), sizeof (f), &(n1->element), sizeof (n1->element), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->previous), sizeof (n1->previous))))
        node = n1;
}

//CodeSeg 1:
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 153
Counter: 154
Batcher Size:123
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:155
--Src File: prog.c
Fragment 0:
{
    memset(n1, 0, sizeof (*(n1)));
    node = n1;
}


BasicTester, a patch instance with id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             
//Patch 0:
{
    memset(n1, 0, sizeof (*(n1)));
    node = n1;
}

//CodeSeg 1:
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 154
Counter: 155
Batcher Size:124
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:183
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->next, n->next->element, l, n->previous, n->element, rm, f, node, n4, n3, n2, n1, status, argv, argc, n->next->next, n->next->previous)))
    return -1;
n = n->next;


CondTester, a patch instance with id 99:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        
//Patch 0:
if ((__is_neg(18, &(n), sizeof (n), &(n->next), sizeof (n->next), &(n->next->element), sizeof (n->next->element), &(l), sizeof (l), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return -1;
n = n->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 155
Counter: 156
Batcher Size:125
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:183
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->next, n->next->element, l, n->previous, n->element, rm, f, node, n4, n3, n2, n1, status, argv, argc, n->next->next, n->next->previous)))
    return 0;
n = n->next;


CondTester, a patch instance with id 100:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        
//Patch 0:
if ((__is_neg(18, &(n), sizeof (n), &(n->next), sizeof (n->next), &(n->next->element), sizeof (n->next->element), &(l), sizeof (l), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return 0;
n = n->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 156
Counter: 157
Batcher Size:126
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:183
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->next, n->next->element, l, n->previous, n->element, rm, f, node, n4, n3, n2, n1, status, argv, argc, n->next->next, n->next->previous)))
    return 1;
n = n->next;


CondTester, a patch instance with id 101:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        
//Patch 0:
if ((__is_neg(18, &(n), sizeof (n), &(n->next), sizeof (n->next), &(n->next->element), sizeof (n->next->element), &(l), sizeof (l), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return 1;
n = n->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 157
Counter: 158
Batcher Size:127
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:183
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->next, n->next->element, l, n->previous, n->element, rm, f, node, n4, n3, n2, n1, status, argv, argc, n->next->next, n->next->previous)))
    return 2;
n = n->next;


CondTester, a patch instance with id 102:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        
//Patch 0:
if ((__is_neg(18, &(n), sizeof (n), &(n->next), sizeof (n->next), &(n->next->element), sizeof (n->next->element), &(l), sizeof (l), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return 2;
n = n->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 158
Counter: 159
Batcher Size:128
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:183
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->next, n->next->element, l, n->previous, n->element, rm, f, node, n4, n3, n2, n1, status, argv, argc, n->next->next, n->next->previous)))
    return 20;
n = n->next;


CondTester, a patch instance with id 103:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        
//Patch 0:
if ((__is_neg(18, &(n), sizeof (n), &(n->next), sizeof (n->next), &(n->next->element), sizeof (n->next->element), &(l), sizeof (l), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return 20;
n = n->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 159
Counter: 160
Batcher Size:129
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:183
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->next, n->next->element, l, n->previous, n->element, rm, f, node, n4, n3, n2, n1, status, argv, argc, n->next->next, n->next->previous)))
    break;
n = n->next;


CondTester, a patch instance with id 104:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        
//Patch 0:
if ((__is_neg(18, &(n), sizeof (n), &(n->next), sizeof (n->next), &(n->next->element), sizeof (n->next->element), &(l), sizeof (l), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    break;
n = n->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 160
Counter: 161
Batcher Size:130
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:183
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(n, n->next, n->next->element, l, n->previous, n->element, rm, f, node, n4, n3, n2, n1, status, argv, argc, n->next->next, n->next->previous)))
    n = n->next;


CondTester, a patch instance with id 105:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        
//Patch 0:
if (!(__is_neg(18, &(n), sizeof (n), &(n->next), sizeof (n->next), &(n->next->element), sizeof (n->next->element), &(l), sizeof (l), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    n = n->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 161
Counter: 162
Batcher Size:131
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:183
--Src File: prog.c
Fragment 0:
memset(n->next, 0, sizeof (*(n->next)));
n = n->next;


BasicTester, a patch instance with id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        
//Patch 0:
memset(n->next, 0, sizeof (*(n->next)));
n = n->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 162
Counter: 163
Batcher Size:132
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:183
--Src File: prog.c
Fragment 0:
memset(n, 0, sizeof (*(n)));
n = n->next;


BasicTester, a patch instance with id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        printf("%s ", n->next->element);
        
//Patch 0:
memset(n, 0, sizeof (*(n)));
n = n->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 163
Counter: 164
Batcher Size:133
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:182
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->next->element, n->next, n->previous->element, n->previous, n->element, l, rm, f, node, n4, n3, n2, n1, status, argv, argc, n->previous->next, n->previous->previous, n->next->next, n->next->previous)))
    break;
printf("%s ", n->next->element);


CondTester, a patch instance with id 106:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    break;
printf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 164
Counter: 165
Batcher Size:134
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:182
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->next->element, n->next, n->previous->element, n->previous, n->element, l, rm, f, node, n4, n3, n2, n1, status, argv, argc, n->previous->next, n->previous->previous, n->next->next, n->next->previous)))
    return 0;
printf("%s ", n->next->element);


CondTester, a patch instance with id 107:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return 0;
printf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 165
Counter: 166
Batcher Size:135
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:182
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->next->element, n->next, n->previous->element, n->previous, n->element, l, rm, f, node, n4, n3, n2, n1, status, argv, argc, n->previous->next, n->previous->previous, n->next->next, n->next->previous)))
    return 2;
printf("%s ", n->next->element);


CondTester, a patch instance with id 108:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return 2;
printf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 166
Counter: 167
Batcher Size:136
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:182
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->next->element, n->next, n->previous->element, n->previous, n->element, l, rm, f, node, n4, n3, n2, n1, status, argv, argc, n->previous->next, n->previous->previous, n->next->next, n->next->previous)))
    return 20;
printf("%s ", n->next->element);


CondTester, a patch instance with id 109:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return 20;
printf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 167
Counter: 168
Batcher Size:137
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:182
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->next->element, n->next, n->previous->element, n->previous, n->element, l, rm, f, node, n4, n3, n2, n1, status, argv, argc, n->previous->next, n->previous->previous, n->next->next, n->next->previous)))
    return 1;
printf("%s ", n->next->element);


CondTester, a patch instance with id 110:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return 1;
printf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 168
Counter: 169
Batcher Size:138
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:182
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, n->next->element, n->next, n->previous->element, n->previous, n->element, l, rm, f, node, n4, n3, n2, n1, status, argv, argc, n->previous->next, n->previous->previous, n->next->next, n->next->previous)))
    return -1;
printf("%s ", n->next->element);


CondTester, a patch instance with id 111:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return -1;
printf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 169
Counter: 170
Batcher Size:139
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:182
--Src File: prog.c
Fragment 0:
sscanf("%s ", n->next->element);


BasicTester, a patch instance with id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
sscanf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 170
Counter: 171
Batcher Size:140
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:182
--Src File: prog.c
Fragment 0:
scanf("%s ", n->next->element);


BasicTester, a patch instance with id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
scanf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 171
Counter: 172
Batcher Size:141
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:182
--Src File: prog.c
Fragment 0:
strspn("%s ", n->next->element);


BasicTester, a patch instance with id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
strspn("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Spawn 1 instances, now Total 172
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        //prophet generated patch
        if (__get_mutant()==0) {
        printf(("%s##uni*##"), n->next->element);
        }
        else if (__get_mutant()==1) {
        if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
            break;
        printf("%s ", n->next->element);
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
            return 0;
        printf("%s ", n->next->element);
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
            return 2;
        printf("%s ", n->next->element);
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
            return 20;
        printf("%s ", n->next->element);
        }
        else if (__get_mutant()==5) {
        if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
            return 1;
        printf("%s ", n->next->element);
        }
        else if (__get_mutant()==6) {
        if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
            return -1;
        printf("%s ", n->next->element);
        }
        else if (__get_mutant()==7) {
        sscanf("%s ", n->next->element);
        }
        else if (__get_mutant()==8) {
        scanf("%s ", n->next->element);
        }
        else if (__get_mutant()==9) {
        strspn("%s ", n->next->element);
        }
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Merged code building succ, going to invoke tester!
StringConstTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
printf(("%s##uni*##"), n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
CondTester, Testing instance id 106:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    break;
printf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 107:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return 0;
printf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 108:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return 2;
printf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 109:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return 20;
printf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 110:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return 1;
printf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 111:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
if ((__is_neg(21, &(n), sizeof (n), &(n->next->element), sizeof (n->next->element), &(n->next), sizeof (n->next), &(n->previous->element), sizeof (n->previous->element), &(n->previous), sizeof (n->previous), &(n->element), sizeof (n->element), &(l), sizeof (l), &(rm), sizeof (rm), &(f), sizeof (f), &(node), sizeof (node), &(n4), sizeof (n4), &(n3), sizeof (n3), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->previous->next), sizeof (n->previous->next), &(n->previous->previous), sizeof (n->previous->previous), &(n->next->next), sizeof (n->next->next), &(n->next->previous), sizeof (n->next->previous))))
    return -1;
printf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head->previous;
    (*e)->next = (*l)->head;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}


int hasLoopNext(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->next == l->head)
            return 1;
        else
            ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}


int hasLoopPrev(struct List* l) {
    if (l->head->previous == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    while (1) {
        if (ln1->previous == l->head)
            return 1;
        else
            ln1 = ln1->previous;
        if (ln2->previous == l->head || ln2->previous->previous == l->head)
            return 1;
        else
            ln2 = ln2->previous->previous;
        if (ln1==ln2)
            return 0;
    }
    return 1;
}

int removeEntry(struct List** l, char* rm) {
    struct Entry* e = (*l)->head->next;
    while (e != (*l)->head) {
        if (strcmp(e->element,rm)!=0) {
            e = e->next;
            continue;
        }
//        e->previous->next = e->next;
        e->next->previous = e->previous;
  //      (*l)->size = (*l)->size -1;
        return 0;
    }
    return 1;
}

 int main(int argc, char *argv[]) {
     if (argc<2) return 0;
     FILE *f = fopen(argv[1],"r");
     if (f==NULL) return 0;
     struct List *l;
     newList(&l);
     char x[20];
     struct Entry* node;
     struct Entry* n1 ;
     newNode(&n1);
     n1->element = "N1";
     struct Entry* n2 ;
    newNode(&n2);
    n2->element = "N2";
     struct Entry* n3 ;
     newNode(&n3);
     n3->element = "N3";
     struct Entry* n4 ;
     newNode(&n4);
     n4->element = "N4";
     int status = -1;
     struct Entry* e = l->head;
     char* rm=NULL;
     while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
             continue;
        if (status == -1) {
            rm = (char*) malloc(sizeof (char) *  (strlen(x)+1));
            strcpy(rm,x);
        status =0;
        continue;
        }
         if (strcmp(x,"N1")==0)
             node = n1;
         if (strcmp(x,"N2")==0)
             node = n2;
         if (strcmp(x,"N3")==0)
             node = n3;
         if (strcmp(x,"N4")==0)
             node = n4;
         if (strcmp(x,"H")==0)
             node = l->head;
         addFirst(&l,&node);
     }
    fclose(f);

    if (hasLoopNext(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }

    if (hasLoopPrev(l)==0  ){
        printf("%s","HAS LOOP");
        return 0;
    }
    printf("%d ",removeEntry(&l,rm));
    struct Entry* n = l->head->next;
    while (n != (l->head)) {
        printf("%s ", n->element);
        printf("%s ", n->previous->element);
        
//Patch 0:
sscanf("%s ", n->next->element);

//CodeSeg 1:
        n = n->next;
    }
    printf(" %d",l->size);
    return 0;

}

Testing negative cases!
BasicTester, Testing instance id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    char*  element;
    struct Entry*  next;
    struct Entry* previous;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void addFirst(struct List **l, struct Entry** n);
void addLast(struct List **l, struct Entry** n);
void newNode(struct Entry **_out);

int hasLoopNext(struct List* l) ;
int hasLoopNext(struct List* l) ;
int removeEntry(struct List** l, char* rm);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    struct Entry* h;
    newNode(&h);
    (*l)->head = h;
    (*l)->head->element = "H";
    (*l)->head->next = (*l)->head;
    (*l)->head->previous = (*l)->head;
    (*l)->size = 0;
    return;
}

void newNode( struct Entry **n){
    *n = malloc(sizeof(struct Entry));
    // (*n)->element = v;
    (*n)->next = NULL;
    (*n)->previous = NULL;
}

void addFirst(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)->head;
    (*e)->next = (*l)->head->next;
    (*e)->next->previous = *e;
    (*e)->previous->next = *e;
    // t->previous = e;
    (*l)->size = (*l)->size +1;
    return;
}

void addLast(struct List** l, struct Entry** e) {
    //    struct Entry* t = (*l)->head->next;
    (*e)->previous = (*l)