Initialize the program!
Verify Test Cases
All passed!
Done Verification
Generating repair candidates!
Processing prog.c
Total 1755 different repair schemas!!!!
Total 3878 different repair candidate templates for scoring!!!
Trying different candidates!
BasicTester pointer: 0xab579c8
StringConstTester pointer: 0xaaff4d8
CondTester pointer: 0xaafab38
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:50
--Src File: prog.c
Fragment 0:
if ((l->head->next == l->head) && !(__abst_hole(l, l->head->next, l->head, l->head->element, l->size)))
    return 1;


CondTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((l->head->next == l->head) && !(__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:50
--Src File: prog.c
Fragment 0:
if ((l->head->next == l->head) || (__abst_hole(l, l->head->next, l->head, l->head->element, l->size)))
    return 1;


CondTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((l->head->next == l->head) || (__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((ln1 == ln2) && !(__abst_hole(ln1, ln2, ln2->next, ln2->next->next, count, l, ln1->next, ln1->element, ln2->element, ln2->next->element)))
    return 0;


CondTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((ln1 == ln2) && !(__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:93
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N1") == 0) && !(__abst_hole(node, n1, f, n2, l, n3, n4, e, argv, argc)))
    node = n1;


CondTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        
//Patch 0:
if ((strcmp(x, "N1") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(f), sizeof (f), &(n2), sizeof (n2), &(l), sizeof (l), &(n3), sizeof (n3), &(n4), sizeof (n4), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n1;

//CodeSeg 1:
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:93
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N1") == 0) || (__abst_hole(node, n1, f, n2, l, n3, n4, e, argv, argc)))
    node = n1;


CondTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        
//Patch 0:
if ((strcmp(x, "N1") == 0) || (__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(f), sizeof (f), &(n2), sizeof (n2), &(l), sizeof (l), &(n3), sizeof (n3), &(n4), sizeof (n4), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n1;

//CodeSeg 1:
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((ln1 == ln2) || (__abst_hole(ln1, ln2, ln2->next, ln2->next->next, count, l, ln1->next, ln1->element, ln2->element, ln2->next->element)))
    return 0;


CondTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((ln1 == ln2) || (__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:60
--Src File: prog.c
Fragment 0:
if ((ln2->next == l->head || ln2->next->next == l->head) && !(__abst_hole(l, ln2, l->head, ln2->next, ln2->next->next, ln1, count, l->head->next, l->head->element, l->size, ln2->element, ln2->next->element)))
    return 1;
else
    ln2 = ln2->next->next;


CondTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
if ((ln2->next == l->head || ln2->next->next == l->head) && !(__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((x[0] == '"') && !(__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    continue;


CondTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') && !(__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((x[0] == '"') || (__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    continue;


CondTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') || (__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:60
--Src File: prog.c
Fragment 0:
if ((ln2->next == l->head || ln2->next->next == l->head) || (__abst_hole(l, ln2, l->head, ln2->next, ln2->next->next, ln1, count, l->head->next, l->head->element, l->size, ln2->element, ln2->next->element)))
    return 1;
else
    ln2 = ln2->next->next;


CondTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
if ((ln2->next == l->head || ln2->next->next == l->head) || (__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 10
Counter: 11
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((ln1->next == l->head) && !(__abst_hole(l, ln1, ln1->next, l->head, count, ln2, l->head->next, l->head->element, ln1->element, l->size)))
    return 1;


CondTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        
//Patch 0:
if ((ln1->next == l->head) && !(__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:11
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:99
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N4") == 0) && !(__abst_hole(node, n3, n4, l, n2, e, n1, f, argv, argc)))
    node = n4;


CondTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        
//Patch 0:
if ((strcmp(x, "N4") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(e), sizeof (e), &(n1), sizeof (n1), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n4;

//CodeSeg 1:
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:99
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N4") == 0) || (__abst_hole(node, n3, n4, l, n2, e, n1, f, argv, argc)))
    node = n4;


CondTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        
//Patch 0:
if ((strcmp(x, "N4") == 0) || (__is_neg(10, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(e), sizeof (e), &(n1), sizeof (n1), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n4;

//CodeSeg 1:
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:13
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:101
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "H") == 0) && !(__abst_hole(l, node, n4, l->head, e, n3, f, n2, n1, argv, argc, l->size)))
    node = l->head;


CondTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        
//Patch 0:
if ((strcmp(x, "H") == 0) && !(__is_neg(12, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(e), sizeof (e), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    node = l->head;

//CodeSeg 1:
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:14
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:101
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "H") == 0) || (__abst_hole(l, node, n4, l->head, e, n3, f, n2, n1, argv, argc, l->size)))
    node = l->head;


CondTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        
//Patch 0:
if ((strcmp(x, "H") == 0) || (__is_neg(12, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(e), sizeof (e), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    node = l->head;

//CodeSeg 1:
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:15
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((ln1->next == l->head) || (__abst_hole(l, ln1, ln1->next, l->head, count, ln2, l->head->next, l->head->element, ln1->element, l->size)))
    return 1;


CondTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        
//Patch 0:
if ((ln1->next == l->head) || (__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:73
--Src File: prog.c
Fragment 0:
if ((argc < 2) || (__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:75
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) || (__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:97
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N3") == 0) && !(__abst_hole(node, n2, n3, n1, n4, l, e, f, argv, argc)))
    node = n3;


CondTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        
//Patch 0:
if ((strcmp(x, "N3") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n3;

//CodeSeg 1:
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:19
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:97
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N3") == 0) || (__abst_hole(node, n2, n3, n1, n4, l, e, f, argv, argc)))
    node = n3;


CondTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        
//Patch 0:
if ((strcmp(x, "N3") == 0) || (__is_neg(10, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n3;

//CodeSeg 1:
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 20
Counter: 21
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:75
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) && !(__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:73
--Src File: prog.c
Fragment 0:
if ((argc < 2) && !(__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:22
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:95
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N2") == 0) && !(__abst_hole(node, n1, n2, n3, f, n4, l, e, argv, argc)))
    node = n2;


CondTester, a patch instance with id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        
//Patch 0:
if ((strcmp(x, "N2") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(f), sizeof (f), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n2;

//CodeSeg 1:
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:23
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:95
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N2") == 0) || (__abst_hole(node, n1, n2, n3, f, n4, l, e, argv, argc)))
    node = n2;


CondTester, a patch instance with id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        
//Patch 0:
if ((strcmp(x, "N2") == 0) || (__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(f), sizeof (f), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n2;

//CodeSeg 1:
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 12481
At location prog.c:50
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->head->next, l->head, l->head->element, l->size)))
    return 0;
if (l->head->next == l->head)
    return 1;


CondTester, a patch instance with id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 0;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:25
Preprocess the following candidate with CondTester:
Priority 12481
At location prog.c:50
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->head->next, l->head, l->head->element, l->size)))
    return 1;
if (l->head->next == l->head)
    return 1;


CondTester, a patch instance with id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 1;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:26
Preprocess the following candidate with CondTester:
Priority 12481
At location prog.c:50
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->head->next, l->head, l->head->element, l->size)))
    return 100;
if (l->head->next == l->head)
    return 1;


CondTester, a patch instance with id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 100;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:27
Preprocess the following candidate with CondTester:
Priority 12472
At location prog.c:28
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n)))
    return;
*n = malloc(sizeof(struct Entry));


CondTester, a patch instance with id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
if ((__is_neg(1, &(n), sizeof (n))))
    return;
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:28
Preprocess the following candidate with CondTester:
Priority 12458
At location prog.c:21
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, (*l)->head, (*l)->head->next, (*l)->head->element, (*l)->size)))
    return;
*l = malloc(sizeof(struct List));


CondTester, a patch instance with id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:29
Preprocess the following candidate with CondTester:
Priority 12453
At location prog.c:73
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 2;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 2;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 30
Counter: 31
Batcher Size:30
Preprocess the following candidate with CondTester:
Priority 12453
At location prog.c:73
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 20;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 20;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:31
Preprocess the following candidate with CondTester:
Priority 12453
At location prog.c:73
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 0;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 32
Counter: 33
Batcher Size:32
Preprocess the following candidate with CondTester:
Priority 12453
At location prog.c:73
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 1;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 1;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:33
Preprocess the following candidate with CondTester:
Priority 9995
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln1, ln1->next, l->head, count, ln2, l->head->next, l->head->element, ln1->element, l->size)))
    return 0;
if (ln1->next == l->head)
    return 1;


CondTester, a patch instance with id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        
//Patch 0:
if ((__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
    return 0;
if (ln1->next == l->head)
    return 1;

//CodeSeg 1:
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:34
Preprocess the following candidate with CondTester:
Priority 9995
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln1, ln1->next, l->head, count, ln2, l->head->next, l->head->element, ln1->element, l->size)))
    break;
if (ln1->next == l->head)
    return 1;


CondTester, a patch instance with id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        
//Patch 0:
if ((__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
    break;
if (ln1->next == l->head)
    return 1;

//CodeSeg 1:
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:35
Preprocess the following candidate with CondTester:
Priority 9995
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln1, ln1->next, l->head, count, ln2, l->head->next, l->head->element, ln1->element, l->size)))
    return 1;
if (ln1->next == l->head)
    return 1;


CondTester, a patch instance with id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        
//Patch 0:
if ((__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
    return 1;
if (ln1->next == l->head)
    return 1;

//CodeSeg 1:
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:36
Preprocess the following candidate with CondTester:
Priority 9995
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln1, ln1->next, l->head, count, ln2, l->head->next, l->head->element, ln1->element, l->size)))
    return 100;
if (ln1->next == l->head)
    return 1;


CondTester, a patch instance with id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        
//Patch 0:
if ((__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
    return 100;
if (ln1->next == l->head)
    return 1;

//CodeSeg 1:
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:37
Preprocess the following candidate with CondTester:
Priority 9977
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    return 0;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:38
Preprocess the following candidate with CondTester:
Priority 9977
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    return 1;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 39
Counter: 40
Batcher Size:39
Preprocess the following candidate with CondTester:
Priority 9977
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    return 2;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 40
Counter: 41
Batcher Size:40
Preprocess the following candidate with CondTester:
Priority 9977
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    return 20;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 41
Counter: 42
Batcher Size:41
Preprocess the following candidate with CondTester:
Priority 9977
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    break;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    break;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 42
Counter: 43
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:21
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*(l))->head;
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*(l))->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 43
Counter: 44
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:28
--Src File: prog.c
Fragment 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Entry));


BasicTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 44
Counter: 45
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 7481
At location prog.c:50
--Src File: prog.c
Fragment 0:
if (l->head->next == l->head)
    return 1;
if (l->head->next == l->head)
    return 1;


BasicTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if (l->head->next == l->head)
    return 1;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 45
Counter: 46
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7481
At location prog.c:50
--Src File: prog.c
Fragment 0:
newList(&(l));
if (l->head->next == l->head)
    return 1;


BasicTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
newList(&(l));
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 46
Counter: 47
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7481
At location prog.c:50
--Src File: prog.c
Fragment 0:
printf(" %d", hasLoop((l)));
if (l->head->next == l->head)
    return 1;


BasicTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
printf(" %d", hasLoop((l)));
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 47
Counter: 48
Batcher Size:47
Preprocess the following candidate with StringConstTester:
Priority 7480
At location prog.c:108
--Src File: prog.c
Fragment 0:
printf((__abst_hole()), hasLoop(l));


StringConstTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    
//Patch 0:
printf((" %##uni*##"), hasLoop(l));

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 48
Counter: 49
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7472
At location prog.c:28
--Src File: prog.c
Fragment 0:
*n = malloc(sizeof(struct Entry));
*n = malloc(sizeof(struct Entry));


BasicTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
*n = malloc(sizeof(struct Entry));
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 49
Counter: 50
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7458
At location prog.c:21
--Src File: prog.c
Fragment 0:
newNode(&((*l)->head));
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
newNode(&((*l)->head));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 50
Counter: 51
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7458
At location prog.c:21
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
newNode(&((*(l))->head));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 51
Counter: 52
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7458
At location prog.c:21
--Src File: prog.c
Fragment 0:
*l = malloc(sizeof(struct List));
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
*l = malloc(sizeof(struct List));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 52
Counter: 53
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7458
At location prog.c:21
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*l)->head;
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*l)->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 53
Counter: 54
Batcher Size:53
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:73
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;


BasicTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 54
Counter: 55
Batcher Size:54
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
if ((__abst_hole(count, ln1, ln2, l)))
    return 100;
return 1;


CondTester, a patch instance with id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 100;
return 1;

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 55
Counter: 56
Batcher Size:55
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
if ((__abst_hole(count, ln1, ln2, l)))
    return 0;
return 1;


CondTester, a patch instance with id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 0;
return 1;

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 56
Counter: 57
Batcher Size:56
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
if ((__abst_hole(count, ln1, ln2, l)))
    return 1;
return 1;


CondTester, a patch instance with id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 1;
return 1;

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 57
Counter: 58
Batcher Size:57
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(count, ln1, ln2, l)))
    return 1;


CondTester, a patch instance with id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    
//Patch 0:
if (!(__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 1;

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 58
Counter: 59
Batcher Size:58
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:66
--Src File: prog.c
Fragment 0:
if ((__abst_hole(count, ln1, ln2, l)))
    return 0;
count = count + 1;


CondTester, a patch instance with id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 0;
count = count + 1;

//CodeSeg 1:
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 59
Counter: 60
Batcher Size:59
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:66
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(count, ln1, ln2, l)))
    count = count + 1;


CondTester, a patch instance with id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        
//Patch 0:
if (!(__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    count = count + 1;

//CodeSeg 1:
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 60
Counter: 61
Batcher Size:60
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:66
--Src File: prog.c
Fragment 0:
if ((__abst_hole(count, ln1, ln2, l)))
    return 1;
count = count + 1;


CondTester, a patch instance with id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 1;
count = count + 1;

//CodeSeg 1:
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 61
Counter: 62
Batcher Size:61
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:66
--Src File: prog.c
Fragment 0:
if ((__abst_hole(count, ln1, ln2, l)))
    return 100;
count = count + 1;


CondTester, a patch instance with id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 100;
count = count + 1;

//CodeSeg 1:
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 62
Counter: 63
Batcher Size:62
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:66
--Src File: prog.c
Fragment 0:
if ((__abst_hole(count, ln1, ln2, l)))
    break;
count = count + 1;


CondTester, a patch instance with id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    break;
count = count + 1;

//CodeSeg 1:
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 63
Counter: 64
Batcher Size:63
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((__abst_hole(ln1, ln2, ln2->next, ln2->next->next, count, l, ln1->next, ln1->element, ln2->element, ln2->next->element)))
    return 100;
if (ln1 == ln2)
    return 0;


CondTester, a patch instance with id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 100;
if (ln1 == ln2)
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 64
Counter: 65
Batcher Size:64
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((__abst_hole(ln1, ln2, ln2->next, ln2->next->next, count, l, ln1->next, ln1->element, ln2->element, ln2->next->element)))
    break;
if (ln1 == ln2)
    return 0;


CondTester, a patch instance with id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    break;
if (ln1 == ln2)
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 65
Counter: 66
Batcher Size:65
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((__abst_hole(ln1, ln2, ln2->next, ln2->next->next, count, l, ln1->next, ln1->element, ln2->element, ln2->next->element)))
    return 0;
if (ln1 == ln2)
    return 0;


CondTester, a patch instance with id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 0;
if (ln1 == ln2)
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 66
Counter: 67
Batcher Size:66
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((__abst_hole(ln1, ln2, ln2->next, ln2->next->next, count, l, ln1->next, ln1->element, ln2->element, ln2->next->element)))
    return 1;
if (ln1 == ln2)
    return 0;


CondTester, a patch instance with id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
if (ln1 == ln2)
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 67
Counter: 68
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:64
--Src File: prog.c
Fragment 0:
memset(ln1, 0, sizeof (*(ln1)));
if (ln1 == ln2)
    return 0;


BasicTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
memset(ln1, 0, sizeof (*(ln1)));
if (ln1 == ln2)
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 68
Counter: 69
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:64
--Src File: prog.c
Fragment 0:
memset(ln2, 0, sizeof (*(ln2)));
if (ln1 == ln2)
    return 0;


BasicTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
memset(ln2, 0, sizeof (*(ln2)));
if (ln1 == ln2)
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 69
Counter: 70
Batcher Size:69
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:64
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(ln1, ln2, ln2->next, ln2->next->next, count, l, ln1->next, ln1->element, ln2->element, ln2->next->element)))
    if (ln1 == ln2)
        return 0;


CondTester, a patch instance with id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if (!(__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    if (ln1 == ln2)
        return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 70
Counter: 71
Batcher Size:70
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:63
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(ln2, ln2->next, ln2->next->next, ln1, l, count, ln1->next, ln1->element, ln2->element, ln2->next->element)))
        return 1;
    ln2 = ln2->next->next;
}


CondTester, a patch instance with id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    if ((__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
        return 1;
    ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 71
Counter: 72
Batcher Size:71
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:63
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(ln2, ln2->next, ln2->next->next, ln1, l, count, ln1->next, ln1->element, ln2->element, ln2->next->element)))
        break;
    ln2 = ln2->next->next;
}


CondTester, a patch instance with id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    if ((__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
        break;
    ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 72
Counter: 73
Batcher Size:72
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:63
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(ln2, ln2->next, ln2->next->next, ln1, l, count, ln1->next, ln1->element, ln2->element, ln2->next->element)))
        return 100;
    ln2 = ln2->next->next;
}


CondTester, a patch instance with id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    if ((__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
        return 100;
    ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 73
Counter: 74
Batcher Size:73
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:63
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(ln2, ln2->next, ln2->next->next, ln1, l, count, ln1->next, ln1->element, ln2->element, ln2->next->element)))
        return 0;
    ln2 = ln2->next->next;
}


CondTester, a patch instance with id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    if ((__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
        return 0;
    ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 74
Counter: 75
Batcher Size:74
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:63
--Src File: prog.c
Fragment 0:
{
    if (!(__abst_hole(ln2, ln2->next, ln2->next->next, ln1, l, count, ln1->next, ln1->element, ln2->element, ln2->next->element)))
        ln2 = ln2->next->next;
}


CondTester, a patch instance with id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    if (!(__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
        ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 75
Counter: 76
Batcher Size:75
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:63
--Src File: prog.c
Fragment 0:
{
    memset(ln2, 0, sizeof (*(ln2)));
    ln2 = ln2->next->next;
}


BasicTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    memset(ln2, 0, sizeof (*(ln2)));
    ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 76
Counter: 77
Batcher Size:76
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:63
--Src File: prog.c
Fragment 0:
{
    memset(ln2->next, 0, sizeof (*(ln2->next)));
    ln2 = ln2->next->next;
}


BasicTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    memset(ln2->next, 0, sizeof (*(ln2->next)));
    ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 77
Counter: 78
Batcher Size:77
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:60
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln2, l->head, ln2->next, ln2->next->next, ln1, count, l->head->next, l->head->element, l->size, ln2->element, ln2->next->element)))
    return 0;
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;


CondTester, a patch instance with id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
if ((__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 0;
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 78
Counter: 79
Batcher Size:78
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:60
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln2, l->head, ln2->next, ln2->next->next, ln1, count, l->head->next, l->head->element, l->size, ln2->element, ln2->next->element)))
    return 100;
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;


CondTester, a patch instance with id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
if ((__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 100;
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 79
Counter: 80
Batcher Size:79
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:60
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln2, l->head, ln2->next, ln2->next->next, ln1, count, l->head->next, l->head->element, l->size, ln2->element, ln2->next->element)))
    break;
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;


CondTester, a patch instance with id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
if ((__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    break;
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 80
Counter: 81
Batcher Size:80
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:60
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, ln2, l->head, ln2->next, ln2->next->next, ln1, count, l->head->next, l->head->element, l->size, ln2->element, ln2->next->element)))
    return 1;
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;


CondTester, a patch instance with id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
if ((__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 81
Counter: 82
Batcher Size:81
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:60
--Src File: prog.c
Fragment 0:
memset(l->head, 0, sizeof (*(l->head)));
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;


BasicTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
memset(l->head, 0, sizeof (*(l->head)));
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 82
Counter: 83
Batcher Size:82
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:60
--Src File: prog.c
Fragment 0:
memset(ln2, 0, sizeof (*(ln2)));
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;


BasicTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
memset(ln2, 0, sizeof (*(ln2)));
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 83
Counter: 84
Batcher Size:83
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:60
--Src File: prog.c
Fragment 0:
memset(ln2->next, 0, sizeof (*(ln2->next)));
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;


BasicTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
memset(ln2->next, 0, sizeof (*(ln2->next)));
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 84
Counter: 85
Batcher Size:84
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:60
--Src File: prog.c
Fragment 0:
memset(l, 0, sizeof (*(l)));
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;


BasicTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
memset(l, 0, sizeof (*(l)));
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 85
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((ln2->next == l->head || ln2->next->next == l->head) && !(__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 1;
        else
            ln2 = ln2->next->next;
        }
        else if (__get_mutant()==1) {
        if ((ln2->next == l->head || ln2->next->next == l->head) || (__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 1;
        else
            ln2 = ln2->next->next;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 0;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 100;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            break;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        }
        else if (__get_mutant()==5) {
        if ((__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 1;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        }
        else if (__get_mutant()==6) {
        memset(l->head, 0, sizeof (*(l->head)));
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        }
        else if (__get_mutant()==7) {
        memset(ln2, 0, sizeof (*(ln2)));
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        }
        else if (__get_mutant()==8) {
        memset(ln2->next, 0, sizeof (*(ln2->next)));
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        }
        else if (__get_mutant()==9) {
        memset(l, 0, sizeof (*(l)));
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        }
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
if ((ln2->next == l->head || ln2->next->next == l->head) && !(__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
if ((ln2->next == l->head || ln2->next->next == l->head) || (__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Testing instance id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
if ((__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 0;
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 5 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 9 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
if ((__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 100;
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Testing instance id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
if ((__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    break;
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Testing instance id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
if ((__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
BasicTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
memset(l->head, 0, sizeof (*(l->head)));
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
memset(ln2, 0, sizeof (*(ln2)));
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
memset(ln2->next, 0, sizeof (*(ln2->next)));
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
memset(l, 0, sizeof (*(l)));
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
CondTester, Postprocessing instance id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        
//Patch 0:
if ((__is_neg(12, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 0;
if (ln2->next == l->head || ln2->next->next == l->head)
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Trying a synthesis expr 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 2
Not passed!
Trying a synthesis expr count == 99
Verifing Negative cases!
Verifying positive cases
Passed Positive Cases
Passed!
Passed with updated best score 4995939.000000
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
        return;
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==1) {
    (*l)->head->next = (*(l))->head;
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==2) {
    newNode(&((*l)->head));
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==3) {
    newNode(&((*(l))->head));
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==4) {
    *l = malloc(sizeof(struct List));
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==5) {
    (*l)->head->next = (*l)->head;
    *l = malloc(sizeof(struct List));
    }
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*(l))->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
newNode(&((*l)->head));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
newNode(&((*(l))->head));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
*l = malloc(sizeof(struct List));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*l)->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(1, &(n), sizeof (n))))
        return;
    *n = malloc(sizeof(struct Entry));
    }
    else if (__get_mutant()==1) {
    (*n)->next = ((void *)0);
    *n = malloc(sizeof(struct Entry));
    }
    else if (__get_mutant()==2) {
    *n = malloc(sizeof(struct Entry));
    *n = malloc(sizeof(struct Entry));
    }
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
if ((__is_neg(1, &(n), sizeof (n))))
    return;
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Branch 4: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Branch 4: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 0
Branch 4: 0
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 0
Branch 4: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Branch 4: 1
Iteration 8
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 0
Branch 4: 0
Iteration 9
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 0
Branch 4: 1
BasicTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
*n = malloc(sizeof(struct Entry));
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((l->head->next == l->head) && !(__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
        return 1;
    }
    else if (__get_mutant()==1) {
    if ((l->head->next == l->head) || (__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
        return 1;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
        return 0;
    if (l->head->next == l->head)
        return 1;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
        return 1;
    if (l->head->next == l->head)
        return 1;
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
        return 100;
    if (l->head->next == l->head)
        return 1;
    }
    else if (__get_mutant()==5) {
    if (l->head->next == l->head)
        return 1;
    if (l->head->next == l->head)
        return 1;
    }
    else if (__get_mutant()==6) {
    newList(&(l));
    if (l->head->next == l->head)
        return 1;
    }
    else if (__get_mutant()==7) {
    printf(" %d", hasLoop((l)));
    if (l->head->next == l->head)
        return 1;
    }
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((l->head->next == l->head) && !(__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((l->head->next == l->head) || (__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 0;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 5 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 9 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 1;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 100;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if (l->head->next == l->head)
    return 1;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
newList(&(l));
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
printf(" %d", hasLoop((l)));
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
CondTester, Postprocessing instance id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 0;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Trying a synthesis expr 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 2
Not passed!
Trying a synthesis expr l->size == 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 2
Not passed!
Initial synthesize failed, final attempt
Final attempt 1/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    //prophet generated patch
    if (((0)))
        return 0;
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Trying Negative cases!
Final attempt 2/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    //prophet generated patch
    if (((1)))
        return 0;
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Trying Negative cases!
Trying Positive cases!
Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((ln1->next == l->head) && !(__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
            return 1;
        }
        else if (__get_mutant()==1) {
        if ((ln1->next == l->head) || (__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
            return 1;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
            return 0;
        if (ln1->next == l->head)
            return 1;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
            break;
        if (ln1->next == l->head)
            return 1;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
            return 1;
        if (ln1->next == l->head)
            return 1;
        }
        else if (__get_mutant()==5) {
        if ((__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
            return 100;
        if (ln1->next == l->head)
            return 1;
        }
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        
//Patch 0:
if ((ln1->next == l->head) && !(__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        
//Patch 0:
if ((ln1->next == l->head) || (__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Testing instance id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        
//Patch 0:
if ((__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
    return 0;
if (ln1->next == l->head)
    return 1;

//CodeSeg 1:
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 5 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 9 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        
//Patch 0:
if ((__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
    break;
if (ln1->next == l->head)
    return 1;

//CodeSeg 1:
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Testing instance id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        
//Patch 0:
if ((__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
    return 1;
if (ln1->next == l->head)
    return 1;

//CodeSeg 1:
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Testing instance id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        
//Patch 0:
if ((__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
    return 100;
if (ln1->next == l->head)
    return 1;

//CodeSeg 1:
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Postprocessing instance id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        
//Patch 0:
if ((__is_neg(10, &(l), sizeof (l), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l->head), sizeof (l->head), &(count), sizeof (count), &(ln2), sizeof (ln2), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size))))
    return 0;
if (ln1->next == l->head)
    return 1;

//CodeSeg 1:
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Trying a synthesis expr 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 2
Not passed!
Trying a synthesis expr count == 99
Verifing Negative cases!
Verifying positive cases
Passed Positive Cases
Passed!
Passed with updated best score 9994967.000000
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            //prophet generated patch
            if (__get_mutant()==0) {
            {
                if ((__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
                    return 1;
                ln2 = ln2->next->next;
            }
            }
            else if (__get_mutant()==1) {
            {
                if ((__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
                    break;
                ln2 = ln2->next->next;
            }
            }
            else if (__get_mutant()==2) {
            {
                if ((__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
                    return 100;
                ln2 = ln2->next->next;
            }
            }
            else if (__get_mutant()==3) {
            {
                if ((__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
                    return 0;
                ln2 = ln2->next->next;
            }
            }
            else if (__get_mutant()==4) {
            {
                if (!(__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
                    ln2 = ln2->next->next;
            }
            }
            else if (__get_mutant()==5) {
            {
                memset(ln2, 0, sizeof (*(ln2)));
                ln2 = ln2->next->next;
            }
            }
            else if (__get_mutant()==6) {
            {
                memset(ln2->next, 0, sizeof (*(ln2->next)));
                ln2 = ln2->next->next;
            }
            }
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    if ((__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
        return 1;
    ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Testing instance id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    if ((__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
        break;
    ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Testing instance id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    if ((__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
        return 100;
    ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Testing instance id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    if ((__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
        return 0;
    ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 5 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 9 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    if (!(__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
        ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 0
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 0
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 1
Log 0 1
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 0
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 0
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 1
Log 0 1
Testing 5 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 0
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 0
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 1
Log 0 1
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 0
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 0
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 1
Log 0 1
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 0
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 0
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 1
Log 0 1
Testing 9 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 0
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 0
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 1
Log 0 1
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
BasicTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    memset(ln2, 0, sizeof (*(ln2)));
    ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    memset(ln2->next, 0, sizeof (*(ln2->next)));
    ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
CondTester, Postprocessing instance id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    if ((__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
        return 0;
    ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Postprocessing failed!
CondTester, Postprocessing instance id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            
//Patch 0:
{
    if (!(__is_neg(10, &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(l), sizeof (l), &(count), sizeof (count), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
        ln2 = ln2->next->next;
}

//CodeSeg 1:
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((ln1 == ln2) && !(__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 0;
        }
        else if (__get_mutant()==1) {
        if ((ln1 == ln2) || (__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 0;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 100;
        if (ln1 == ln2)
            return 0;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            break;
        if (ln1 == ln2)
            return 0;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 0;
        if (ln1 == ln2)
            return 0;
        }
        else if (__get_mutant()==5) {
        if ((__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 1;
        if (ln1 == ln2)
            return 0;
        }
        else if (__get_mutant()==6) {
        memset(ln1, 0, sizeof (*(ln1)));
        if (ln1 == ln2)
            return 0;
        }
        else if (__get_mutant()==7) {
        memset(ln2, 0, sizeof (*(ln2)));
        if (ln1 == ln2)
            return 0;
        }
        else if (__get_mutant()==8) {
        if (!(__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            if (ln1 == ln2)
                return 0;
        }
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((ln1 == ln2) && !(__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((ln1 == ln2) || (__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 5 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 9 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 100;
if (ln1 == ln2)
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Testing instance id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    break;
if (ln1 == ln2)
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Testing instance id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 0;
if (ln1 == ln2)
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 5 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 9 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
if (ln1 == ln2)
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
BasicTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
memset(ln1, 0, sizeof (*(ln1)));
if (ln1 == ln2)
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
memset(ln2, 0, sizeof (*(ln2)));
if (ln1 == ln2)
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if (!(__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    if (ln1 == ln2)
        return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Branch 99: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 0
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 0
Branch 99: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 0
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Branch 98: 1
Branch 99: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Branch 97: 0
Branch 98: 0
Branch 99: 1
CondTester, Postprocessing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((ln1 == ln2) || (__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Trying a synthesis expr 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 7
Not passed!
Trying a synthesis expr count == 99
Verifing Negative cases!
Verifying positive cases
Passed Positive Cases
Passed!
Passed with updated best score 19999995.000000
CondTester, Postprocessing instance id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        
//Patch 0:
if ((__is_neg(10, &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l), sizeof (l), &(ln1->next), sizeof (ln1->next), &(ln1->element), sizeof (ln1->element), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 0;
if (ln1 == ln2)
    return 0;

//CodeSeg 1:
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
            return 0;
        count = count + 1;
        }
        else if (__get_mutant()==1) {
        if (!(__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
            count = count + 1;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
            return 1;
        count = count + 1;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
            return 100;
        count = count + 1;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
            break;
        count = count + 1;
        }
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 0;
count = count + 1;

//CodeSeg 1:
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 5 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Testing 9 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        
//Patch 0:
if (!(__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    count = count + 1;

//CodeSeg 1:
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Branch 100: 0
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Branch 100: 1
Branch 101: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Branch 100: 1
Branch 101: 1
Branch 102: 0
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Branch 100: 1
Branch 101: 1
Branch 102: 1
Branch 103: 0
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Branch 100: 1
Branch 101: 1
Branch 102: 1
Branch 103: 1
Branch 104: 0
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Branch 100: 1
Branch 101: 1
Branch 102: 1
Branch 103: 1
Branch 104: 1
Branch 105: 0
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Branch 100: 1
Branch 101: 1
Branch 102: 1
Branch 103: 1
Branch 104: 1
Branch 105: 1
Branch 106: 0
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Branch 100: 1
Branch 101: 1
Branch 102: 1
Branch 103: 1
Branch 104: 1
Branch 105: 1
Branch 106: 1
Branch 107: 0
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Branch 100: 1
Branch 101: 1
Branch 102: 1
Branch 103: 1
Branch 104: 1
Branch 105: 1
Branch 106: 1
Branch 107: 1
Branch 108: 0
CondTester, Testing instance id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 1;
count = count + 1;

//CodeSeg 1:
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Testing instance id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 100;
count = count + 1;

//CodeSeg 1:
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Testing instance id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    break;
count = count + 1;

//CodeSeg 1:
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 1
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
CondTester, Postprocessing instance id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 0;
count = count + 1;

//CodeSeg 1:
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
        return 100;
    return 1;
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
        return 0;
    return 1;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
        return 1;
    return 1;
    }
    else if (__get_mutant()==3) {
    if (!(__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
        return 1;
    }
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 100;
return 1;

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 0;
return 1;

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 5 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 9 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 1;
return 1;

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    
//Patch 0:
if (!(__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 1;

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Postprocessing instance id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln1), sizeof (ln1), &(ln2), sizeof (ln2), &(l), sizeof (l))))
    return 0;
return 1;

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 2;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 20;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==5) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 1;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==6) {
    if (argc < 2)
        return 0;
    if (argc < 2)
        return 0;
    }
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 2;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 20;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 1;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((x[0] == '"') && !(__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            continue;
        }
        else if (__get_mutant()==1) {
        if ((x[0] == '"') || (__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            continue;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 0;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 1;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 2;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==5) {
        if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 20;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==6) {
        if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            break;
        if (x[0] == '"')
            continue;
        }
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') && !(__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') || (__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
CondTester, Testing instance id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
CondTester, Testing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
CondTester, Testing instance id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
CondTester, Testing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
CondTester, Testing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    break;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((strcmp(x, "N1") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(f), sizeof (f), &(n2), sizeof (n2), &(l), sizeof (l), &(n3), sizeof (n3), &(n4), sizeof (n4), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n1;
        }
        else if (__get_mutant()==1) {
        if ((strcmp(x, "N1") == 0) || (__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(f), sizeof (f), &(n2), sizeof (n2), &(l), sizeof (l), &(n3), sizeof (n3), &(n4), sizeof (n4), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n1;
        }
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        
//Patch 0:
if ((strcmp(x, "N1") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(f), sizeof (f), &(n2), sizeof (n2), &(l), sizeof (l), &(n3), sizeof (n3), &(n4), sizeof (n4), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n1;

//CodeSeg 1:
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
CondTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        
//Patch 0:
if ((strcmp(x, "N1") == 0) || (__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(f), sizeof (f), &(n2), sizeof (n2), &(l), sizeof (l), &(n3), sizeof (n3), &(n4), sizeof (n4), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n1;

//CodeSeg 1:
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((strcmp(x, "N2") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(f), sizeof (f), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n2;
        }
        else if (__get_mutant()==1) {
        if ((strcmp(x, "N2") == 0) || (__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(f), sizeof (f), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n2;
        }
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        
//Patch 0:
if ((strcmp(x, "N2") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(f), sizeof (f), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n2;

//CodeSeg 1:
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        
//Patch 0:
if ((strcmp(x, "N2") == 0) || (__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(f), sizeof (f), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n2;

//CodeSeg 1:
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((strcmp(x, "N3") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n3;
        }
        else if (__get_mutant()==1) {
        if ((strcmp(x, "N3") == 0) || (__is_neg(10, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n3;
        }
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        
//Patch 0:
if ((strcmp(x, "N3") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n3;

//CodeSeg 1:
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        
//Patch 0:
if ((strcmp(x, "N3") == 0) || (__is_neg(10, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n3;

//CodeSeg 1:
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((strcmp(x, "N4") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(e), sizeof (e), &(n1), sizeof (n1), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n4;
        }
        else if (__get_mutant()==1) {
        if ((strcmp(x, "N4") == 0) || (__is_neg(10, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(e), sizeof (e), &(n1), sizeof (n1), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n4;
        }
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        
//Patch 0:
if ((strcmp(x, "N4") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(e), sizeof (e), &(n1), sizeof (n1), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n4;

//CodeSeg 1:
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        
//Patch 0:
if ((strcmp(x, "N4") == 0) || (__is_neg(10, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(e), sizeof (e), &(n1), sizeof (n1), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n4;

//CodeSeg 1:
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((strcmp(x, "H") == 0) && !(__is_neg(12, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(e), sizeof (e), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
            node = l->head;
        }
        else if (__get_mutant()==1) {
        if ((strcmp(x, "H") == 0) || (__is_neg(12, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(e), sizeof (e), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
            node = l->head;
        }
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        
//Patch 0:
if ((strcmp(x, "H") == 0) && !(__is_neg(12, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(e), sizeof (e), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    node = l->head;

//CodeSeg 1:
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        
//Patch 0:
if ((strcmp(x, "H") == 0) || (__is_neg(12, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(e), sizeof (e), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    node = l->head;

//CodeSeg 1:
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    //prophet generated patch
    if (__get_mutant()==0) {
    printf((" %##uni*##"), hasLoop(l));
    }
    return 0;


}

Merged code building succ, going to invoke tester!
StringConstTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
        if (ln1->next == l->head)
            return 1;
       // else
      //  ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
        if (ln1==ln2)
            return 0;
        count = count+1;
    }
    return 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    
//Patch 0:
printf((" %##uni*##"), hasLoop(l));

//CodeSeg 1:
    return 0;


}

Testing negative cases!
Generate a candidate with schema id: 78
Generate a candidate with schema id: 34
Generate a candidate with schema id: 6
Total cnt of passed cond schemas: 9
Total cnt of cond schemas: 65
Counter: 86
Batcher Size:0
The found score 19999995.000000 is greater than current score 4996.000000!
Terminate current session!
Generate a candidate with schema id: 78
Generate a candidate with schema id: 34
Generate a candidate with schema id: 6
Total cnt of passed cond schemas: 9
Total cnt of cond schemas: 65
The first schema id that generates patch: 6
Found a fix! Store to: __fixed_prog.c
Found a fix! Store to: __fixed_prog.c-1
Found a fix! Store to: __fixed_prog.c-2
Repair process ends successfully!
Total 1755 different repair schemas!!!!
Total 3878 different repair candidate templates for scoring!!!
Total number of compiles: 28
Total number of test eval: 661
