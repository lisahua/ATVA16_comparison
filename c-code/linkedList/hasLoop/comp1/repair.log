Initialize the program!
Verify Test Cases
All passed!
Done Verification
Generating repair candidates!
Processing prog.c
Total 1747 different repair schemas!!!!
Total 3720 different repair candidate templates for scoring!!!
Trying different candidates!
BasicTester pointer: 0x9cd4bb8
StringConstTester pointer: 0x9cd5000
CondTester pointer: 0x9c23680
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:50
--Src File: prog.c
Fragment 0:
if ((l->head->next == l->head) && !(__abst_hole(l, l->head->next, l->head, l->head->element, l->size)))
    return 1;


CondTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((l->head->next == l->head) && !(__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:60
--Src File: prog.c
Fragment 0:
if ((ln2->next == l->head || ln2->next->next == l->head) && !(__abst_hole(l, ln2, l->head, ln2->next, ln2->next->next, ln1, ln1->next, count, l->head->next, l->head->element, ln1->element, l->size, ln2->element, ln2->next->element)))
    return 1;
else
    ln2 = ln2->next->next;


CondTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        
//Patch 0:
if ((ln2->next == l->head || ln2->next->next == l->head) && !(__is_neg(14, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:60
--Src File: prog.c
Fragment 0:
if ((ln2->next == l->head || ln2->next->next == l->head) || (__abst_hole(l, ln2, l->head, ln2->next, ln2->next->next, ln1, ln1->next, count, l->head->next, l->head->element, ln1->element, l->size, ln2->element, ln2->next->element)))
    return 1;
else
    ln2 = ln2->next->next;


CondTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        
//Patch 0:
if ((ln2->next == l->head || ln2->next->next == l->head) || (__is_neg(14, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((x[0] == '"') && !(__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    continue;


CondTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') && !(__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((x[0] == '"') || (__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    continue;


CondTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') || (__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:50
--Src File: prog.c
Fragment 0:
if ((l->head->next == l->head) || (__abst_hole(l, l->head->next, l->head, l->head->element, l->size)))
    return 1;


CondTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((l->head->next == l->head) || (__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:75
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) && !(__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:101
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "H") == 0) && !(__abst_hole(l, node, n4, l->head, e, n3, f, n2, n1, argv, argc, l->size)))
    node = l->head;


CondTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        
//Patch 0:
if ((strcmp(x, "H") == 0) && !(__is_neg(12, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(e), sizeof (e), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    node = l->head;

//CodeSeg 1:
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:101
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "H") == 0) || (__abst_hole(l, node, n4, l->head, e, n3, f, n2, n1, argv, argc, l->size)))
    node = l->head;


CondTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        
//Patch 0:
if ((strcmp(x, "H") == 0) || (__is_neg(12, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(e), sizeof (e), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    node = l->head;

//CodeSeg 1:
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:75
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) || (__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 10
Counter: 11
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:99
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N4") == 0) && !(__abst_hole(node, n3, n4, l, n2, e, n1, f, argv, argc)))
    node = n4;


CondTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        
//Patch 0:
if ((strcmp(x, "N4") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(e), sizeof (e), &(n1), sizeof (n1), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n4;

//CodeSeg 1:
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:11
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:99
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N4") == 0) || (__abst_hole(node, n3, n4, l, n2, e, n1, f, argv, argc)))
    node = n4;


CondTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        
//Patch 0:
if ((strcmp(x, "N4") == 0) || (__is_neg(10, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(e), sizeof (e), &(n1), sizeof (n1), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n4;

//CodeSeg 1:
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:97
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N3") == 0) && !(__abst_hole(node, n2, n3, n1, n4, l, e, f, argv, argc)))
    node = n3;


CondTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        
//Patch 0:
if ((strcmp(x, "N3") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n3;

//CodeSeg 1:
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:13
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:97
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N3") == 0) || (__abst_hole(node, n2, n3, n1, n4, l, e, f, argv, argc)))
    node = n3;


CondTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        
//Patch 0:
if ((strcmp(x, "N3") == 0) || (__is_neg(10, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n3;

//CodeSeg 1:
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:14
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:73
--Src File: prog.c
Fragment 0:
if ((argc < 2) && !(__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:15
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:73
--Src File: prog.c
Fragment 0:
if ((argc < 2) || (__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:95
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N2") == 0) && !(__abst_hole(node, n1, n2, n3, f, n4, l, e, argv, argc)))
    node = n2;


CondTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        
//Patch 0:
if ((strcmp(x, "N2") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(f), sizeof (f), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n2;

//CodeSeg 1:
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:95
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N2") == 0) || (__abst_hole(node, n1, n2, n3, f, n4, l, e, argv, argc)))
    node = n2;


CondTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        
//Patch 0:
if ((strcmp(x, "N2") == 0) || (__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(f), sizeof (f), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n2;

//CodeSeg 1:
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:93
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N1") == 0) && !(__abst_hole(node, n1, f, n2, l, n3, n4, e, argv, argc)))
    node = n1;


CondTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        
//Patch 0:
if ((strcmp(x, "N1") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(f), sizeof (f), &(n2), sizeof (n2), &(l), sizeof (l), &(n3), sizeof (n3), &(n4), sizeof (n4), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n1;

//CodeSeg 1:
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:19
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:93
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "N1") == 0) || (__abst_hole(node, n1, f, n2, l, n3, n4, e, argv, argc)))
    node = n1;


CondTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        
//Patch 0:
if ((strcmp(x, "N1") == 0) || (__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(f), sizeof (f), &(n2), sizeof (n2), &(l), sizeof (l), &(n3), sizeof (n3), &(n4), sizeof (n4), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n1;

//CodeSeg 1:
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 20
Counter: 21
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 12483
At location prog.c:50
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->head->next, l->head, l->head->element, l->size)))
    return 100;
if (l->head->next == l->head)
    return 1;


CondTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 100;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 12483
At location prog.c:50
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->head->next, l->head, l->head->element, l->size)))
    return 0;
if (l->head->next == l->head)
    return 1;


CondTester, a patch instance with id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 0;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:22
Preprocess the following candidate with CondTester:
Priority 12483
At location prog.c:50
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->head->next, l->head, l->head->element, l->size)))
    return 1;
if (l->head->next == l->head)
    return 1;


CondTester, a patch instance with id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 1;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:23
Preprocess the following candidate with CondTester:
Priority 12474
At location prog.c:28
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n)))
    return;
*n = malloc(sizeof(struct Entry));


CondTester, a patch instance with id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
if ((__is_neg(1, &(n), sizeof (n))))
    return;
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 12460
At location prog.c:21
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, (*l)->head, (*l)->head->next, (*l)->head->element, (*l)->size)))
    return;
*l = malloc(sizeof(struct List));


CondTester, a patch instance with id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:25
Preprocess the following candidate with CondTester:
Priority 12455
At location prog.c:73
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 0;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:26
Preprocess the following candidate with CondTester:
Priority 12455
At location prog.c:73
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 1;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 1;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:27
Preprocess the following candidate with CondTester:
Priority 12455
At location prog.c:73
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 2;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 2;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:28
Preprocess the following candidate with CondTester:
Priority 12455
At location prog.c:73
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 20;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 20;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:29
Preprocess the following candidate with CondTester:
Priority 9996
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((__abst_hole(ln1, ln1->next, l, ln2, l->head, ln2->next, ln2->next->next, count, l->head->next, l->head->element, ln1->element, l->size, ln2->element, ln2->next->element)))
    return 100;
ln1 = ln1->next;


CondTester, a patch instance with id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        
//Patch 0:
if ((__is_neg(14, &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 100;
ln1 = ln1->next;

//CodeSeg 1:
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 30
Counter: 31
Batcher Size:30
Preprocess the following candidate with CondTester:
Priority 9996
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((__abst_hole(ln1, ln1->next, l, ln2, l->head, ln2->next, ln2->next->next, count, l->head->next, l->head->element, ln1->element, l->size, ln2->element, ln2->next->element)))
    break;
ln1 = ln1->next;


CondTester, a patch instance with id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        
//Patch 0:
if ((__is_neg(14, &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    break;
ln1 = ln1->next;

//CodeSeg 1:
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:31
Preprocess the following candidate with CondTester:
Priority 9996
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((__abst_hole(ln1, ln1->next, l, ln2, l->head, ln2->next, ln2->next->next, count, l->head->next, l->head->element, ln1->element, l->size, ln2->element, ln2->next->element)))
    return 0;
ln1 = ln1->next;


CondTester, a patch instance with id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        
//Patch 0:
if ((__is_neg(14, &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 0;
ln1 = ln1->next;

//CodeSeg 1:
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 32
Counter: 33
Batcher Size:32
Preprocess the following candidate with CondTester:
Priority 9996
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((__abst_hole(ln1, ln1->next, l, ln2, l->head, ln2->next, ln2->next->next, count, l->head->next, l->head->element, ln1->element, l->size, ln2->element, ln2->next->element)))
    return 1;
ln1 = ln1->next;


CondTester, a patch instance with id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        
//Patch 0:
if ((__is_neg(14, &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
ln1 = ln1->next;

//CodeSeg 1:
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:33
Preprocess the following candidate with CondTester:
Priority 9979
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    return 0;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:34
Preprocess the following candidate with CondTester:
Priority 9979
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    return 1;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:35
Preprocess the following candidate with CondTester:
Priority 9979
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    return 2;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:36
Preprocess the following candidate with CondTester:
Priority 9979
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    return 20;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:37
Preprocess the following candidate with CondTester:
Priority 9979
At location prog.c:91
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, n1, n4, n2, n3, e, argv, argc)))
    break;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    break;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:28
--Src File: prog.c
Fragment 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Entry));


BasicTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 39
Counter: 40
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:21
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*(l))->head;
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*(l))->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 40
Counter: 41
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority 7483
At location prog.c:50
--Src File: prog.c
Fragment 0:
exit(1);
if (l->head->next == l->head)
    return 1;


BasicTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
exit(1);
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 41
Counter: 42
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority 7483
At location prog.c:50
--Src File: prog.c
Fragment 0:
if (l->head->next == l->head)
    return 1;
if (l->head->next == l->head)
    return 1;


BasicTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if (l->head->next == l->head)
    return 1;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 42
Counter: 43
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority 7483
At location prog.c:50
--Src File: prog.c
Fragment 0:
newList(&(l));
if (l->head->next == l->head)
    return 1;


BasicTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
newList(&(l));
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 43
Counter: 44
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7483
At location prog.c:50
--Src File: prog.c
Fragment 0:
printf(" %d", hasLoop((l)));
if (l->head->next == l->head)
    return 1;


BasicTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
printf(" %d", hasLoop((l)));
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 44
Counter: 45
Batcher Size:44
Preprocess the following candidate with StringConstTester:
Priority 7482
At location prog.c:108
--Src File: prog.c
Fragment 0:
printf((__abst_hole()), hasLoop(l));


StringConstTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    
//Patch 0:
printf((" %##uni*##"), hasLoop(l));

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 45
Counter: 46
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 7474
At location prog.c:28
--Src File: prog.c
Fragment 0:
*n = malloc(sizeof(struct Entry));
*n = malloc(sizeof(struct Entry));


BasicTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
*n = malloc(sizeof(struct Entry));
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 46
Counter: 47
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 7474
At location prog.c:28
--Src File: prog.c
Fragment 0:
exit(1);
*n = malloc(sizeof(struct Entry));


BasicTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
exit(1);
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 47
Counter: 48
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 7460
At location prog.c:21
--Src File: prog.c
Fragment 0:
exit(1);
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
exit(1);
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 48
Counter: 49
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 7460
At location prog.c:21
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
newNode(&((*(l))->head));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 49
Counter: 50
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 7460
At location prog.c:21
--Src File: prog.c
Fragment 0:
*l = malloc(sizeof(struct List));
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
*l = malloc(sizeof(struct List));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 50
Counter: 51
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 7460
At location prog.c:21
--Src File: prog.c
Fragment 0:
newNode(&((*l)->head));
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
newNode(&((*l)->head));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 51
Counter: 52
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 7460
At location prog.c:21
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*l)->head;
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*l)->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 52
Counter: 53
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 7455
At location prog.c:73
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;


BasicTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 53
Counter: 54
Batcher Size:53
Preprocess the following candidate with BasicTester:
Priority 7455
At location prog.c:73
--Src File: prog.c
Fragment 0:
exit(1);
if (argc < 2)
    return 0;


BasicTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
exit(1);
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 54
Counter: 55
Batcher Size:54
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
if ((__abst_hole(count, ln2, l, ln1)))
    return 0;
exit(1);


CondTester, a patch instance with id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln2), sizeof (ln2), &(l), sizeof (l), &(ln1), sizeof (ln1))))
    return 0;
exit(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 55
Counter: 56
Batcher Size:55
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
if ((__abst_hole(count, ln2, l, ln1)))
    return 1;
exit(1);


CondTester, a patch instance with id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln2), sizeof (ln2), &(l), sizeof (l), &(ln1), sizeof (ln1))))
    return 1;
exit(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 56
Counter: 57
Batcher Size:56
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
if ((__abst_hole(count, ln2, l, ln1)))
    return 100;
exit(1);


CondTester, a patch instance with id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln2), sizeof (ln2), &(l), sizeof (l), &(ln1), sizeof (ln1))))
    return 100;
exit(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 57
Counter: 58
Batcher Size:57
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
_Exit(1);


BasicTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
_Exit(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 58
Counter: 59
Batcher Size:58
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
abs(1);


BasicTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
abs(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 59
Counter: 60
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
abs(1);


BasicTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
abs(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 60
Counter: 61
Batcher Size:60
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(count, ln2, l, ln1)))
    exit(1);


CondTester, a patch instance with id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
if (!(__is_neg(4, &(count), sizeof (count), &(ln2), sizeof (ln2), &(l), sizeof (l), &(ln1), sizeof (ln1))))
    exit(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 61
Counter: 62
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
strerror(1);


BasicTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
strerror(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 62
Counter: 63
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
putchar(1);


BasicTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
putchar(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 63
Counter: 64
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:68
--Src File: prog.c
Fragment 0:
exit(1);


BasicTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
exit(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Spawn 1 instances, now Total 64
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(4, &(count), sizeof (count), &(ln2), sizeof (ln2), &(l), sizeof (l), &(ln1), sizeof (ln1))))
        return 0;
    exit(1);
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(4, &(count), sizeof (count), &(ln2), sizeof (ln2), &(l), sizeof (l), &(ln1), sizeof (ln1))))
        return 1;
    exit(1);
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(4, &(count), sizeof (count), &(ln2), sizeof (ln2), &(l), sizeof (l), &(ln1), sizeof (ln1))))
        return 100;
    exit(1);
    }
    else if (__get_mutant()==3) {
    _Exit(1);
    }
    else if (__get_mutant()==4) {
    abs(1);
    }
    else if (__get_mutant()==5) {
    abs(1);
    }
    else if (__get_mutant()==6) {
    if (!(__is_neg(4, &(count), sizeof (count), &(ln2), sizeof (ln2), &(l), sizeof (l), &(ln1), sizeof (ln1))))
        exit(1);
    }
    else if (__get_mutant()==7) {
    strerror(1);
    }
    else if (__get_mutant()==8) {
    putchar(1);
    }
    else if (__get_mutant()==9) {
    exit(1);
    }
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln2), sizeof (ln2), &(l), sizeof (l), &(ln1), sizeof (ln1))))
    return 0;
exit(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 5 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 9 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln2), sizeof (ln2), &(l), sizeof (l), &(ln1), sizeof (ln1))))
    return 1;
exit(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln2), sizeof (ln2), &(l), sizeof (l), &(ln1), sizeof (ln1))))
    return 100;
exit(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
_Exit(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
abs(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
abs(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
if (!(__is_neg(4, &(count), sizeof (count), &(ln2), sizeof (ln2), &(l), sizeof (l), &(ln1), sizeof (ln1))))
    exit(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
strerror(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
putchar(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
exit(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
CondTester, Postprocessing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    
//Patch 0:
if ((__is_neg(4, &(count), sizeof (count), &(ln2), sizeof (ln2), &(l), sizeof (l), &(ln1), sizeof (ln1))))
    return 0;
exit(1);

//CodeSeg 1:
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Trying a synthesis expr 1
Verifing Negative cases!
Verifying positive cases
Passed Positive Cases
Passed!
Passed with updated best score 4999962.000000
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
        return;
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==1) {
    (*l)->head->next = (*(l))->head;
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==2) {
    exit(1);
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==3) {
    newNode(&((*(l))->head));
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==4) {
    *l = malloc(sizeof(struct List));
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==5) {
    newNode(&((*l)->head));
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==6) {
    (*l)->head->next = (*l)->head;
    *l = malloc(sizeof(struct List));
    }
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*(l))->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
exit(1);
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
newNode(&((*(l))->head));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
*l = malloc(sizeof(struct List));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
newNode(&((*l)->head));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*l)->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(1, &(n), sizeof (n))))
        return;
    *n = malloc(sizeof(struct Entry));
    }
    else if (__get_mutant()==1) {
    (*n)->next = ((void *)0);
    *n = malloc(sizeof(struct Entry));
    }
    else if (__get_mutant()==2) {
    *n = malloc(sizeof(struct Entry));
    *n = malloc(sizeof(struct Entry));
    }
    else if (__get_mutant()==3) {
    exit(1);
    *n = malloc(sizeof(struct Entry));
    }
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
if ((__is_neg(1, &(n), sizeof (n))))
    return;
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 1
Iteration 2
Not caught by the negative case, give up!
BasicTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
*n = malloc(sizeof(struct Entry));
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
exit(1);
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((l->head->next == l->head) && !(__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
        return 1;
    }
    else if (__get_mutant()==1) {
    if ((l->head->next == l->head) || (__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
        return 1;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
        return 100;
    if (l->head->next == l->head)
        return 1;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
        return 0;
    if (l->head->next == l->head)
        return 1;
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
        return 1;
    if (l->head->next == l->head)
        return 1;
    }
    else if (__get_mutant()==5) {
    exit(1);
    if (l->head->next == l->head)
        return 1;
    }
    else if (__get_mutant()==6) {
    if (l->head->next == l->head)
        return 1;
    if (l->head->next == l->head)
        return 1;
    }
    else if (__get_mutant()==7) {
    newList(&(l));
    if (l->head->next == l->head)
        return 1;
    }
    else if (__get_mutant()==8) {
    printf(" %d", hasLoop((l)));
    if (l->head->next == l->head)
        return 1;
    }
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((l->head->next == l->head) && !(__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((l->head->next == l->head) || (__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 100;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 0;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 4 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
Log 0 0
Log 1 0
Log 2 1
Testing 5 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 1
Iteration 1
Branch 0: 1
Branch 1: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 0
Iteration 2
Branch 0: 1
Branch 1: 1
Log 0 1
Log 1 1
Testing 9 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
CondTester, Testing instance id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &(l->head->next), sizeof (l->head->next), &(l->head), sizeof (l->head), &(l->head->element), sizeof (l->head->element), &(l->size), sizeof (l->size))))
    return 1;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
exit(1);
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
if (l->head->next == l->head)
    return 1;
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
newList(&(l));
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    
//Patch 0:
printf(" %d", hasLoop((l)));
if (l->head->next == l->head)
    return 1;

//CodeSeg 1:
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((__is_neg(14, &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 100;
        ln1 = ln1->next;
        }
        else if (__get_mutant()==1) {
        if ((__is_neg(14, &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            break;
        ln1 = ln1->next;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(14, &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 0;
        ln1 = ln1->next;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(14, &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 1;
        ln1 = ln1->next;
        }
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        
//Patch 0:
if ((__is_neg(14, &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 100;
ln1 = ln1->next;

//CodeSeg 1:
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 1
Branch 1: 1
Branch 2: 1
CondTester, Testing instance id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        
//Patch 0:
if ((__is_neg(14, &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    break;
ln1 = ln1->next;

//CodeSeg 1:
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        
//Patch 0:
if ((__is_neg(14, &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 0;
ln1 = ln1->next;

//CodeSeg 1:
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        
//Patch 0:
if ((__is_neg(14, &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
ln1 = ln1->next;

//CodeSeg 1:
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 0
Branch 94: 0
Branch 95: 0
Branch 96: 0
Branch 97: 0
Branch 98: 0
Branch 99: 1
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 0
Branch 93: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 0
Branch 92: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 0
Branch 91: 1
Branch 92: 1
Branch 93: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Branch 8: 0
Branch 9: 0
Branch 10: 0
Branch 11: 0
Branch 12: 0
Branch 13: 0
Branch 14: 0
Branch 15: 0
Branch 16: 0
Branch 17: 0
Branch 18: 0
Branch 19: 0
Branch 20: 0
Branch 21: 0
Branch 22: 0
Branch 23: 0
Branch 24: 0
Branch 25: 0
Branch 26: 0
Branch 27: 0
Branch 28: 0
Branch 29: 0
Branch 30: 0
Branch 31: 0
Branch 32: 0
Branch 33: 0
Branch 34: 0
Branch 35: 0
Branch 36: 0
Branch 37: 0
Branch 38: 0
Branch 39: 0
Branch 40: 0
Branch 41: 0
Branch 42: 0
Branch 43: 0
Branch 44: 0
Branch 45: 0
Branch 46: 0
Branch 47: 0
Branch 48: 0
Branch 49: 0
Branch 50: 0
Branch 51: 0
Branch 52: 0
Branch 53: 0
Branch 54: 0
Branch 55: 0
Branch 56: 0
Branch 57: 0
Branch 58: 0
Branch 59: 0
Branch 60: 0
Branch 61: 0
Branch 62: 0
Branch 63: 0
Branch 64: 0
Branch 65: 0
Branch 66: 0
Branch 67: 0
Branch 68: 0
Branch 69: 0
Branch 70: 0
Branch 71: 0
Branch 72: 0
Branch 73: 0
Branch 74: 0
Branch 75: 0
Branch 76: 0
Branch 77: 0
Branch 78: 0
Branch 79: 0
Branch 80: 0
Branch 81: 0
Branch 82: 0
Branch 83: 0
Branch 84: 0
Branch 85: 0
Branch 86: 0
Branch 87: 0
Branch 88: 0
Branch 89: 0
Branch 90: 1
Iteration 5
Not caught by the negative case, give up!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((ln2->next == l->head || ln2->next->next == l->head) && !(__is_neg(14, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 1;
        else
            ln2 = ln2->next->next;
        }
        else if (__get_mutant()==1) {
        if ((ln2->next == l->head || ln2->next->next == l->head) || (__is_neg(14, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
            return 1;
        else
            ln2 = ln2->next->next;
        }
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        
//Patch 0:
if ((ln2->next == l->head || ln2->next->next == l->head) && !(__is_neg(14, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        
//Patch 0:
if ((ln2->next == l->head || ln2->next->next == l->head) || (__is_neg(14, &(l), sizeof (l), &(ln2), sizeof (ln2), &(l->head), sizeof (l->head), &(ln2->next), sizeof (ln2->next), &(ln2->next->next), sizeof (ln2->next->next), &(ln1), sizeof (ln1), &(ln1->next), sizeof (ln1->next), &(count), sizeof (count), &(l->head->next), sizeof (l->head->next), &(l->head->element), sizeof (l->head->element), &(ln1->element), sizeof (ln1->element), &(l->size), sizeof (l->size), &(ln2->element), sizeof (ln2->element), &(ln2->next->element), sizeof (ln2->next->element))))
    return 1;
else
    ln2 = ln2->next->next;

//CodeSeg 1:
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Iteration 3
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 1;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 2;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==5) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 20;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==6) {
    if (argc < 2)
        return 0;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==7) {
    exit(1);
    if (argc < 2)
        return 0;
    }
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 1;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 2;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 20;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 1
BasicTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    
//Patch 0:
exit(1);
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((x[0] == '"') && !(__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            continue;
        }
        else if (__get_mutant()==1) {
        if ((x[0] == '"') || (__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            continue;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 0;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 1;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 2;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==5) {
        if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 20;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==6) {
        if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            break;
        if (x[0] == '"')
            continue;
        }
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') && !(__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 0
Iteration 3
Not caught by the negative case, give up!
CondTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') || (__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 1
Branch 1: 1
CondTester, Testing instance id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 6
Not caught by the negative case, give up!
CondTester, Testing instance id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 1
CondTester, Testing instance id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 4
Branch 0: 0
Branch 1: 1
Iteration 5
Branch 0: 1
CondTester, Testing instance id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(10, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(n1), sizeof (n1), &(n4), sizeof (n4), &(n2), sizeof (n2), &(n3), sizeof (n3), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    break;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Not caught by the negative case, give up!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((strcmp(x, "N1") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(f), sizeof (f), &(n2), sizeof (n2), &(l), sizeof (l), &(n3), sizeof (n3), &(n4), sizeof (n4), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n1;
        }
        else if (__get_mutant()==1) {
        if ((strcmp(x, "N1") == 0) || (__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(f), sizeof (f), &(n2), sizeof (n2), &(l), sizeof (l), &(n3), sizeof (n3), &(n4), sizeof (n4), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n1;
        }
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        
//Patch 0:
if ((strcmp(x, "N1") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(f), sizeof (f), &(n2), sizeof (n2), &(l), sizeof (l), &(n3), sizeof (n3), &(n4), sizeof (n4), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n1;

//CodeSeg 1:
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
CondTester, Testing instance id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        
//Patch 0:
if ((strcmp(x, "N1") == 0) || (__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(f), sizeof (f), &(n2), sizeof (n2), &(l), sizeof (l), &(n3), sizeof (n3), &(n4), sizeof (n4), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n1;

//CodeSeg 1:
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((strcmp(x, "N2") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(f), sizeof (f), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n2;
        }
        else if (__get_mutant()==1) {
        if ((strcmp(x, "N2") == 0) || (__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(f), sizeof (f), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n2;
        }
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        
//Patch 0:
if ((strcmp(x, "N2") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(f), sizeof (f), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n2;

//CodeSeg 1:
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        
//Patch 0:
if ((strcmp(x, "N2") == 0) || (__is_neg(10, &(node), sizeof (node), &(n1), sizeof (n1), &(n2), sizeof (n2), &(n3), sizeof (n3), &(f), sizeof (f), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n2;

//CodeSeg 1:
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((strcmp(x, "N3") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n3;
        }
        else if (__get_mutant()==1) {
        if ((strcmp(x, "N3") == 0) || (__is_neg(10, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n3;
        }
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        
//Patch 0:
if ((strcmp(x, "N3") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n3;

//CodeSeg 1:
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        
//Patch 0:
if ((strcmp(x, "N3") == 0) || (__is_neg(10, &(node), sizeof (node), &(n2), sizeof (n2), &(n3), sizeof (n3), &(n1), sizeof (n1), &(n4), sizeof (n4), &(l), sizeof (l), &(e), sizeof (e), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n3;

//CodeSeg 1:
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((strcmp(x, "N4") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(e), sizeof (e), &(n1), sizeof (n1), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n4;
        }
        else if (__get_mutant()==1) {
        if ((strcmp(x, "N4") == 0) || (__is_neg(10, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(e), sizeof (e), &(n1), sizeof (n1), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            node = n4;
        }
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        
//Patch 0:
if ((strcmp(x, "N4") == 0) && !(__is_neg(10, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(e), sizeof (e), &(n1), sizeof (n1), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n4;

//CodeSeg 1:
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        
//Patch 0:
if ((strcmp(x, "N4") == 0) || (__is_neg(10, &(node), sizeof (node), &(n3), sizeof (n3), &(n4), sizeof (n4), &(l), sizeof (l), &(n2), sizeof (n2), &(e), sizeof (e), &(n1), sizeof (n1), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    node = n4;

//CodeSeg 1:
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((strcmp(x, "H") == 0) && !(__is_neg(12, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(e), sizeof (e), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
            node = l->head;
        }
        else if (__get_mutant()==1) {
        if ((strcmp(x, "H") == 0) || (__is_neg(12, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(e), sizeof (e), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
            node = l->head;
        }
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        
//Patch 0:
if ((strcmp(x, "H") == 0) && !(__is_neg(12, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(e), sizeof (e), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    node = l->head;

//CodeSeg 1:
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        
//Patch 0:
if ((strcmp(x, "H") == 0) || (__is_neg(12, &(l), sizeof (l), &(node), sizeof (node), &(n4), sizeof (n4), &(l->head), sizeof (l->head), &(e), sizeof (e), &(n3), sizeof (n3), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    node = l->head;

//CodeSeg 1:
        e->next = node;
        e = e->next;
    }
    fclose(f);

    printf(" %d",hasLoop(l));
    return 0;


}

Testing negative cases!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    //prophet generated patch
    if (__get_mutant()==0) {
    printf((" %##uni*##"), hasLoop(l));
    }
    return 0;


}

Merged code building succ, going to invoke tester!
StringConstTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
    //    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
    (*l)->size = (*l)->size + 1;
}

int hasLoop(struct List* l) {
    if (l->head->next == l->head)
        return 1;
    struct Entry* ln1 = l->head;
    struct Entry* ln2 = l->head;
    int count=0;
    while (count <100) {
    //    if (ln1->next == l->head)
    //        return 1;
    //    else
        ln1 = ln1->next;
        if (ln2->next == l->head || ln2->next->next == l->head)
            return 1;
        else
            ln2 = ln2->next->next;
   //     if (ln1==ln2)
    //        return 0;
        count = count+1;
    }
    exit(1);
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    struct Entry* n1 ;
    newNode(&n1);
    struct Entry* n2 ;
    newNode(&n2);
    struct Entry* n3 ;
    newNode(&n3);
    struct Entry* n4 ;
    newNode(&n4);
    int status = 0;
    struct Entry* e = l->head;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')
            continue;
        if (strcmp(x,"N1")==0)
            node = n1;
        if (strcmp(x,"N2")==0)
            node = n2;
        if (strcmp(x,"N3")==0)
            node = n3;
        if (strcmp(x,"N4")==0)
            node = n4;
        if (strcmp(x,"H")==0)
            node = l->head;
        e->next = node;
        e = e->next;
    }
    fclose(f);

    
//Patch 0:
printf((" %##uni*##"), hasLoop(l));

//CodeSeg 1:
    return 0;


}

Testing negative cases!
Generate a candidate with schema id: 55
Total cnt of passed cond schemas: 1
Total cnt of cond schemas: 42
Counter: 65
Batcher Size:0
The found score 4999962.000000 is greater than current score 5000.000000!
Terminate current session!
Generate a candidate with schema id: 55
Total cnt of passed cond schemas: 1
Total cnt of cond schemas: 42
The first schema id that generates patch: 55
Found a fix! Store to: __fixed_prog.c
Repair process ends successfully!
Total 1747 different repair schemas!!!!
Total 3720 different repair candidate templates for scoring!!!
Total number of compiles: 16
Total number of test eval: 212
