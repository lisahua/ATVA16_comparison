Initialize the program!
Verify Test Cases
All passed!
Done Verification
Generating repair candidates!
Processing prog.c
Total 669 different repair schemas!!!!
Total 1458 different repair candidate templates for scoring!!!
Trying different candidates!
BasicTester pointer: 0xb563890
StringConstTester pointer: 0xb583c90
CondTester pointer: 0xb575010
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:39
--Src File: prog.c
Fragment 0:
if ((e->next->element < v) && !(__abst_hole(v, e, e->next->element, e->next, l, (*l)->head, in, (*l)->size, e->next->next, e->element)))
    e = e->next;
else
    break;


CondTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
if ((e->next->element < v) && !(__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:39
--Src File: prog.c
Fragment 0:
if ((e->next->element < v) || (__abst_hole(v, e, e->next->element, e->next, l, (*l)->head, in, (*l)->size, e->next->next, e->element)))
    e = e->next;
else
    break;


CondTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
if ((e->next->element < v) || (__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((x[0] != '"') && !(__abst_hole(f, l, argv, node, argc))) {
    insertSort(&l, atoi(x));
}


CondTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] != '"') && !(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc)))) {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((x[0] != '"') || (__abst_hole(f, l, argv, node, argc))) {
    insertSort(&l, atoi(x));
}


CondTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] != '"') || (__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc)))) {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:51
--Src File: prog.c
Fragment 0:
if ((argc < 2) && !(__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:51
--Src File: prog.c
Fragment 0:
if ((argc < 2) || (__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:53
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) && !(__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:53
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) || (__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 12493
At location prog.c:35
--Src File: prog.c
Fragment 0:
if ((__abst_hole(in, v, in->element, l, in->next)))
    return;
newNode(&in);


CondTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
if ((__is_neg(5, &(in), sizeof (in), &(v), sizeof (v), &(in->element), sizeof (in->element), &(l), sizeof (l), &(in->next), sizeof (in->next))))
    return;
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 12483
At location prog.c:28
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n)))
    return;
*n = malloc(sizeof(struct Entry));


CondTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
if ((__is_neg(1, &(n), sizeof (n))))
    return;
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 10
Counter: 11
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 12476
At location prog.c:21
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, (*l)->head, (*l)->head->next, (*l)->head->element, (*l)->size)))
    return;
*l = malloc(sizeof(struct List));


CondTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:11
Preprocess the following candidate with CondTester:
Priority 12471
At location prog.c:51
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 0;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 12471
At location prog.c:51
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 1;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 1;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:13
Preprocess the following candidate with CondTester:
Priority 12471
At location prog.c:51
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 2;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 2;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:14
Preprocess the following candidate with CondTester:
Priority 12471
At location prog.c:51
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 20;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 20;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:15
Preprocess the following candidate with CondTester:
Priority 9999
At location prog.c:68
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, node->next->element, node->next, l, l->head, l->size, f, argv, argc, node->next->next, node->element)))
    return 20;
printf("%d ", node->next->element);


CondTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 20;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 9999
At location prog.c:68
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, node->next->element, node->next, l, l->head, l->size, f, argv, argc, node->next->next, node->element)))
    break;
printf("%d ", node->next->element);


CondTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    break;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 9999
At location prog.c:68
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, node->next->element, node->next, l, l->head, l->size, f, argv, argc, node->next->next, node->element)))
    return 0;
printf("%d ", node->next->element);


CondTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 0;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 9999
At location prog.c:68
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, node->next->element, node->next, l, l->head, l->size, f, argv, argc, node->next->next, node->element)))
    return 1;
printf("%d ", node->next->element);


CondTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 1;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:19
Preprocess the following candidate with CondTester:
Priority 9999
At location prog.c:68
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, node->next->element, node->next, l, l->head, l->size, f, argv, argc, node->next->next, node->element)))
    return 2;
printf("%d ", node->next->element);


CondTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 2;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 20
Counter: 21
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 9991
At location prog.c:61
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, f, node, l->head, argv, argc, l->size)))
    return 0;
insertSort(&l, atoi(x));


CondTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    return 0;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 9991
At location prog.c:61
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, f, node, l->head, argv, argc, l->size)))
    return 1;
insertSort(&l, atoi(x));


CondTester, a patch instance with id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    return 1;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:22
Preprocess the following candidate with CondTester:
Priority 9991
At location prog.c:61
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, f, node, l->head, argv, argc, l->size)))
    return 2;
insertSort(&l, atoi(x));


CondTester, a patch instance with id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    return 2;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:23
Preprocess the following candidate with CondTester:
Priority 9991
At location prog.c:61
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, f, node, l->head, argv, argc, l->size)))
    break;
insertSort(&l, atoi(x));


CondTester, a patch instance with id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    break;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 9991
At location prog.c:61
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, f, node, l->head, argv, argc, l->size)))
    return 20;
insertSort(&l, atoi(x));


CondTester, a patch instance with id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    return 20;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:25
Preprocess the following candidate with CondTester:
Priority 9985
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, argv, node, argc)))
    return 0;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


CondTester, a patch instance with id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
    return 0;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:26
Preprocess the following candidate with CondTester:
Priority 9985
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, argv, node, argc)))
    return 1;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


CondTester, a patch instance with id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
    return 1;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:27
Preprocess the following candidate with CondTester:
Priority 9985
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, argv, node, argc)))
    return 20;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


CondTester, a patch instance with id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
    return 20;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:28
Preprocess the following candidate with CondTester:
Priority 9985
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, argv, node, argc)))
    break;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


CondTester, a patch instance with id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
    break;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:29
Preprocess the following candidate with CondTester:
Priority 9985
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, argv, node, argc)))
    return 2;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


CondTester, a patch instance with id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
    return 2;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 30
Counter: 31
Batcher Size:30
Preprocess the following candidate with CondTester:
Priority 9970
At location prog.c:39
--Src File: prog.c
Fragment 0:
if ((__abst_hole(v, e, e->next->element, e->next, l, (*l)->head, in, (*l)->size, e->next->next, e->element)))
    return;
if (e->next->element < v)
    e = e->next;
else
    break;


CondTester, a patch instance with id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
if ((__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    return;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:31
Preprocess the following candidate with CondTester:
Priority 9970
At location prog.c:39
--Src File: prog.c
Fragment 0:
if ((__abst_hole(v, e, e->next->element, e->next, l, (*l)->head, in, (*l)->size, e->next->next, e->element)))
    break;
if (e->next->element < v)
    e = e->next;
else
    break;


CondTester, a patch instance with id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
if ((__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    break;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 32
Counter: 33
Batcher Size:32
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:35
--Src File: prog.c
Fragment 0:
in->element = (0);
newNode(&in);


BasicTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
in->element = (0);
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:33
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:21
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*(l))->head;
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*(l))->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:34
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:28
--Src File: prog.c
Fragment 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Entry));


BasicTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:35
Preprocess the following candidate with StringConstTester:
Priority 7499
At location prog.c:68
--Src File: prog.c
Fragment 0:
printf((__abst_hole()), node->next->element);


StringConstTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf(("%d##uni*##"), node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority 7493
At location prog.c:35
--Src File: prog.c
Fragment 0:
in->next = (in);
newNode(&in);


BasicTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
in->next = (in);
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority 7493
At location prog.c:35
--Src File: prog.c
Fragment 0:
newNode(&in);
newNode(&in);


BasicTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
newNode(&in);
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority 7493
At location prog.c:35
--Src File: prog.c
Fragment 0:
printf("%d ", (in)->next->element);
newNode(&in);


BasicTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
printf("%d ", (in)->next->element);
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 39
Counter: 40
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority 7493
At location prog.c:35
--Src File: prog.c
Fragment 0:
in->next = (in)->next;
newNode(&in);


BasicTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
in->next = (in)->next;
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 40
Counter: 41
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority 7493
At location prog.c:35
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
newNode(&in);


BasicTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
newNode(&((*(l))->head));
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 41
Counter: 42
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority 7493
At location prog.c:35
--Src File: prog.c
Fragment 0:
newNode(&(in));
newNode(&in);


BasicTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
newNode(&(in));
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 42
Counter: 43
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority 7493
At location prog.c:35
--Src File: prog.c
Fragment 0:
in->element = v;
newNode(&in);


BasicTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
in->element = v;
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 43
Counter: 44
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 7493
At location prog.c:35
--Src File: prog.c
Fragment 0:
in->element = (v);
newNode(&in);


BasicTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
in->element = (v);
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 44
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(5, &(in), sizeof (in), &(v), sizeof (v), &(in->element), sizeof (in->element), &(l), sizeof (l), &(in->next), sizeof (in->next))))
        return;
    newNode(&in);
    }
    else if (__get_mutant()==1) {
    in->element = (0);
    newNode(&in);
    }
    else if (__get_mutant()==2) {
    in->next = (in);
    newNode(&in);
    }
    else if (__get_mutant()==3) {
    newNode(&in);
    newNode(&in);
    }
    else if (__get_mutant()==4) {
    printf("%d ", (in)->next->element);
    newNode(&in);
    }
    else if (__get_mutant()==5) {
    in->next = (in)->next;
    newNode(&in);
    }
    else if (__get_mutant()==6) {
    newNode(&((*(l))->head));
    newNode(&in);
    }
    else if (__get_mutant()==7) {
    newNode(&(in));
    newNode(&in);
    }
    else if (__get_mutant()==8) {
    in->element = v;
    newNode(&in);
    }
    else if (__get_mutant()==9) {
    in->element = (v);
    newNode(&in);
    }
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
if ((__is_neg(5, &(in), sizeof (in), &(v), sizeof (v), &(in->element), sizeof (in->element), &(l), sizeof (l), &(in->next), sizeof (in->next))))
    return;
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
BasicTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
in->element = (0);
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
in->next = (in);
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
newNode(&in);
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
printf("%d ", (in)->next->element);
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
in->next = (in)->next;
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
newNode(&((*(l))->head));
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
newNode(&(in));
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
in->element = v;
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
in->element = (v);
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 45
Batcher Size:34
Preprocess the following candidate with StringConstTester:
Priority 7489
At location prog.c:71
--Src File: prog.c
Fragment 0:
printf((__abst_hole()), l->size);


StringConstTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf((" %##uni*##"), l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 45
Counter: 46
Batcher Size:35
Preprocess the following candidate with BasicTester:
Priority 7483
At location prog.c:28
--Src File: prog.c
Fragment 0:
*n = malloc(sizeof(struct Entry));
*n = malloc(sizeof(struct Entry));


BasicTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
*n = malloc(sizeof(struct Entry));
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 46
Counter: 47
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority 7476
At location prog.c:21
--Src File: prog.c
Fragment 0:
newNode(&((*l)->head));
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
newNode(&((*l)->head));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 47
Counter: 48
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority 7476
At location prog.c:21
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
newNode(&((*(l))->head));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 48
Counter: 49
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority 7476
At location prog.c:21
--Src File: prog.c
Fragment 0:
*l = malloc(sizeof(struct List));
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
*l = malloc(sizeof(struct List));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 49
Counter: 50
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority 7476
At location prog.c:21
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*l)->head;
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*l)->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 50
Counter: 51
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority 7471
At location prog.c:51
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;


BasicTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 51
Counter: 52
Batcher Size:41
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:69
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, node->next, node->next->element, l, f, argv, argc, node->next->next, node->element)))
    return 0;
node = node->next;


CondTester, a patch instance with id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 0;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 52
Counter: 53
Batcher Size:42
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:69
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, node->next, node->next->element, l, f, argv, argc, node->next->next, node->element)))
    return 1;
node = node->next;


CondTester, a patch instance with id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 1;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 53
Counter: 54
Batcher Size:43
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:69
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, node->next, node->next->element, l, f, argv, argc, node->next->next, node->element)))
    return 2;
node = node->next;


CondTester, a patch instance with id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 2;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 54
Counter: 55
Batcher Size:44
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:69
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, node->next, node->next->element, l, f, argv, argc, node->next->next, node->element)))
    break;
node = node->next;


CondTester, a patch instance with id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    break;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 55
Counter: 56
Batcher Size:45
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:69
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, node->next, node->next->element, l, f, argv, argc, node->next->next, node->element)))
    return 20;
node = node->next;


CondTester, a patch instance with id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 20;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 56
Counter: 57
Batcher Size:46
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:69
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(node, node->next, node->next->element, l, f, argv, argc, node->next->next, node->element)))
    node = node->next;


CondTester, a patch instance with id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if (!(__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 57
Counter: 58
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:69
--Src File: prog.c
Fragment 0:
memset(node->next, 0, sizeof (*(node->next)));
node = node->next;


BasicTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
memset(node->next, 0, sizeof (*(node->next)));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 58
Counter: 59
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:69
--Src File: prog.c
Fragment 0:
memset(node, 0, sizeof (*(node)));
node = node->next;


BasicTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
memset(node, 0, sizeof (*(node)));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 59
Counter: 60
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
printf("%d ", node->next->element);
printf("%d ", node->next->element);


BasicTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf("%d ", node->next->element);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 60
Counter: 61
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
node = node->next;
printf("%d ", node->next->element);


BasicTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
node = node->next;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 61
Counter: 62
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);
printf("%d ", node->next->element);


BasicTester, a patch instance with id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf(" %d", l->size);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 62
Counter: 63
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
printf("%d ", (node)->next->element);
printf("%d ", node->next->element);


BasicTester, a patch instance with id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf("%d ", (node)->next->element);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 63
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
            return 20;
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==1) {
        if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
            break;
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
            return 0;
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
            return 1;
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
            return 2;
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==5) {
        printf(("%d##uni*##"), node->next->element);
        }
        else if (__get_mutant()==6) {
        printf("%d ", node->next->element);
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==7) {
        node = node->next;
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==8) {
        printf(" %d", l->size);
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==9) {
        printf("%d ", (node)->next->element);
        printf("%d ", node->next->element);
        }
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 20;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    break;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 0;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 1;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if ((__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 2;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
StringConstTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf(("%d##uni*##"), node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf("%d ", node->next->element);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
node = node->next;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf(" %d", l->size);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf("%d ", (node)->next->element);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 64
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
printf("%d ", node->next->element);


BasicTester, a patch instance with id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf(" %d", (l)->size);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 64
Counter: 65
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
insertSort(&l, atoi(x));
printf("%d ", node->next->element);


BasicTester, a patch instance with id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
insertSort(&l, atoi(x));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 65
Counter: 66
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
node = (l)->head;
printf("%d ", node->next->element);


BasicTester, a patch instance with id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
node = (l)->head;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 66
Counter: 67
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
node = (node)->next;
printf("%d ", node->next->element);


BasicTester, a patch instance with id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
node = (node)->next;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 67
Counter: 68
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
node = l->head;
printf("%d ", node->next->element);


BasicTester, a patch instance with id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
node = l->head;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 68
Counter: 69
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
node = (node);
printf("%d ", node->next->element);


BasicTester, a patch instance with id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
node = (node);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 69
Counter: 70
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
newList(&(l));
printf("%d ", node->next->element);


BasicTester, a patch instance with id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
newList(&(l));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 70
Counter: 71
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
newList(&l);
printf("%d ", node->next->element);


BasicTester, a patch instance with id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
newList(&l);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 71
Counter: 72
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
newNode(&(node));
printf("%d ", node->next->element);


BasicTester, a patch instance with id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
newNode(&(node));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 72
Counter: 73
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
wctomb("%d ", node->next->element);


BasicTester, a patch instance with id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
wctomb("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 73
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        //prophet generated patch
        if (__get_mutant()==0) {
        printf(" %d", (l)->size);
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==1) {
        insertSort(&l, atoi(x));
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==2) {
        node = (l)->head;
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==3) {
        node = (node)->next;
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==4) {
        node = l->head;
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==5) {
        node = (node);
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==6) {
        newList(&(l));
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==7) {
        newList(&l);
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==8) {
        newNode(&(node));
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==9) {
        wctomb("%d ", node->next->element);
        }
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf(" %d", (l)->size);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
insertSort(&l, atoi(x));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
node = (l)->head;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
node = (node)->next;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
node = l->head;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
node = (node);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
newList(&(l));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
newList(&l);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
newNode(&(node));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
wctomb("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 74
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
memset(node->next, 0, sizeof (*(node->next)));
printf("%d ", node->next->element);


BasicTester, a patch instance with id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
memset(node->next, 0, sizeof (*(node->next)));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 74
Counter: 75
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
printf("%d ", node->next->element);


BasicTester, a patch instance with id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if (argc < 2)
    return 0;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 75
Counter: 76
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
printf("%d ", node->next->element);


BasicTester, a patch instance with id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 76
Counter: 77
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
insertSort(&(l), atoi(x));
printf("%d ", node->next->element);


BasicTester, a patch instance with id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
insertSort(&(l), atoi(x));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 77
Counter: 78
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
printf("%d ", node->next->element);


BasicTester, a patch instance with id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if (f == ((void *)0))
    return 0;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 78
Counter: 79
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
memset(node, 0, sizeof (*(node)));
printf("%d ", node->next->element);


BasicTester, a patch instance with id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
memset(node, 0, sizeof (*(node)));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 79
Counter: 80
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
fclose((f));
printf("%d ", node->next->element);


BasicTester, a patch instance with id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
fclose((f));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 80
Counter: 81
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
fclose(f);
printf("%d ", node->next->element);


BasicTester, a patch instance with id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
fclose(f);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 81
Counter: 82
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
strchr("%d ", node->next->element);


BasicTester, a patch instance with id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
strchr("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 82
Counter: 83
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
strrchr("%d ", node->next->element);


BasicTester, a patch instance with id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
strrchr("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 83
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        //prophet generated patch
        if (__get_mutant()==0) {
        memset(node->next, 0, sizeof (*(node->next)));
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==1) {
        if (argc < 2)
            return 0;
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==2) {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==3) {
        insertSort(&(l), atoi(x));
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==4) {
        if (f == ((void *)0))
            return 0;
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==5) {
        memset(node, 0, sizeof (*(node)));
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==6) {
        fclose((f));
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==7) {
        fclose(f);
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==8) {
        strchr("%d ", node->next->element);
        }
        else if (__get_mutant()==9) {
        strrchr("%d ", node->next->element);
        }
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
memset(node->next, 0, sizeof (*(node->next)));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if (argc < 2)
    return 0;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
insertSort(&(l), atoi(x));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if (f == ((void *)0))
    return 0;
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
memset(node, 0, sizeof (*(node)));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
fclose((f));
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
fclose(f);
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
strchr("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
strrchr("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 84
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
insertSort("%d ", node->next->element);


BasicTester, a patch instance with id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
insertSort("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 84
Counter: 85
Batcher Size:44
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(node, node->next->element, node->next, l, l->head, l->size, f, argv, argc, node->next->next, node->element)))
    printf("%d ", node->next->element);


CondTester, a patch instance with id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if (!(__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 85
Counter: 86
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
insertSort("%d ", node->next->element);


BasicTester, a patch instance with id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
insertSort("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 86
Counter: 87
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
strchr("%d ", node->next->element);


BasicTester, a patch instance with id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
strchr("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 87
Counter: 88
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
strrchr("%d ", node->next->element);


BasicTester, a patch instance with id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
strrchr("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 88
Counter: 89
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
printf("%d ", node->next->element);


BasicTester, a patch instance with id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 89
Counter: 90
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
scanf("%d ", node->next->element);


BasicTester, a patch instance with id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
scanf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 90
Counter: 91
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
scanf("%d ", node->next->element);


BasicTester, a patch instance with id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
scanf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 91
Counter: 92
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
scanf("%d ", node->next->element);


BasicTester, a patch instance with id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
scanf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 92
Counter: 93
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:68
--Src File: prog.c
Fragment 0:
__overflow("%d ", node->next->element);


BasicTester, a patch instance with id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
__overflow("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 93
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        //prophet generated patch
        if (__get_mutant()==0) {
        insertSort("%d ", node->next->element);
        }
        else if (__get_mutant()==1) {
        if (!(__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
            printf("%d ", node->next->element);
        }
        else if (__get_mutant()==2) {
        insertSort("%d ", node->next->element);
        }
        else if (__get_mutant()==3) {
        strchr("%d ", node->next->element);
        }
        else if (__get_mutant()==4) {
        strrchr("%d ", node->next->element);
        }
        else if (__get_mutant()==5) {
        printf("%d ", node->next->element);
        }
        else if (__get_mutant()==6) {
        scanf("%d ", node->next->element);
        }
        else if (__get_mutant()==7) {
        scanf("%d ", node->next->element);
        }
        else if (__get_mutant()==8) {
        scanf("%d ", node->next->element);
        }
        else if (__get_mutant()==9) {
        __overflow("%d ", node->next->element);
        }
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
insertSort("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
if (!(__is_neg(11, &(node), sizeof (node), &(node->next->element), sizeof (node->next->element), &(node->next), sizeof (node->next), &(l), sizeof (l), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
BasicTester, Testing instance id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
insertSort("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
strchr("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
strrchr("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
scanf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
scanf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
scanf("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
__overflow("%d ", node->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 94
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:45
--Src File: prog.c
Fragment 0:
memset(e, 0, sizeof (*(e)));
e->next = in;


BasicTester, a patch instance with id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
memset(e, 0, sizeof (*(e)));
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 94
Counter: 95
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:45
--Src File: prog.c
Fragment 0:
memset(e->next, 0, sizeof (*(e->next)));
e->next = in;


BasicTester, a patch instance with id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
memset(e->next, 0, sizeof (*(e->next)));
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 95
Counter: 96
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:45
--Src File: prog.c
Fragment 0:
memset(in, 0, sizeof (*(in)));
e->next = in;


BasicTester, a patch instance with id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
memset(in, 0, sizeof (*(in)));
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 96
Counter: 97
Batcher Size:46
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:45
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(in, e, e->next, in->next, v, e->next->element, l, in->element, e->next->next, e->element)))
    e->next = in;


CondTester, a patch instance with id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
if (!(__is_neg(10, &(in), sizeof (in), &(e), sizeof (e), &(e->next), sizeof (e->next), &(in->next), sizeof (in->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in->element), sizeof (in->element), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 97
Counter: 98
Batcher Size:47
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:45
--Src File: prog.c
Fragment 0:
if ((__abst_hole(in, e, e->next, in->next, v, e->next->element, l, in->element, e->next->next, e->element)))
    return;
e->next = in;


CondTester, a patch instance with id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
if ((__is_neg(10, &(in), sizeof (in), &(e), sizeof (e), &(e->next), sizeof (e->next), &(in->next), sizeof (in->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in->element), sizeof (in->element), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    return;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 98
Counter: 99
Batcher Size:48
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:44
--Src File: prog.c
Fragment 0:
if ((__abst_hole(in, e, in->next, e->next, v, e->next->element, l, in->element, e->next->next, e->element)))
    return;
in->next = e->next;


CondTester, a patch instance with id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
if ((__is_neg(10, &(in), sizeof (in), &(e), sizeof (e), &(in->next), sizeof (in->next), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in->element), sizeof (in->element), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    return;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 99
Counter: 100
Batcher Size:49
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:44
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(in, e, in->next, e->next, v, e->next->element, l, in->element, e->next->next, e->element)))
    in->next = e->next;


CondTester, a patch instance with id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
if (!(__is_neg(10, &(in), sizeof (in), &(e), sizeof (e), &(in->next), sizeof (in->next), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in->element), sizeof (in->element), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 100
Counter: 101
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:44
--Src File: prog.c
Fragment 0:
memset(e->next, 0, sizeof (*(e->next)));
in->next = e->next;


BasicTester, a patch instance with id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
memset(e->next, 0, sizeof (*(e->next)));
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 101
Counter: 102
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:44
--Src File: prog.c
Fragment 0:
memset(in, 0, sizeof (*(in)));
in->next = e->next;


BasicTester, a patch instance with id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
memset(in, 0, sizeof (*(in)));
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 102
Counter: 103
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:44
--Src File: prog.c
Fragment 0:
memset(e, 0, sizeof (*(e)));
in->next = e->next;


BasicTester, a patch instance with id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
memset(e, 0, sizeof (*(e)));
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 103
Counter: 104
Batcher Size:53
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:38
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, e, (*l)->head, e->next, v, e->next->element, in, (*l)->size, e->next->next, e->element)))
    return;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


CondTester, a patch instance with id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
if ((__is_neg(10, &(l), sizeof (l), &(e), sizeof (e), &((*l)->head), sizeof ((*l)->head), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    return;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 104
Counter: 105
Batcher Size:54
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:38
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l, e, (*l)->head, e->next, v, e->next->element, in, (*l)->size, e->next->next, e->element)))
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }


CondTester, a patch instance with id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
if (!(__is_neg(10, &(l), sizeof (l), &(e), sizeof (e), &((*l)->head), sizeof ((*l)->head), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 105
Counter: 106
Batcher Size:55
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:38
--Src File: prog.c
Fragment 0:
memset((*l), 0, sizeof (*((*l))));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
memset((*l), 0, sizeof (*((*l))));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 106
Counter: 107
Batcher Size:56
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:38
--Src File: prog.c
Fragment 0:
memset(e->next, 0, sizeof (*(e->next)));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
memset(e->next, 0, sizeof (*(e->next)));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 107
Counter: 108
Batcher Size:57
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:38
--Src File: prog.c
Fragment 0:
memset(e, 0, sizeof (*(e)));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
memset(e, 0, sizeof (*(e)));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 108
Counter: 109
Batcher Size:58
Preprocess the following candidate with CondTester:
Priority 4995
At location prog.c:37
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, (*l)->head, v, in, in->element, in->next, (*l)->size)))
    return;
struct Entry *e = (*l)->head;


CondTester, a patch instance with id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(v), sizeof (v), &(in), sizeof (in), &(in->element), sizeof (in->element), &(in->next), sizeof (in->next), &((*l)->size), sizeof ((*l)->size))))
    return;
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 109
Counter: 110
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4995
At location prog.c:37
--Src File: prog.c
Fragment 0:
memset((*l), 0, sizeof (*((*l))));
struct Entry *e = (*l)->head;


BasicTester, a patch instance with id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
memset((*l), 0, sizeof (*((*l))));
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 110
Counter: 111
Batcher Size:60
Preprocess the following candidate with CondTester:
Priority 4994
At location prog.c:36
--Src File: prog.c
Fragment 0:
if ((__abst_hole(v, in, in->element, l, (*l)->head, in->next, (*l)->size)))
    return;
in->element = v;


CondTester, a patch instance with id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
if ((__is_neg(7, &(v), sizeof (v), &(in), sizeof (in), &(in->element), sizeof (in->element), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in->next), sizeof (in->next), &((*l)->size), sizeof ((*l)->size))))
    return;
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 111
Counter: 112
Batcher Size:61
Preprocess the following candidate with CondTester:
Priority 4994
At location prog.c:36
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(v, in, in->element, l, (*l)->head, in->next, (*l)->size)))
    in->element = v;


CondTester, a patch instance with id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
if (!(__is_neg(7, &(v), sizeof (v), &(in), sizeof (in), &(in->element), sizeof (in->element), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in->next), sizeof (in->next), &((*l)->size), sizeof ((*l)->size))))
    in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 112
Counter: 113
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4994
At location prog.c:36
--Src File: prog.c
Fragment 0:
memset(in, 0, sizeof (*(in)));
in->element = v;


BasicTester, a patch instance with id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
memset(in, 0, sizeof (*(in)));
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 113
Counter: 114
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:35
--Src File: prog.c
Fragment 0:
newNode(&in);


BasicTester, a patch instance with id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 114
Counter: 115
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:35
--Src File: prog.c
Fragment 0:
memset(in, 0, sizeof (*(in)));
newNode(&in);


BasicTester, a patch instance with id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
memset(in, 0, sizeof (*(in)));
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 115
Counter: 116
Batcher Size:65
Preprocess the following candidate with CondTester:
Priority 4993
At location prog.c:35
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(in, v, in->element, l, in->next)))
    newNode(&in);


CondTester, a patch instance with id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
if (!(__is_neg(5, &(in), sizeof (in), &(v), sizeof (v), &(in->element), sizeof (in->element), &(l), sizeof (l), &(in->next), sizeof (in->next))))
    newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 116
Counter: 117
Batcher Size:66
Preprocess the following candidate with CondTester:
Priority 4992
At location prog.c:34
--Src File: prog.c
Fragment 0:
if ((__abst_hole(v, l)))
    return;
struct Entry *in;


CondTester, a patch instance with id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    
//Patch 0:
if ((__is_neg(2, &(v), sizeof (v), &(l), sizeof (l))))
    return;
struct Entry *in;

//CodeSeg 1:
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 117
Counter: 118
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
node = (node);
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
node = (node);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 118
Counter: 119
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 66:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
printf(" %d", (l)->size);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 119
Counter: 120
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
printf("%d ", (node)->next->element);
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 67:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
printf("%d ", (node)->next->element);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 120
Counter: 121
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
printf("%d ", node->next->element);
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
printf("%d ", node->next->element);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 121
Counter: 122
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
printf(" %d", l->size);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 122
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
                return 0;
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
                return 1;
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
                return 2;
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
                break;
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==4) {
            if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
                return 20;
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==5) {
            node = (node);
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==6) {
            printf(" %d", (l)->size);
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==7) {
            printf("%d ", (node)->next->element);
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==8) {
            printf("%d ", node->next->element);
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==9) {
            printf(" %d", l->size);
            insertSort(&l, atoi(x));
            }
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    return 0;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    return 1;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 1
CondTester, Testing instance id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    return 2;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    break;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    return 20;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
BasicTester, Testing instance id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
node = (node);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 66:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
printf(" %d", (l)->size);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 67:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
printf("%d ", (node)->next->element);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
printf("%d ", node->next->element);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
printf(" %d", l->size);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 123
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
node = (node)->next;
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 70:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
node = (node)->next;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 123
Counter: 124
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
node = l->head;
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 71:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
node = l->head;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 124
Counter: 125
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
node = node->next;
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 72:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
node = node->next;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 125
Counter: 126
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if (f == ((void *)0))
    return 0;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 126
Counter: 127
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
newList(&(l));
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
newList(&(l));
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 127
Counter: 128
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
newNode(&(node));
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 75:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
newNode(&(node));
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 128
Counter: 129
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
node = (l)->head;
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 76:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
node = (l)->head;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 129
Counter: 130
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
newList(&l);
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
newList(&l);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 130
Counter: 131
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 131
Counter: 132
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
insertSort(&(l), atoi(x));
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 79:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&(l), atoi(x));
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 132
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            //prophet generated patch
            if (__get_mutant()==0) {
            node = (node)->next;
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==1) {
            node = l->head;
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==2) {
            node = node->next;
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==3) {
            if (f == ((void *)0))
                return 0;
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==4) {
            newList(&(l));
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==5) {
            newNode(&(node));
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==6) {
            node = (l)->head;
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==7) {
            newList(&l);
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==8) {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==9) {
            insertSort(&(l), atoi(x));
            insertSort(&l, atoi(x));
            }
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 70:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
node = (node)->next;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 71:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
node = l->head;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 72:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
node = node->next;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if (f == ((void *)0))
    return 0;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
newList(&(l));
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 75:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
newNode(&(node));
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 76:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
node = (l)->head;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
newList(&l);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 79:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&(l), atoi(x));
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 133
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
insertSort(&l, atoi(x));
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, atoi(x));
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 133
Counter: 134
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 81:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if (argc < 2)
    return 0;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 134
Counter: 135
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
fclose(f);
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 82:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
fclose(f);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 135
Counter: 136
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
memset(l, 0, sizeof (*(l)));
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 83:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
memset(l, 0, sizeof (*(l)));
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 136
Counter: 137
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
fclose((f));
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 84:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
fclose((f));
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 137
Counter: 138
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
insertSort(&l, system(x));


BasicTester, a patch instance with id 85:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, system(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 138
Counter: 139
Batcher Size:68
Preprocess the following candidate with CondTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l, f, node, l->head, argv, argc, l->size)))
    insertSort(&l, atoi(x));


CondTester, a patch instance with id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if (!(__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 139
Counter: 140
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
insertSort(&l, scanf(x));


BasicTester, a patch instance with id 86:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, scanf(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 140
Counter: 141
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
insertSort(&l, puts(x));


BasicTester, a patch instance with id 87:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, puts(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 141
Counter: 142
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
strrchr(&l, atoi(x));


BasicTester, a patch instance with id 88:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
strrchr(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 142
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            //prophet generated patch
            if (__get_mutant()==0) {
            insertSort(&l, atoi(x));
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==1) {
            if (argc < 2)
                return 0;
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==2) {
            fclose(f);
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==3) {
            memset(l, 0, sizeof (*(l)));
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==4) {
            fclose((f));
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==5) {
            insertSort(&l, system(x));
            }
            else if (__get_mutant()==6) {
            if (!(__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
                insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==7) {
            insertSort(&l, scanf(x));
            }
            else if (__get_mutant()==8) {
            insertSort(&l, puts(x));
            }
            else if (__get_mutant()==9) {
            strrchr(&l, atoi(x));
            }
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, atoi(x));
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 81:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if (argc < 2)
    return 0;
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 82:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
fclose(f);
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 83:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
memset(l, 0, sizeof (*(l)));
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 84:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
fclose((f));
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 85:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, system(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
if (!(__is_neg(7, &(l), sizeof (l), &(f), sizeof (f), &(node), sizeof (node), &(l->head), sizeof (l->head), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->size), sizeof (l->size))))
    insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
BasicTester, Testing instance id 86:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, scanf(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 87:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, puts(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 88:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
strrchr(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 143
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
insertSort(&l, printf(x));


BasicTester, a patch instance with id 89:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, printf(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 143
Counter: 144
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
insertSort(&l, scanf(x));


BasicTester, a patch instance with id 90:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, scanf(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 144
Counter: 145
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
insertSort(&l, scanf(x));


BasicTester, a patch instance with id 91:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, scanf(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 145
Counter: 146
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
insertSort(&l, printf(x));


BasicTester, a patch instance with id 92:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, printf(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 146
Counter: 147
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
strrchr(&l, atoi(x));


BasicTester, a patch instance with id 93:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
strrchr(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 147
Counter: 148
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
insertSort(&l, atoi(x));


BasicTester, a patch instance with id 94:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 148
Counter: 149
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
insertSort(&l, remove(x));


BasicTester, a patch instance with id 95:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, remove(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 149
Counter: 150
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
scanf(&l, atoi(x));


BasicTester, a patch instance with id 96:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
scanf(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 150
Counter: 151
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
strchr(&l, atoi(x));


BasicTester, a patch instance with id 97:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
strchr(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 151
Counter: 152
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
strchr(&l, atoi(x));


BasicTester, a patch instance with id 98:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
strchr(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 152
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            //prophet generated patch
            if (__get_mutant()==0) {
            insertSort(&l, printf(x));
            }
            else if (__get_mutant()==1) {
            insertSort(&l, scanf(x));
            }
            else if (__get_mutant()==2) {
            insertSort(&l, scanf(x));
            }
            else if (__get_mutant()==3) {
            insertSort(&l, printf(x));
            }
            else if (__get_mutant()==4) {
            strrchr(&l, atoi(x));
            }
            else if (__get_mutant()==5) {
            insertSort(&l, atoi(x));
            }
            else if (__get_mutant()==6) {
            insertSort(&l, remove(x));
            }
            else if (__get_mutant()==7) {
            scanf(&l, atoi(x));
            }
            else if (__get_mutant()==8) {
            strchr(&l, atoi(x));
            }
            else if (__get_mutant()==9) {
            strchr(&l, atoi(x));
            }
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 89:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, printf(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 90:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, scanf(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 91:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, scanf(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 92:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, printf(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 93:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
strrchr(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 94:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 95:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&l, remove(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 96:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
scanf(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 97:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
strchr(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 98:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
strchr(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 153
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
wctomb(&l, atoi(x));


BasicTester, a patch instance with id 99:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
wctomb(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 153
Counter: 154
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
printf(&l, atoi(x));


BasicTester, a patch instance with id 100:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
printf(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 154
Counter: 155
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
scanf(&l, atoi(x));


BasicTester, a patch instance with id 101:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
scanf(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 155
Counter: 156
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
scanf(&l, atoi(x));


BasicTester, a patch instance with id 102:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
scanf(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 156
Counter: 157
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
printf(&l, atoi(x));


BasicTester, a patch instance with id 103:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
printf(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 157
Counter: 158
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4991
At location prog.c:61
--Src File: prog.c
Fragment 0:
__overflow(&l, atoi(x));


BasicTester, a patch instance with id 104:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
__overflow(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 158
Counter: 159
Batcher Size:68
Preprocess the following candidate with CondTester:
Priority 4990
At location prog.c:72
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->size, node, l->head, f, argv, argc)))
    return 0;
return 0;


CondTester, a patch instance with id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 159
Counter: 160
Batcher Size:69
Preprocess the following candidate with CondTester:
Priority 4990
At location prog.c:72
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->size, node, l->head, f, argv, argc)))
    return 1;
return 0;


CondTester, a patch instance with id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 160
Counter: 161
Batcher Size:70
Preprocess the following candidate with CondTester:
Priority 4990
At location prog.c:72
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->size, node, l->head, f, argv, argc)))
    return 2;
return 0;


CondTester, a patch instance with id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 161
Counter: 162
Batcher Size:71
Preprocess the following candidate with CondTester:
Priority 4990
At location prog.c:72
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->size, node, l->head, f, argv, argc)))
    return 20;
return 0;


CondTester, a patch instance with id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 162
Counter: 163
Batcher Size:72
Preprocess the following candidate with CondTester:
Priority 4990
At location prog.c:72
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l, l->size, node, l->head, f, argv, argc)))
    return 0;


CondTester, a patch instance with id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if (!(__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 163
Counter: 164
Batcher Size:73
Preprocess the following candidate with CondTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->size, node, l->head, f, argv, argc)))
    return 0;
printf(" %d", l->size);


CondTester, a patch instance with id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 164
Counter: 165
Batcher Size:74
Preprocess the following candidate with CondTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->size, node, l->head, f, argv, argc)))
    return 1;
printf(" %d", l->size);


CondTester, a patch instance with id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 165
Counter: 166
Batcher Size:75
Preprocess the following candidate with CondTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->size, node, l->head, f, argv, argc)))
    return 2;
printf(" %d", l->size);


CondTester, a patch instance with id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 166
Counter: 167
Batcher Size:76
Preprocess the following candidate with CondTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->size, node, l->head, f, argv, argc)))
    return 20;
printf(" %d", l->size);


CondTester, a patch instance with id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 167
Counter: 168
Batcher Size:77
Preprocess the following candidate with BasicTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
strchr(" %d", l->size);


BasicTester, a patch instance with id 105:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
strchr(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 168
Counter: 169
Batcher Size:78
Preprocess the following candidate with BasicTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
insertSort(" %d", l->size);


BasicTester, a patch instance with id 106:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
insertSort(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 169
Counter: 170
Batcher Size:79
Preprocess the following candidate with BasicTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
memset(l, 0, sizeof (*(l)));
printf(" %d", l->size);


BasicTester, a patch instance with id 107:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
memset(l, 0, sizeof (*(l)));
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 170
Counter: 171
Batcher Size:80
Preprocess the following candidate with CondTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l, l->size, node, l->head, f, argv, argc)))
    printf(" %d", l->size);


CondTester, a patch instance with id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if (!(__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 171
Counter: 172
Batcher Size:81
Preprocess the following candidate with BasicTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
strrchr(" %d", l->size);


BasicTester, a patch instance with id 108:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
strrchr(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 172
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    printf((" %##uni*##"), l->size);
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    printf(" %d", l->size);
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 1;
    printf(" %d", l->size);
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 2;
    printf(" %d", l->size);
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 20;
    printf(" %d", l->size);
    }
    else if (__get_mutant()==5) {
    strchr(" %d", l->size);
    }
    else if (__get_mutant()==6) {
    insertSort(" %d", l->size);
    }
    else if (__get_mutant()==7) {
    memset(l, 0, sizeof (*(l)));
    printf(" %d", l->size);
    }
    else if (__get_mutant()==8) {
    if (!(__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        printf(" %d", l->size);
    }
    else if (__get_mutant()==9) {
    strrchr(" %d", l->size);
    }
    return 0;


}

Merged code building succ, going to invoke tester!
StringConstTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf((" %##uni*##"), l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 105:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
strchr(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 106:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
insertSort(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 107:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
memset(l, 0, sizeof (*(l)));
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if (!(__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 108:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
strrchr(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
Counter: 173
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
strrchr(" %d", l->size);


BasicTester, a patch instance with id 109:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
strrchr(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 173
Counter: 174
Batcher Size:73
Preprocess the following candidate with BasicTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
scanf(" %d", l->size);


BasicTester, a patch instance with id 110:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
scanf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 174
Counter: 175
Batcher Size:74
Preprocess the following candidate with BasicTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
wctomb(" %d", l->size);


BasicTester, a patch instance with id 111:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
wctomb(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 175
Counter: 176
Batcher Size:75
Preprocess the following candidate with BasicTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
strchr(" %d", l->size);


BasicTester, a patch instance with id 112:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
strchr(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 176
Counter: 177
Batcher Size:76
Preprocess the following candidate with BasicTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
scanf(" %d", l->size);


BasicTester, a patch instance with id 113:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
scanf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 177
Counter: 178
Batcher Size:77
Preprocess the following candidate with BasicTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
__overflow(" %d", l->size);


BasicTester, a patch instance with id 114:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
__overflow(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 178
Counter: 179
Batcher Size:78
Preprocess the following candidate with BasicTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);


BasicTester, a patch instance with id 115:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 179
Counter: 180
Batcher Size:79
Preprocess the following candidate with BasicTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
insertSort(" %d", l->size);


BasicTester, a patch instance with id 116:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
insertSort(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 180
Counter: 181
Batcher Size:80
Preprocess the following candidate with BasicTester:
Priority 4989
At location prog.c:71
--Src File: prog.c
Fragment 0:
scanf(" %d", l->size);


BasicTester, a patch instance with id 117:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
scanf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 181
Counter: 182
Batcher Size:81
Preprocess the following candidate with CondTester:
Priority 4988
At location prog.c:67
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l, node, node->next, l->head, node->next->element, f, l->size, argv, argc, node->next->next, node->element)))
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }


CondTester, a patch instance with id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if (!(__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 182
Counter: 183
Batcher Size:82
Preprocess the following candidate with BasicTester:
Priority 4988
At location prog.c:67
--Src File: prog.c
Fragment 0:
memset(node->next, 0, sizeof (*(node->next)));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 118:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
memset(node->next, 0, sizeof (*(node->next)));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 183
Counter: 184
Batcher Size:83
Preprocess the following candidate with CondTester:
Priority 4988
At location prog.c:67
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, node, node->next, l->head, node->next->element, f, l->size, argv, argc, node->next->next, node->element)))
    return 20;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


CondTester, a patch instance with id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 20;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 184
Counter: 185
Batcher Size:84
Preprocess the following candidate with CondTester:
Priority 4988
At location prog.c:67
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, node, node->next, l->head, node->next->element, f, l->size, argv, argc, node->next->next, node->element)))
    return 2;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


CondTester, a patch instance with id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 2;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 185
Counter: 186
Batcher Size:85
Preprocess the following candidate with CondTester:
Priority 4988
At location prog.c:67
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, node, node->next, l->head, node->next->element, f, l->size, argv, argc, node->next->next, node->element)))
    return 1;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


CondTester, a patch instance with id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 1;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 186
Counter: 187
Batcher Size:86
Preprocess the following candidate with CondTester:
Priority 4988
At location prog.c:67
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, node, node->next, l->head, node->next->element, f, l->size, argv, argc, node->next->next, node->element)))
    return 0;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


CondTester, a patch instance with id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 0;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 187
Counter: 188
Batcher Size:87
Preprocess the following candidate with BasicTester:
Priority 4988
At location prog.c:67
--Src File: prog.c
Fragment 0:
memset(node, 0, sizeof (*(node)));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 119:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
memset(node, 0, sizeof (*(node)));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 188
Counter: 189
Batcher Size:88
Preprocess the following candidate with BasicTester:
Priority 4988
At location prog.c:67
--Src File: prog.c
Fragment 0:
memset(l, 0, sizeof (*(l)));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 120:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
memset(l, 0, sizeof (*(l)));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 189
Counter: 190
Batcher Size:89
Preprocess the following candidate with CondTester:
Priority 4987
At location prog.c:66
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, node, l->head, node->next, f, node->next->element, l->size, argv, argc, node->next->next, node->element)))
    return 0;
node = l->head;


CondTester, a patch instance with id 66:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 0;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 190
Counter: 191
Batcher Size:90
Preprocess the following candidate with CondTester:
Priority 4987
At location prog.c:66
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, node, l->head, node->next, f, node->next->element, l->size, argv, argc, node->next->next, node->element)))
    return 2;
node = l->head;


CondTester, a patch instance with id 67:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 2;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 191
Counter: 192
Batcher Size:91
Preprocess the following candidate with CondTester:
Priority 4987
At location prog.c:66
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, node, l->head, node->next, f, node->next->element, l->size, argv, argc, node->next->next, node->element)))
    return 20;
node = l->head;


CondTester, a patch instance with id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 20;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 192
Counter: 193
Batcher Size:92
Preprocess the following candidate with CondTester:
Priority 4987
At location prog.c:66
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, node, l->head, node->next, f, node->next->element, l->size, argv, argc, node->next->next, node->element)))
    return 1;
node = l->head;


CondTester, a patch instance with id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 1;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 193
Counter: 194
Batcher Size:93
Preprocess the following candidate with CondTester:
Priority 4987
At location prog.c:66
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l, node, l->head, node->next, f, node->next->element, l->size, argv, argc, node->next->next, node->element)))
    node = l->head;


CondTester, a patch instance with id 70:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if (!(__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 194
Counter: 195
Batcher Size:94
Preprocess the following candidate with BasicTester:
Priority 4987
At location prog.c:66
--Src File: prog.c
Fragment 0:
memset(node, 0, sizeof (*(node)));
node = l->head;


BasicTester, a patch instance with id 121:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
memset(node, 0, sizeof (*(node)));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 195
Counter: 196
Batcher Size:95
Preprocess the following candidate with BasicTester:
Priority 4987
At location prog.c:66
--Src File: prog.c
Fragment 0:
memset(l, 0, sizeof (*(l)));
node = l->head;


BasicTester, a patch instance with id 122:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
memset(l, 0, sizeof (*(l)));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 196
Counter: 197
Batcher Size:96
Preprocess the following candidate with CondTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, argv, argc)))
    return 2;
fclose(f);


CondTester, a patch instance with id 71:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 197
Counter: 198
Batcher Size:97
Preprocess the following candidate with CondTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, argv, argc)))
    return 20;
fclose(f);


CondTester, a patch instance with id 72:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 198
Counter: 199
Batcher Size:98
Preprocess the following candidate with CondTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, argv, argc)))
    return 0;
fclose(f);


CondTester, a patch instance with id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 199
Counter: 200
Batcher Size:99
Preprocess the following candidate with CondTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, node, argv, argc)))
    return 1;
fclose(f);


CondTester, a patch instance with id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 200
Counter: 201
Batcher Size:100
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
feof(f);


BasicTester, a patch instance with id 123:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
feof(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 201
Counter: 202
Batcher Size:101
Preprocess the following candidate with CondTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(f, l, node, argv, argc)))
    fclose(f);


CondTester, a patch instance with id 75:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if (!(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 202
Counter: 203
Batcher Size:102
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
ferror(f);


BasicTester, a patch instance with id 124:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
ferror(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 203
Counter: 204
Batcher Size:103
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
_IO_ftrylockfile(f);


BasicTester, a patch instance with id 125:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_ftrylockfile(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 204
Counter: 205
Batcher Size:104
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
getc(f);


BasicTester, a patch instance with id 126:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
getc(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 205
Counter: 206
Batcher Size:105
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
rewind(f);


BasicTester, a patch instance with id 127:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
rewind(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 206
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 2;
    fclose(f);
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 20;
    fclose(f);
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    fclose(f);
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 1;
    fclose(f);
    }
    else if (__get_mutant()==4) {
    feof(f);
    }
    else if (__get_mutant()==5) {
    if (!(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        fclose(f);
    }
    else if (__get_mutant()==6) {
    ferror(f);
    }
    else if (__get_mutant()==7) {
    _IO_ftrylockfile(f);
    }
    else if (__get_mutant()==8) {
    getc(f);
    }
    else if (__get_mutant()==9) {
    rewind(f);
    }

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 71:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 72:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 123:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
feof(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 75:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if (!(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(node), sizeof (node), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 124:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
ferror(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 125:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_ftrylockfile(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 126:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
getc(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 127:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
rewind(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 207
Batcher Size:96
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
clearerr(f);


BasicTester, a patch instance with id 128:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
clearerr(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 207
Counter: 208
Batcher Size:97
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
ftell(f);


BasicTester, a patch instance with id 129:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
ftell(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 208
Counter: 209
Batcher Size:98
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
_IO_free_backup_area(f);


BasicTester, a patch instance with id 130:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_free_backup_area(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 209
Counter: 210
Batcher Size:99
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
fflush(f);


BasicTester, a patch instance with id 131:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
fflush(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 210
Counter: 211
Batcher Size:100
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
fgetc(f);


BasicTester, a patch instance with id 132:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
fgetc(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 211
Counter: 212
Batcher Size:101
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
_IO_ferror(f);


BasicTester, a patch instance with id 133:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_ferror(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 212
Counter: 213
Batcher Size:102
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
_IO_flockfile(f);


BasicTester, a patch instance with id 134:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_flockfile(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 213
Counter: 214
Batcher Size:103
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
_IO_funlockfile(f);


BasicTester, a patch instance with id 135:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_funlockfile(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 214
Counter: 215
Batcher Size:104
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
_IO_peekc_locked(f);


BasicTester, a patch instance with id 136:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_peekc_locked(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 215
Counter: 216
Batcher Size:105
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
__underflow(f);


BasicTester, a patch instance with id 137:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
__underflow(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 216
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    clearerr(f);
    }
    else if (__get_mutant()==1) {
    ftell(f);
    }
    else if (__get_mutant()==2) {
    _IO_free_backup_area(f);
    }
    else if (__get_mutant()==3) {
    fflush(f);
    }
    else if (__get_mutant()==4) {
    fgetc(f);
    }
    else if (__get_mutant()==5) {
    _IO_ferror(f);
    }
    else if (__get_mutant()==6) {
    _IO_flockfile(f);
    }
    else if (__get_mutant()==7) {
    _IO_funlockfile(f);
    }
    else if (__get_mutant()==8) {
    _IO_peekc_locked(f);
    }
    else if (__get_mutant()==9) {
    __underflow(f);
    }

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 128:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
clearerr(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 129:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
ftell(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 130:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_free_backup_area(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 131:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
fflush(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 132:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
fgetc(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 133:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_ferror(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 134:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_flockfile(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 135:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_funlockfile(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 136:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_peekc_locked(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 137:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
__underflow(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 217
Batcher Size:96
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
_IO_getc(f);


BasicTester, a patch instance with id 138:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_getc(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 217
Counter: 218
Batcher Size:97
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
_IO_feof(f);


BasicTester, a patch instance with id 139:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_feof(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 218
Counter: 219
Batcher Size:98
Preprocess the following candidate with BasicTester:
Priority 4986
At location prog.c:64
--Src File: prog.c
Fragment 0:
__uflow(f);


BasicTester, a patch instance with id 140:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
__uflow(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 219
Counter: 220
Batcher Size:99
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
printf("%d ", node->next->element);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 141:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
printf("%d ", node->next->element);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 220
Counter: 221
Batcher Size:100
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 142:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if (argc < 2)
    return 0;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 221
Counter: 222
Batcher Size:101
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
node = (l)->head;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 143:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
node = (l)->head;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 222
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((x[0] != '"') && !(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc)))) {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==1) {
        if ((x[0] != '"') || (__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc)))) {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
            return 0;
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
            return 1;
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
            return 20;
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==5) {
        if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
            break;
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==6) {
        if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
            return 2;
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==7) {
        printf("%d ", node->next->element);
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==8) {
        if (argc < 2)
            return 0;
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==9) {
        node = (l)->head;
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] != '"') && !(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc)))) {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
CondTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] != '"') || (__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc)))) {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
CondTester, Testing instance id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
    return 0;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
CondTester, Testing instance id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
    return 1;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
CondTester, Testing instance id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
    return 20;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
CondTester, Testing instance id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
    break;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
CondTester, Testing instance id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
    return 2;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
BasicTester, Testing instance id 141:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
printf("%d ", node->next->element);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 142:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if (argc < 2)
    return 0;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 143:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
node = (l)->head;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Going to sync the batch tester, clear all existing tasks!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
        return;
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==1) {
    (*l)->head->next = (*(l))->head;
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==2) {
    newNode(&((*l)->head));
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==3) {
    newNode(&((*(l))->head));
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==4) {
    *l = malloc(sizeof(struct List));
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==5) {
    (*l)->head->next = (*l)->head;
    *l = malloc(sizeof(struct List));
    }
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*(l))->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
newNode(&((*l)->head));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
newNode(&((*(l))->head));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
*l = malloc(sizeof(struct List));
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
(*l)->head->next = (*l)->head;
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(1, &(n), sizeof (n))))
        return;
    *n = malloc(sizeof(struct Entry));
    }
    else if (__get_mutant()==1) {
    (*n)->next = ((void *)0);
    *n = malloc(sizeof(struct Entry));
    }
    else if (__get_mutant()==2) {
    *n = malloc(sizeof(struct Entry));
    *n = malloc(sizeof(struct Entry));
    }
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
if ((__is_neg(1, &(n), sizeof (n))))
    return;
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Iteration 3
Branch 0: 1
Branch 1: 0
Branch 2: 0
Iteration 4
Branch 0: 1
Branch 1: 0
Branch 2: 1
Iteration 5
Branch 0: 1
Branch 1: 1
BasicTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
*n = malloc(sizeof(struct Entry));
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(2, &(v), sizeof (v), &(l), sizeof (l))))
        return;
    struct Entry *in;
    }
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building failed! Going to build saperately!
CondTester, Testing instance id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    
//Patch 0:
if ((__is_neg(2, &(v), sizeof (v), &(l), sizeof (l))))
    return;
struct Entry *in;

//CodeSeg 1:
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    //prophet generated patch
    if (__get_mutant()==0) {
    newNode(&in);
    }
    else if (__get_mutant()==1) {
    memset(in, 0, sizeof (*(in)));
    newNode(&in);
    }
    else if (__get_mutant()==2) {
    if (!(__is_neg(5, &(in), sizeof (in), &(v), sizeof (v), &(in->element), sizeof (in->element), &(l), sizeof (l), &(in->next), sizeof (in->next))))
        newNode(&in);
    }
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
memset(in, 0, sizeof (*(in)));
newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
if (!(__is_neg(5, &(in), sizeof (in), &(v), sizeof (v), &(in->element), sizeof (in->element), &(l), sizeof (l), &(in->next), sizeof (in->next))))
    newNode(&in);

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(7, &(v), sizeof (v), &(in), sizeof (in), &(in->element), sizeof (in->element), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in->next), sizeof (in->next), &((*l)->size), sizeof ((*l)->size))))
        return;
    in->element = v;
    }
    else if (__get_mutant()==1) {
    if (!(__is_neg(7, &(v), sizeof (v), &(in), sizeof (in), &(in->element), sizeof (in->element), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in->next), sizeof (in->next), &((*l)->size), sizeof ((*l)->size))))
        in->element = v;
    }
    else if (__get_mutant()==2) {
    memset(in, 0, sizeof (*(in)));
    in->element = v;
    }
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
if ((__is_neg(7, &(v), sizeof (v), &(in), sizeof (in), &(in->element), sizeof (in->element), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in->next), sizeof (in->next), &((*l)->size), sizeof ((*l)->size))))
    return;
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
CondTester, Testing instance id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
if (!(__is_neg(7, &(v), sizeof (v), &(in), sizeof (in), &(in->element), sizeof (in->element), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in->next), sizeof (in->next), &((*l)->size), sizeof ((*l)->size))))
    in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
BasicTester, Testing instance id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
memset(in, 0, sizeof (*(in)));
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(7, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(v), sizeof (v), &(in), sizeof (in), &(in->element), sizeof (in->element), &(in->next), sizeof (in->next), &((*l)->size), sizeof ((*l)->size))))
        return;
    struct Entry *e = (*l)->head;
    }
    else if (__get_mutant()==1) {
    memset((*l), 0, sizeof (*((*l))));
    struct Entry *e = (*l)->head;
    }
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building failed! Going to build saperately!
CondTester, Testing instance id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(v), sizeof (v), &(in), sizeof (in), &(in->element), sizeof (in->element), &(in->next), sizeof (in->next), &((*l)->size), sizeof ((*l)->size))))
    return;
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
BasicTester, Testing instance id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
memset((*l), 0, sizeof (*((*l))));
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(10, &(l), sizeof (l), &(e), sizeof (e), &((*l)->head), sizeof ((*l)->head), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
        return;
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==1) {
    if (!(__is_neg(10, &(l), sizeof (l), &(e), sizeof (e), &((*l)->head), sizeof ((*l)->head), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
        while (e->next != (*l)->head)
            {
                if (e->next->element < v)
                    e = e->next;
                else
                    break;
            }
    }
    else if (__get_mutant()==2) {
    memset((*l), 0, sizeof (*((*l))));
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==3) {
    memset(e->next, 0, sizeof (*(e->next)));
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==4) {
    memset(e, 0, sizeof (*(e)));
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
if ((__is_neg(10, &(l), sizeof (l), &(e), sizeof (e), &((*l)->head), sizeof ((*l)->head), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    return;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
CondTester, Testing instance id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
if (!(__is_neg(10, &(l), sizeof (l), &(e), sizeof (e), &((*l)->head), sizeof ((*l)->head), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
BasicTester, Testing instance id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
memset((*l), 0, sizeof (*((*l))));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
memset(e->next, 0, sizeof (*(e->next)));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
memset(e, 0, sizeof (*(e)));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((e->next->element < v) && !(__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==1) {
        if ((e->next->element < v) || (__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
            return;
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
            break;
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
if ((e->next->element < v) && !(__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
if ((e->next->element < v) || (__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
if ((__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    return;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
if ((__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    break;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(10, &(in), sizeof (in), &(e), sizeof (e), &(in->next), sizeof (in->next), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in->element), sizeof (in->element), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
        return;
    in->next = e->next;
    }
    else if (__get_mutant()==1) {
    if (!(__is_neg(10, &(in), sizeof (in), &(e), sizeof (e), &(in->next), sizeof (in->next), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in->element), sizeof (in->element), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
        in->next = e->next;
    }
    else if (__get_mutant()==2) {
    memset(e->next, 0, sizeof (*(e->next)));
    in->next = e->next;
    }
    else if (__get_mutant()==3) {
    memset(in, 0, sizeof (*(in)));
    in->next = e->next;
    }
    else if (__get_mutant()==4) {
    memset(e, 0, sizeof (*(e)));
    in->next = e->next;
    }
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
if ((__is_neg(10, &(in), sizeof (in), &(e), sizeof (e), &(in->next), sizeof (in->next), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in->element), sizeof (in->element), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    return;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
CondTester, Testing instance id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
if (!(__is_neg(10, &(in), sizeof (in), &(e), sizeof (e), &(in->next), sizeof (in->next), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in->element), sizeof (in->element), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
BasicTester, Testing instance id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
memset(e->next, 0, sizeof (*(e->next)));
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
memset(in, 0, sizeof (*(in)));
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
memset(e, 0, sizeof (*(e)));
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    //prophet generated patch
    if (__get_mutant()==0) {
    memset(e, 0, sizeof (*(e)));
    e->next = in;
    }
    else if (__get_mutant()==1) {
    memset(e->next, 0, sizeof (*(e->next)));
    e->next = in;
    }
    else if (__get_mutant()==2) {
    memset(in, 0, sizeof (*(in)));
    e->next = in;
    }
    else if (__get_mutant()==3) {
    if (!(__is_neg(10, &(in), sizeof (in), &(e), sizeof (e), &(e->next), sizeof (e->next), &(in->next), sizeof (in->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in->element), sizeof (in->element), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
        e->next = in;
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(10, &(in), sizeof (in), &(e), sizeof (e), &(e->next), sizeof (e->next), &(in->next), sizeof (in->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in->element), sizeof (in->element), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
        return;
    e->next = in;
    }
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
memset(e, 0, sizeof (*(e)));
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
memset(e->next, 0, sizeof (*(e->next)));
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
memset(in, 0, sizeof (*(in)));
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
if (!(__is_neg(10, &(in), sizeof (in), &(e), sizeof (e), &(e->next), sizeof (e->next), &(in->next), sizeof (in->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in->element), sizeof (in->element), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
CondTester, Testing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
if ((__is_neg(10, &(in), sizeof (in), &(e), sizeof (e), &(e->next), sizeof (e->next), &(in->next), sizeof (in->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in->element), sizeof (in->element), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    return;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 1;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 2;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==5) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 20;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==6) {
    if (argc < 2)
        return 0;
    if (argc < 2)
        return 0;
    }
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 1;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 2;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 20;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            //prophet generated patch
            if (__get_mutant()==0) {
            wctomb(&l, atoi(x));
            }
            else if (__get_mutant()==1) {
            printf(&l, atoi(x));
            }
            else if (__get_mutant()==2) {
            scanf(&l, atoi(x));
            }
            else if (__get_mutant()==3) {
            scanf(&l, atoi(x));
            }
            else if (__get_mutant()==4) {
            printf(&l, atoi(x));
            }
            else if (__get_mutant()==5) {
            __overflow(&l, atoi(x));
            }
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 99:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
wctomb(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 100:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
printf(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 101:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
scanf(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 102:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
scanf(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 103:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
printf(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 104:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
__overflow(&l, atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    _IO_getc(f);
    }
    else if (__get_mutant()==1) {
    _IO_feof(f);
    }
    else if (__get_mutant()==2) {
    __uflow(f);
    }

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 138:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_getc(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 139:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
_IO_feof(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 140:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
__uflow(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
        return 0;
    node = l->head;
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
        return 2;
    node = l->head;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
        return 20;
    node = l->head;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
        return 1;
    node = l->head;
    }
    else if (__get_mutant()==4) {
    if (!(__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
        node = l->head;
    }
    else if (__get_mutant()==5) {
    memset(node, 0, sizeof (*(node)));
    node = l->head;
    }
    else if (__get_mutant()==6) {
    memset(l, 0, sizeof (*(l)));
    node = l->head;
    }
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 66:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 0;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 67:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 2;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 20;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 1;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 70:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if (!(__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(l->head), sizeof (l->head), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->next->element), sizeof (node->next->element), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
BasicTester, Testing instance id 121:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
memset(node, 0, sizeof (*(node)));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 122:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
memset(l, 0, sizeof (*(l)));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    //prophet generated patch
    if (__get_mutant()==0) {
    if (!(__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
        while (node->next != l->head)
            {
                printf("%d ", node->next->element);
                node = node->next;
            }
    }
    else if (__get_mutant()==1) {
    memset(node->next, 0, sizeof (*(node->next)));
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
        return 20;
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
        return 2;
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
        return 1;
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==5) {
    if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
        return 0;
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==6) {
    memset(node, 0, sizeof (*(node)));
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==7) {
    memset(l, 0, sizeof (*(l)));
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if (!(__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 118:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
memset(node->next, 0, sizeof (*(node->next)));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 20;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 2;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 1;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(node), sizeof (node), &(node->next), sizeof (node->next), &(l->head), sizeof (l->head), &(node->next->element), sizeof (node->next->element), &(f), sizeof (f), &(l->size), sizeof (l->size), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 0;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 119:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
memset(node, 0, sizeof (*(node)));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 120:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
memset(l, 0, sizeof (*(l)));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
            return 0;
        node = node->next;
        }
        else if (__get_mutant()==1) {
        if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
            return 1;
        node = node->next;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
            return 2;
        node = node->next;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
            break;
        node = node->next;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
            return 20;
        node = node->next;
        }
        else if (__get_mutant()==5) {
        if (!(__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
            node = node->next;
        }
        else if (__get_mutant()==6) {
        memset(node->next, 0, sizeof (*(node->next)));
        node = node->next;
        }
        else if (__get_mutant()==7) {
        memset(node, 0, sizeof (*(node)));
        node = node->next;
        }
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 0;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 1;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 2;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    break;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if ((__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    return 20;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if (!(__is_neg(9, &(node), sizeof (node), &(node->next), sizeof (node->next), &(node->next->element), sizeof (node->next->element), &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->next->next), sizeof (node->next->next), &(node->element), sizeof (node->element))))
    node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 2
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 3
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 4
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 5
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 6
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 7
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 8
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Iteration 9
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 1
Branch 10: 0
BasicTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
memset(node->next, 0, sizeof (*(node->next)));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
memset(node, 0, sizeof (*(node)));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    strrchr(" %d", l->size);
    }
    else if (__get_mutant()==1) {
    scanf(" %d", l->size);
    }
    else if (__get_mutant()==2) {
    wctomb(" %d", l->size);
    }
    else if (__get_mutant()==3) {
    strchr(" %d", l->size);
    }
    else if (__get_mutant()==4) {
    scanf(" %d", l->size);
    }
    else if (__get_mutant()==5) {
    __overflow(" %d", l->size);
    }
    else if (__get_mutant()==6) {
    printf(" %d", l->size);
    }
    else if (__get_mutant()==7) {
    insertSort(" %d", l->size);
    }
    else if (__get_mutant()==8) {
    scanf(" %d", l->size);
    }
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 109:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
strrchr(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 110:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
scanf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 111:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
wctomb(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 112:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
strchr(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 113:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
scanf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 114:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
__overflow(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 115:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 116:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
insertSort(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 117:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
scanf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    return 0;
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 1;
    return 0;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 2;
    return 0;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 20;
    return 0;
    }
    else if (__get_mutant()==4) {
    if (!(__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
return 0;

//CodeSeg 1:


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
return 0;

//CodeSeg 1:


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
return 0;

//CodeSeg 1:


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
return 0;

//CodeSeg 1:


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if (!(__is_neg(7, &(l), sizeof (l), &(l->size), sizeof (l->size), &(node), sizeof (node), &(l->head), sizeof (l->head), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Counter: 223
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
node = node->next;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 144:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
node = node->next;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 223
Counter: 224
Batcher Size:1
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 145:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
printf(" %d", l->size);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 224
Counter: 225
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
printf("%d ", (node)->next->element);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 146:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
printf("%d ", (node)->next->element);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 225
Counter: 226
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 147:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
printf(" %d", (l)->size);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 226
Counter: 227
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
node = (node);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 148:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
node = (node);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 227
Counter: 228
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
node = (node)->next;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 149:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
node = (node)->next;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 228
Counter: 229
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
node = l->head;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 150:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
node = l->head;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 229
Counter: 230
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 151:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if (f == ((void *)0))
    return 0;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 230
Counter: 231
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
insertSort(&l, atoi(x));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 152:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
insertSort(&l, atoi(x));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 231
Counter: 232
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
newList(&l);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 153:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
newList(&l);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 232
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        //prophet generated patch
        if (__get_mutant()==0) {
        node = node->next;
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==1) {
        printf(" %d", l->size);
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==2) {
        printf("%d ", (node)->next->element);
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==3) {
        printf(" %d", (l)->size);
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==4) {
        node = (node);
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==5) {
        node = (node)->next;
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==6) {
        node = l->head;
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==7) {
        if (f == ((void *)0))
            return 0;
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==8) {
        insertSort(&l, atoi(x));
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==9) {
        newList(&l);
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 144:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
node = node->next;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 145:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
printf(" %d", l->size);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 146:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
printf("%d ", (node)->next->element);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 147:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
printf(" %d", (l)->size);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 148:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
node = (node);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 149:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
node = (node)->next;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 150:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
node = l->head;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 151:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if (f == ((void *)0))
    return 0;
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 152:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
insertSort(&l, atoi(x));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 153:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
newList(&l);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 233
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
newNode(&(node));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 154:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
newNode(&(node));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 233
Counter: 234
Batcher Size:1
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
newList(&(l));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 155:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
newList(&(l));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 234
Counter: 235
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 156:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 235
Counter: 236
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
insertSort(&(l), atoi(x));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 157:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
insertSort(&(l), atoi(x));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 236
Counter: 237
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
fclose((f));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 158:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
fclose((f));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 237
Counter: 238
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
fclose(f);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 159:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
fclose(f);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 238
Counter: 239
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(f, l, argv, node, argc)) && (x[0] != '"')) {
    insertSort(&l, atoi(x));
}


CondTester, a patch instance with id 76:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if (!(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))) && (x[0] != '"')) {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 239
Counter: 240
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
memset(l, 0, sizeof (*(l)));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}


BasicTester, a patch instance with id 160:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
memset(l, 0, sizeof (*(l)));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 240
Counter: 241
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 4985
At location prog.c:59
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(f, l, argv, node, argc)))
    if (x[0] != '"') {
        insertSort(&l, atoi(x));
    }


CondTester, a patch instance with id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if (!(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
    if (x[0] != '"') {
        insertSort(&l, atoi(x));
    }

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 241
Counter: 242
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 4984
At location prog.c:30
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, (*n)->next, (*n)->element)))
    return;
(*n)->next = ((void *)0);


CondTester, a patch instance with id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    
//Patch 0:
if ((__is_neg(3, &(n), sizeof (n), &((*n)->next), sizeof ((*n)->next), &((*n)->element), sizeof ((*n)->element))))
    return;
(*n)->next = ((void *)0);

//CodeSeg 1:
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 242
Counter: 243
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 4984
At location prog.c:30
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(n, (*n)->next, (*n)->element)))
    (*n)->next = ((void *)0);


CondTester, a patch instance with id 79:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    
//Patch 0:
if (!(__is_neg(3, &(n), sizeof (n), &((*n)->next), sizeof ((*n)->next), &((*n)->element), sizeof ((*n)->element))))
    (*n)->next = ((void *)0);

//CodeSeg 1:
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 243
Counter: 244
Batcher Size:11
Preprocess the following candidate with BasicTester:
Priority 4984
At location prog.c:30
--Src File: prog.c
Fragment 0:
memset((*n), 0, sizeof (*((*n))));
(*n)->next = ((void *)0);


BasicTester, a patch instance with id 161:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    
//Patch 0:
memset((*n), 0, sizeof (*((*n))));
(*n)->next = ((void *)0);

//CodeSeg 1:
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 244
Counter: 245
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 4983
At location prog.c:28
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(n)))
    *n = malloc(sizeof(struct Entry));


CondTester, a patch instance with id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
if (!(__is_neg(1, &(n), sizeof (n))))
    *n = malloc(sizeof(struct Entry));

//CodeSeg 1:
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 245
Counter: 246
Batcher Size:13
Preprocess the following candidate with BasicTester:
Priority 4983
At location prog.c:28
--Src File: prog.c
Fragment 0:
*n = malloc(sizeof(struct Entry));


BasicTester, a patch instance with id 162:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 246
Counter: 247
Batcher Size:14
Preprocess the following candidate with CondTester:
Priority 4982
At location prog.c:58
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, argv, argc, node)))
    return 1;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


CondTester, a patch instance with id 81:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
    return 1;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 247
Counter: 248
Batcher Size:15
Preprocess the following candidate with CondTester:
Priority 4982
At location prog.c:58
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, argv, argc, node)))
    return 20;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


CondTester, a patch instance with id 82:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
    return 20;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 248
Counter: 249
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 4982
At location prog.c:58
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, argv, argc, node)))
    return 2;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


CondTester, a patch instance with id 83:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
    return 2;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 249
Counter: 250
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 4982
At location prog.c:58
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, argv, argc, node)))
    return 0;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


CondTester, a patch instance with id 84:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
    return 0;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 250
Counter: 251
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 4982
At location prog.c:58
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(f, l, argv, argc, node)))
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }


CondTester, a patch instance with id 85:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if (!(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 251
Counter: 252
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority 4982
At location prog.c:58
--Src File: prog.c
Fragment 0:
memset(l, 0, sizeof (*(l)));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 163:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
memset(l, 0, sizeof (*(l)));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 252
Counter: 253
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 4981
At location prog.c:57
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, argv, argc)))
    return 2;
struct Entry *node;


CondTester, a patch instance with id 86:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if ((__is_neg(4, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 253
Counter: 254
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 4981
At location prog.c:57
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, argv, argc)))
    return 20;
struct Entry *node;


CondTester, a patch instance with id 87:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if ((__is_neg(4, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 254
Counter: 255
Batcher Size:22
Preprocess the following candidate with CondTester:
Priority 4981
At location prog.c:57
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, argv, argc)))
    return 0;
struct Entry *node;


CondTester, a patch instance with id 88:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if ((__is_neg(4, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 255
Counter: 256
Batcher Size:23
Preprocess the following candidate with CondTester:
Priority 4981
At location prog.c:57
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, l, argv, argc)))
    return 1;
struct Entry *node;


CondTester, a patch instance with id 89:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if ((__is_neg(4, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 256
Counter: 257
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 4980
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, f, argv, argc, l->head, l->size)))
    return 20;
char x[20];


CondTester, a patch instance with id 90:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 20;
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 257
CondTester, Testing instance id 90:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 20;
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Counter: 258
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 4980
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, f, argv, argc, l->head, l->size)))
    return 1;
char x[20];


CondTester, a patch instance with id 91:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 1;
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 258
CondTester, Testing instance id 91:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 1;
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Counter: 259
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 4980
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, f, argv, argc, l->head, l->size)))
    return 2;
char x[20];


CondTester, a patch instance with id 92:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 2;
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 259
CondTester, Testing instance id 92:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 2;
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Counter: 260
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 4980
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, f, argv, argc, l->head, l->size)))
    return 0;
char x[20];


CondTester, a patch instance with id 93:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 0;
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 260
CondTester, Testing instance id 93:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 0;
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Counter: 261
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 4979
At location prog.c:24
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l, (*l)->head->next, (*l)->head, (*l)->head->element, (*l)->size)))
    return;


CondTester, a patch instance with id 94:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
if (!(__is_neg(5, &(l), sizeof (l), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head), sizeof ((*l)->head), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 261
Counter: 262
Batcher Size:25
Preprocess the following candidate with CondTester:
Priority 4979
At location prog.c:24
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, (*l)->head->next, (*l)->head, (*l)->head->element, (*l)->size)))
    return;
return;


CondTester, a patch instance with id 95:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head), sizeof ((*l)->head), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;
return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 262
Counter: 263
Batcher Size:26
Preprocess the following candidate with CondTester:
Priority 4978
At location prog.c:23
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, (*l)->head->next, (*l)->head, (*l)->head->element, (*l)->size)))
    return;
(*l)->head->next = (*l)->head;


CondTester, a patch instance with id 96:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head), sizeof ((*l)->head), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 263
Counter: 264
Batcher Size:27
Preprocess the following candidate with CondTester:
Priority 4978
At location prog.c:23
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l, (*l)->head->next, (*l)->head, (*l)->head->element, (*l)->size)))
    (*l)->head->next = (*l)->head;


CondTester, a patch instance with id 97:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
if (!(__is_neg(5, &(l), sizeof (l), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head), sizeof ((*l)->head), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    (*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 264
Counter: 265
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 4978
At location prog.c:23
--Src File: prog.c
Fragment 0:
memset((*l)->head, 0, sizeof (*((*l)->head)));
(*l)->head->next = (*l)->head;


BasicTester, a patch instance with id 164:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
memset((*l)->head, 0, sizeof (*((*l)->head)));
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 265
Counter: 266
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 4978
At location prog.c:23
--Src File: prog.c
Fragment 0:
memset((*l), 0, sizeof (*((*l))));
(*l)->head->next = (*l)->head;


BasicTester, a patch instance with id 165:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
memset((*l), 0, sizeof (*((*l))));
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 266
Counter: 267
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority 4977
At location prog.c:22
--Src File: prog.c
Fragment 0:
memset((*l), 0, sizeof (*((*l))));
newNode(&((*l)->head));


BasicTester, a patch instance with id 166:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
memset((*l), 0, sizeof (*((*l))));
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 267
Counter: 268
Batcher Size:31
Preprocess the following candidate with BasicTester:
Priority 4977
At location prog.c:22
--Src File: prog.c
Fragment 0:
memset((*l)->head, 0, sizeof (*((*l)->head)));
newNode(&((*l)->head));


BasicTester, a patch instance with id 167:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
memset((*l)->head, 0, sizeof (*((*l)->head)));
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 268
Counter: 269
Batcher Size:32
Preprocess the following candidate with CondTester:
Priority 4977
At location prog.c:22
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l, (*l)->head, (*l)->head->next, (*l)->head->element, (*l)->size)))
    newNode(&((*l)->head));


CondTester, a patch instance with id 98:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
if (!(__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 269
Counter: 270
Batcher Size:33
Preprocess the following candidate with BasicTester:
Priority 4977
At location prog.c:22
--Src File: prog.c
Fragment 0:
newNode(&((*l)->head));


BasicTester, a patch instance with id 168:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 270
Counter: 271
Batcher Size:34
Preprocess the following candidate with CondTester:
Priority 4977
At location prog.c:22
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, (*l)->head, (*l)->head->next, (*l)->head->element, (*l)->size)))
    return;
newNode(&((*l)->head));


CondTester, a patch instance with id 99:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 271
Counter: 272
Batcher Size:35
Preprocess the following candidate with BasicTester:
Priority 4976
At location prog.c:21
--Src File: prog.c
Fragment 0:
*l = malloc(sizeof(struct List));


BasicTester, a patch instance with id 169:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 272
Counter: 273
Batcher Size:36
Preprocess the following candidate with CondTester:
Priority 4976
At location prog.c:21
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l, (*l)->head, (*l)->head->next, (*l)->head->element, (*l)->size)))
    *l = malloc(sizeof(struct List));


CondTester, a patch instance with id 100:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
if (!(__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    *l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 273
Counter: 274
Batcher Size:37
Preprocess the following candidate with CondTester:
Priority 4975
At location prog.c:55
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, f, argv, argc, l->head, l->size)))
    return 0;
newList(&l);


CondTester, a patch instance with id 101:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 0;
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 274
Counter: 275
Batcher Size:38
Preprocess the following candidate with CondTester:
Priority 4975
At location prog.c:55
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, f, argv, argc, l->head, l->size)))
    return 20;
newList(&l);


CondTester, a patch instance with id 102:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 20;
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 275
Counter: 276
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority 4975
At location prog.c:55
--Src File: prog.c
Fragment 0:
reverse(&l);


BasicTester, a patch instance with id 170:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
reverse(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 276
Counter: 277
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority 4975
At location prog.c:55
--Src File: prog.c
Fragment 0:
memset(l, 0, sizeof (*(l)));
newList(&l);


BasicTester, a patch instance with id 171:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
memset(l, 0, sizeof (*(l)));
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 277
Counter: 278
Batcher Size:41
Preprocess the following candidate with CondTester:
Priority 4975
At location prog.c:55
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l, f, argv, argc, l->head, l->size)))
    newList(&l);


CondTester, a patch instance with id 103:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if (!(__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 278
Counter: 279
Batcher Size:42
Preprocess the following candidate with CondTester:
Priority 4975
At location prog.c:55
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, f, argv, argc, l->head, l->size)))
    return 2;
newList(&l);


CondTester, a patch instance with id 104:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 2;
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 279
Counter: 280
Batcher Size:43
Preprocess the following candidate with CondTester:
Priority 4975
At location prog.c:55
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, f, argv, argc, l->head, l->size)))
    return 1;
newList(&l);


CondTester, a patch instance with id 105:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 1;
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 280
Counter: 281
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority 4975
At location prog.c:55
--Src File: prog.c
Fragment 0:
newList(&l);


BasicTester, a patch instance with id 172:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 281
Counter: 282
Batcher Size:45
Preprocess the following candidate with CondTester:
Priority 4974
At location prog.c:54
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, argv, argc)))
    return 0;
struct List *l;


CondTester, a patch instance with id 106:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 282
Counter: 283
Batcher Size:46
Preprocess the following candidate with CondTester:
Priority 4974
At location prog.c:54
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, argv, argc)))
    return 2;
struct List *l;


CondTester, a patch instance with id 107:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 283
Counter: 284
Batcher Size:47
Preprocess the following candidate with CondTester:
Priority 4974
At location prog.c:54
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, argv, argc)))
    return 20;
struct List *l;


CondTester, a patch instance with id 108:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 284
Counter: 285
Batcher Size:48
Preprocess the following candidate with CondTester:
Priority 4974
At location prog.c:54
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, argv, argc)))
    return 1;
struct List *l;


CondTester, a patch instance with id 109:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 285
Counter: 286
Batcher Size:49
Preprocess the following candidate with CondTester:
Priority 4973
At location prog.c:53
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, argv, argc)))
    return 20;
if (f == ((void *)0))
    return 0;


CondTester, a patch instance with id 110:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 286
Counter: 287
Batcher Size:50
Preprocess the following candidate with CondTester:
Priority 4973
At location prog.c:53
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, argv, argc)))
    return 2;
if (f == ((void *)0))
    return 0;


CondTester, a patch instance with id 111:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 287
Counter: 288
Batcher Size:51
Preprocess the following candidate with CondTester:
Priority 4973
At location prog.c:53
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, argv, argc)))
    return 0;
if (f == ((void *)0))
    return 0;


CondTester, a patch instance with id 112:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 288
Counter: 289
Batcher Size:52
Preprocess the following candidate with CondTester:
Priority 4973
At location prog.c:53
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, argv, argc)))
    return 1;
if (f == ((void *)0))
    return 0;


CondTester, a patch instance with id 113:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 289
Counter: 290
Batcher Size:53
Preprocess the following candidate with CondTester:
Priority 4973
At location prog.c:53
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(f, argv, argc)))
    if (f == ((void *)0))
        return 0;


CondTester, a patch instance with id 114:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if (!(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    if (f == ((void *)0))
        return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 290
Counter: 291
Batcher Size:54
Preprocess the following candidate with CondTester:
Priority 4972
At location prog.c:52
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argv, argc)))
    return 20;
FILE *f = fopen(argv[1], "r");


CondTester, a patch instance with id 115:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    
//Patch 0:
if ((__is_neg(2, &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
FILE *f = fopen(argv[1], "r");

//CodeSeg 1:
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 291
Counter: 292
Batcher Size:55
Preprocess the following candidate with CondTester:
Priority 4972
At location prog.c:52
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argv, argc)))
    return 2;
FILE *f = fopen(argv[1], "r");


CondTester, a patch instance with id 116:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    
//Patch 0:
if ((__is_neg(2, &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
FILE *f = fopen(argv[1], "r");

//CodeSeg 1:
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 292
Counter: 293
Batcher Size:56
Preprocess the following candidate with CondTester:
Priority 4972
At location prog.c:52
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argv, argc)))
    return 1;
FILE *f = fopen(argv[1], "r");


CondTester, a patch instance with id 117:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    
//Patch 0:
if ((__is_neg(2, &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
FILE *f = fopen(argv[1], "r");

//CodeSeg 1:
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 293
Counter: 294
Batcher Size:57
Preprocess the following candidate with CondTester:
Priority 4972
At location prog.c:52
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argv, argc)))
    return 0;
FILE *f = fopen(argv[1], "r");


CondTester, a patch instance with id 118:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    
//Patch 0:
if ((__is_neg(2, &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
FILE *f = fopen(argv[1], "r");

//CodeSeg 1:
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 294
Counter: 295
Batcher Size:58
Preprocess the following candidate with CondTester:
Priority 4971
At location prog.c:51
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(argc, argv)))
    if (argc < 2)
        return 0;


CondTester, a patch instance with id 119:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if (!(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    if (argc < 2)
        return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 295
Counter: 296
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
in->element = (v);
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 173:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->element = (v);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 296
Counter: 297
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
in->element = (0);
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 174:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->element = (0);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 297
Counter: 298
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
e->next = (in);
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 175:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e->next = (in);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 298
Counter: 299
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
e->next = in;
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 176:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e->next = in;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 299
Counter: 300
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
e->next = (e);
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 177:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e->next = (e);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 300
Counter: 301
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
e = e->next;
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 178:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e = e->next;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 301
Counter: 302
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
e = (in);
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 179:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e = (in);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 302
Counter: 303
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
e = (e)->next;
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 180:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e = (e)->next;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 303
Counter: 304
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
e = (e);
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 181:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e = (e);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 304
Counter: 305
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
memset(e->next, 0, sizeof (*(e->next)));
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 182:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
memset(e->next, 0, sizeof (*(e->next)));
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 305
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        //prophet generated patch
        if (__get_mutant()==0) {
        in->element = (v);
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==1) {
        in->element = (0);
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==2) {
        e->next = (in);
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==3) {
        e->next = in;
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==4) {
        e->next = (e);
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==5) {
        e = e->next;
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==6) {
        e = (in);
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==7) {
        e = (e)->next;
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==8) {
        e = (e);
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==9) {
        memset(e->next, 0, sizeof (*(e->next)));
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 173:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->element = (v);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 174:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->element = (0);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 175:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e->next = (in);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 176:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e->next = in;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 177:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e->next = (e);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 178:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e = e->next;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 179:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e = (in);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 180:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e = (e)->next;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 181:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e = (e);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 182:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
memset(e->next, 0, sizeof (*(e->next)));
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Going to sync the batch tester, clear all existing tasks!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    //prophet generated patch
    if (__get_mutant()==0) {
    *l = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==1) {
    if (!(__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
        *l = malloc(sizeof(struct List));
    }
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 169:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
*l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 100:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    
//Patch 0:
if (!(__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    *l = malloc(sizeof(struct List));

//CodeSeg 1:
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    //prophet generated patch
    if (__get_mutant()==0) {
    memset((*l), 0, sizeof (*((*l))));
    newNode(&((*l)->head));
    }
    else if (__get_mutant()==1) {
    memset((*l)->head, 0, sizeof (*((*l)->head)));
    newNode(&((*l)->head));
    }
    else if (__get_mutant()==2) {
    if (!(__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
        newNode(&((*l)->head));
    }
    else if (__get_mutant()==3) {
    newNode(&((*l)->head));
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
        return;
    newNode(&((*l)->head));
    }
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 166:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
memset((*l), 0, sizeof (*((*l))));
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 167:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
memset((*l)->head, 0, sizeof (*((*l)->head)));
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 98:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
if (!(__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 168:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 99:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(5, &(l), sizeof (l), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head), sizeof ((*l)->head), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
        return;
    (*l)->head->next = (*l)->head;
    }
    else if (__get_mutant()==1) {
    if (!(__is_neg(5, &(l), sizeof (l), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head), sizeof ((*l)->head), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
        (*l)->head->next = (*l)->head;
    }
    else if (__get_mutant()==2) {
    memset((*l)->head, 0, sizeof (*((*l)->head)));
    (*l)->head->next = (*l)->head;
    }
    else if (__get_mutant()==3) {
    memset((*l), 0, sizeof (*((*l))));
    (*l)->head->next = (*l)->head;
    }
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 96:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head), sizeof ((*l)->head), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 97:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
if (!(__is_neg(5, &(l), sizeof (l), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head), sizeof ((*l)->head), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    (*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 164:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
memset((*l)->head, 0, sizeof (*((*l)->head)));
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 165:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
memset((*l), 0, sizeof (*((*l))));
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    //prophet generated patch
    if (__get_mutant()==0) {
    if (!(__is_neg(5, &(l), sizeof (l), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head), sizeof ((*l)->head), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
        return;
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(5, &(l), sizeof (l), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head), sizeof ((*l)->head), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
        return;
    return;
    }
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 94:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
if (!(__is_neg(5, &(l), sizeof (l), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head), sizeof ((*l)->head), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 95:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
if ((__is_neg(5, &(l), sizeof (l), &((*l)->head->next), sizeof ((*l)->head->next), &((*l)->head), sizeof ((*l)->head), &((*l)->head->element), sizeof ((*l)->head->element), &((*l)->size), sizeof ((*l)->size))))
    return;
return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    //prophet generated patch
    if (__get_mutant()==0) {
    if (!(__is_neg(1, &(n), sizeof (n))))
        *n = malloc(sizeof(struct Entry));
    }
    else if (__get_mutant()==1) {
    *n = malloc(sizeof(struct Entry));
    }
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
if (!(__is_neg(1, &(n), sizeof (n))))
    *n = malloc(sizeof(struct Entry));

//CodeSeg 1:
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Iteration 3
Branch 0: 1
Branch 1: 0
Branch 2: 0
Iteration 4
Branch 0: 1
Branch 1: 0
Branch 2: 1
Iteration 5
Branch 0: 1
Branch 1: 1
BasicTester, Testing instance id 162:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    
//Patch 0:
*n = malloc(sizeof(struct Entry));

//CodeSeg 1:
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(3, &(n), sizeof (n), &((*n)->next), sizeof ((*n)->next), &((*n)->element), sizeof ((*n)->element))))
        return;
    (*n)->next = ((void *)0);
    }
    else if (__get_mutant()==1) {
    if (!(__is_neg(3, &(n), sizeof (n), &((*n)->next), sizeof ((*n)->next), &((*n)->element), sizeof ((*n)->element))))
        (*n)->next = ((void *)0);
    }
    else if (__get_mutant()==2) {
    memset((*n), 0, sizeof (*((*n))));
    (*n)->next = ((void *)0);
    }
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    
//Patch 0:
if ((__is_neg(3, &(n), sizeof (n), &((*n)->next), sizeof ((*n)->next), &((*n)->element), sizeof ((*n)->element))))
    return;
(*n)->next = ((void *)0);

//CodeSeg 1:
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 3
Branch 0: 0
Branch 1: 1
Branch 2: 1
Iteration 4
Branch 0: 1
Branch 1: 0
Branch 2: 0
Iteration 5
Branch 0: 1
Branch 1: 0
Branch 2: 1
Iteration 6
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 7
Branch 0: 1
Branch 1: 1
Branch 2: 1
CondTester, Testing instance id 79:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    
//Patch 0:
if (!(__is_neg(3, &(n), sizeof (n), &((*n)->next), sizeof ((*n)->next), &((*n)->element), sizeof ((*n)->element))))
    (*n)->next = ((void *)0);

//CodeSeg 1:
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 3
Branch 0: 0
Branch 1: 1
Branch 2: 1
Iteration 4
Branch 0: 1
Branch 1: 0
Branch 2: 0
Iteration 5
Branch 0: 1
Branch 1: 0
Branch 2: 1
Iteration 6
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 7
Branch 0: 1
Branch 1: 1
Branch 2: 1
BasicTester, Testing instance id 161:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    
//Patch 0:
memset((*n), 0, sizeof (*((*n))));
(*n)->next = ((void *)0);

//CodeSeg 1:
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if (!(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        if (argc < 2)
            return 0;
    }
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 119:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    
//Patch 0:
if (!(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    if (argc < 2)
        return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(2, &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 20;
    FILE *f = fopen(argv[1], "r");
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(2, &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 2;
    FILE *f = fopen(argv[1], "r");
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(2, &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 1;
    FILE *f = fopen(argv[1], "r");
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(2, &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    FILE *f = fopen(argv[1], "r");
    }
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building failed! Going to build saperately!
CondTester, Testing instance id 115:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    
//Patch 0:
if ((__is_neg(2, &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
FILE *f = fopen(argv[1], "r");

//CodeSeg 1:
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 116:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    
//Patch 0:
if ((__is_neg(2, &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
FILE *f = fopen(argv[1], "r");

//CodeSeg 1:
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 117:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    
//Patch 0:
if ((__is_neg(2, &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
FILE *f = fopen(argv[1], "r");

//CodeSeg 1:
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 118:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    
//Patch 0:
if ((__is_neg(2, &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
FILE *f = fopen(argv[1], "r");

//CodeSeg 1:
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 20;
    if (f == ((void *)0))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 2;
    if (f == ((void *)0))
        return 0;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    if (f == ((void *)0))
        return 0;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 1;
    if (f == ((void *)0))
        return 0;
    }
    else if (__get_mutant()==4) {
    if (!(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        if (f == ((void *)0))
            return 0;
    }
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 110:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 111:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 112:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 113:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 114:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if (!(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    if (f == ((void *)0))
        return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    struct List *l;
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 2;
    struct List *l;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 20;
    struct List *l;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 1;
    struct List *l;
    }
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building failed! Going to build saperately!
CondTester, Testing instance id 106:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 107:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 108:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 109:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
if ((__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
        return 0;
    newList(&l);
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
        return 20;
    newList(&l);
    }
    else if (__get_mutant()==2) {
    reverse(&l);
    }
    else if (__get_mutant()==3) {
    memset(l, 0, sizeof (*(l)));
    newList(&l);
    }
    else if (__get_mutant()==4) {
    if (!(__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
        newList(&l);
    }
    else if (__get_mutant()==5) {
    if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
        return 2;
    newList(&l);
    }
    else if (__get_mutant()==6) {
    if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
        return 1;
    newList(&l);
    }
    else if (__get_mutant()==7) {
    newList(&l);
    }
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building failed! Going to build saperately!
CondTester, Testing instance id 101:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 0;
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 102:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 20;
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Single building for Tester 0xb563890 id 170 failed as well!
BasicTester, Testing instance id 171:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
memset(l, 0, sizeof (*(l)));
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 103:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if (!(__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 104:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 2;
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 105:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if ((__is_neg(6, &(l), sizeof (l), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(l->head), sizeof (l->head), &(l->size), sizeof (l->size))))
    return 1;
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 172:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(4, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 2;
    struct Entry *node;
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(4, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 20;
    struct Entry *node;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(4, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    struct Entry *node;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(4, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 1;
    struct Entry *node;
    }
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building failed! Going to build saperately!
CondTester, Testing instance id 86:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if ((__is_neg(4, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 87:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if ((__is_neg(4, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 88:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if ((__is_neg(4, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 89:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if ((__is_neg(4, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
        return 1;
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
        return 20;
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
        return 2;
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
        return 0;
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==4) {
    if (!(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
        while (fscanf(f, "%s", x) == 1)
            {
                if (x[0] != '"') {
                    insertSort(&l, atoi(x));
                }
            }
    }
    else if (__get_mutant()==5) {
    memset(l, 0, sizeof (*(l)));
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 81:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
    return 1;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 82:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
    return 20;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 83:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
    return 2;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 84:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if ((__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
    return 0;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 85:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if (!(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node), sizeof (node))))
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 163:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
memset(l, 0, sizeof (*(l)));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        //prophet generated patch
        if (__get_mutant()==0) {
        newNode(&(node));
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==1) {
        newList(&(l));
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==2) {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==3) {
        insertSort(&(l), atoi(x));
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==4) {
        fclose((f));
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==5) {
        fclose(f);
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==6) {
        if (!(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))) && (x[0] != '"')) {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==7) {
        memset(l, 0, sizeof (*(l)));
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        }
        else if (__get_mutant()==8) {
        if (!(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 154:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
newNode(&(node));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 155:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
newList(&(l));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 156:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 157:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
insertSort(&(l), atoi(x));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 158:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
fclose((f));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 159:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
fclose(f);
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 76:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if (!(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))) && (x[0] != '"')) {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Iteration 4
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 0
Iteration 5
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 1
Iteration 6
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 7
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Iteration 8
Branch 0: 1
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 9
Branch 0: 1
Branch 1: 0
Branch 2: 0
Branch 3: 1
BasicTester, Testing instance id 160:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
memset(l, 0, sizeof (*(l)));
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if (!(__is_neg(5, &(f), sizeof (f), &(l), sizeof (l), &(argv), sizeof (argv), &(node), sizeof (node), &(argc), sizeof (argc))))
    if (x[0] != '"') {
        insertSort(&l, atoi(x));
    }

//CodeSeg 1:
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Iteration 4
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 0
Iteration 5
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 1
Iteration 6
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 7
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Iteration 8
Branch 0: 1
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 9
Branch 0: 1
Branch 1: 0
Branch 2: 0
Branch 3: 1
Counter: 306
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
memset(e, 0, sizeof (*(e)));
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 183:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
memset(e, 0, sizeof (*(e)));
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 306
Counter: 307
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(v, e, e->next->element, e->next, l, (*l)->head, in, (*l)->size, e->next->next, e->element)))
    if (e->next->element < v)
        e = e->next;
    else
        break;


CondTester, a patch instance with id 120:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
if (!(__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    if (e->next->element < v)
        e = e->next;
    else
        break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 307
Counter: 308
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
newNode(&(in));
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 184:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
newNode(&(in));
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 308
Counter: 309
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
printf("%d ", (in)->next->element);
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 185:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
printf("%d ", (in)->next->element);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 309
Counter: 310
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
printf("%d ", (e)->next->element);
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 186:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
printf("%d ", (e)->next->element);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 310
Counter: 311
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
newNode(&in);
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 187:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
newNode(&in);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 311
Counter: 312
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
newNode(&(e));
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 188:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
newNode(&(e));
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 312
Counter: 313
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
e = (in)->next;
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 189:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e = (in)->next;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 313
Counter: 314
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 190:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
newNode(&((*(l))->head));
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 314
Counter: 315
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
in->next = e->next;
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 191:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->next = e->next;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 315
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        //prophet generated patch
        if (__get_mutant()==0) {
        memset(e, 0, sizeof (*(e)));
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==1) {
        if (!(__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
        else if (__get_mutant()==2) {
        newNode(&(in));
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==3) {
        printf("%d ", (in)->next->element);
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==4) {
        printf("%d ", (e)->next->element);
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==5) {
        newNode(&in);
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==6) {
        newNode(&(e));
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==7) {
        e = (in)->next;
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==8) {
        newNode(&((*(l))->head));
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==9) {
        in->next = e->next;
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 183:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
memset(e, 0, sizeof (*(e)));
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 120:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
if (!(__is_neg(10, &(v), sizeof (v), &(e), sizeof (e), &(e->next->element), sizeof (e->next->element), &(e->next), sizeof (e->next), &(l), sizeof (l), &((*l)->head), sizeof ((*l)->head), &(in), sizeof (in), &((*l)->size), sizeof ((*l)->size), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
    if (e->next->element < v)
        e = e->next;
    else
        break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Branch 1: 0
Iteration 2
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 6
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 7
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 8
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 9
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
BasicTester, Testing instance id 184:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
newNode(&(in));
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 185:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
printf("%d ", (in)->next->element);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 186:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
printf("%d ", (e)->next->element);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 187:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
newNode(&in);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 188:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
newNode(&(e));
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 189:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
e = (in)->next;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 190:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
newNode(&((*(l))->head));
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 191:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->next = e->next;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 316
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
in->next = (in)->next;
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 192:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->next = (in)->next;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 316
Counter: 317
Batcher Size:1
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
in->element = v;
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 193:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->element = v;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 317
Counter: 318
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
in->next = (in);
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 194:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->next = (in);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 318
Counter: 319
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
in->next = (e)->next;
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 195:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->next = (e)->next;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 319
Counter: 320
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority 4970
At location prog.c:39
--Src File: prog.c
Fragment 0:
in->next = (e);
if (e->next->element < v)
    e = e->next;
else
    break;


BasicTester, a patch instance with id 196:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->next = (e);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 320
Counter: 321
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 4969
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(in, e, v, l)))
        return;
    break;
}


CondTester, a patch instance with id 121:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    if ((__is_neg(4, &(in), sizeof (in), &(e), sizeof (e), &(v), sizeof (v), &(l), sizeof (l))))
        return;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 321
Counter: 322
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 4969
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(in, e, v, l)))
        break;
    break;
}


CondTester, a patch instance with id 122:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    if ((__is_neg(4, &(in), sizeof (in), &(e), sizeof (e), &(v), sizeof (v), &(l), sizeof (l))))
        break;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 322
Counter: 323
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 4969
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    if (!(__abst_hole(in, e, v, l)))
        break;
}


CondTester, a patch instance with id 123:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    if (!(__is_neg(4, &(in), sizeof (in), &(e), sizeof (e), &(v), sizeof (v), &(l), sizeof (l))))
        break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 323
Counter: 324
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 4968
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(e, e->next, v, e->next->element, l, in, e->next->next, e->element)))
        break;
    e = e->next;
}


CondTester, a patch instance with id 124:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    if ((__is_neg(8, &(e), sizeof (e), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in), sizeof (in), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
        break;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 324
Counter: 325
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 4968
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(e, e->next, v, e->next->element, l, in, e->next->next, e->element)))
        return;
    e = e->next;
}


CondTester, a patch instance with id 125:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    if ((__is_neg(8, &(e), sizeof (e), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in), sizeof (in), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
        return;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 325
Counter: 326
Batcher Size:10
Preprocess the following candidate with BasicTester:
Priority 4968
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    memset(e, 0, sizeof (*(e)));
    e = e->next;
}


BasicTester, a patch instance with id 197:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    memset(e, 0, sizeof (*(e)));
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 326
Counter: 327
Batcher Size:11
Preprocess the following candidate with BasicTester:
Priority 4968
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    memset(e->next, 0, sizeof (*(e->next)));
    e = e->next;
}


BasicTester, a patch instance with id 198:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    memset(e->next, 0, sizeof (*(e->next)));
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 327
Counter: 328
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 4968
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    if (!(__abst_hole(e, e->next, v, e->next->element, l, in, e->next->next, e->element)))
        e = e->next;
}


CondTester, a patch instance with id 126:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    if (!(__is_neg(8, &(e), sizeof (e), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in), sizeof (in), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
        e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 328
Counter: 329
Batcher Size:13
Preprocess the following candidate with BasicTester:
Priority 2500
At location prog.c:69
--Src File: prog.c
Fragment 0:
node = (node);


BasicTester, a patch instance with id 199:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = (node);

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 329
Counter: 330
Batcher Size:14
Preprocess the following candidate with BasicTester:
Priority 2500
At location prog.c:69
--Src File: prog.c
Fragment 0:
node = (node)->next;


BasicTester, a patch instance with id 200:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = (node)->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 330
Counter: 331
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority 2499
At location prog.c:68
--Src File: prog.c
Fragment 0:
printf("%d ", (node)->next->element);


BasicTester, a patch instance with id 201:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf("%d ", (node)->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 331
Counter: 332
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority 2498
At location prog.c:45
--Src File: prog.c
Fragment 0:
e->next = (e);


BasicTester, a patch instance with id 202:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = (e);

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 332
Counter: 333
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority 2498
At location prog.c:45
--Src File: prog.c
Fragment 0:
e->next = (e);


BasicTester, a patch instance with id 203:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = (e);

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 333
Counter: 334
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority 2498
At location prog.c:45
--Src File: prog.c
Fragment 0:
e->next = (in);


BasicTester, a patch instance with id 204:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = (in);

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 334
Counter: 335
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority 2498
At location prog.c:45
--Src File: prog.c
Fragment 0:
e->next = (in);


BasicTester, a patch instance with id 205:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = (in);

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 335
Counter: 336
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority 2497
At location prog.c:44
--Src File: prog.c
Fragment 0:
in->next = (e)->next;


BasicTester, a patch instance with id 206:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (e)->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 336
Counter: 337
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority 2497
At location prog.c:44
--Src File: prog.c
Fragment 0:
in->next = (in)->next;


BasicTester, a patch instance with id 207:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (in)->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 337
Counter: 338
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority 2497
At location prog.c:44
--Src File: prog.c
Fragment 0:
in->next = (in);


BasicTester, a patch instance with id 208:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (in);

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 338
Counter: 339
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority 2497
At location prog.c:44
--Src File: prog.c
Fragment 0:
in->next = (e);


BasicTester, a patch instance with id 209:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (e);

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 339
Counter: 340
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority 2494
At location prog.c:36
--Src File: prog.c
Fragment 0:
in->element = (v);


BasicTester, a patch instance with id 210:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->element = (v);

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 340
Counter: 341
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority 2494
At location prog.c:36
--Src File: prog.c
Fragment 0:
in->element = (0);


BasicTester, a patch instance with id 211:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->element = (0);

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 341
Counter: 342
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority 2493
At location prog.c:35
--Src File: prog.c
Fragment 0:
newNode(&(in));


BasicTester, a patch instance with id 212:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
newNode(&(in));

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 342
Counter: 343
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority 2491
At location prog.c:61
--Src File: prog.c
Fragment 0:
insertSort(&(l), atoi(x));


BasicTester, a patch instance with id 213:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&(l), atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 343
Counter: 344
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority 2489
At location prog.c:71
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);


BasicTester, a patch instance with id 214:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf(" %d", (l)->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 344
Counter: 345
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority 2487
At location prog.c:66
--Src File: prog.c
Fragment 0:
node = (node);


BasicTester, a patch instance with id 215:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = (node);

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 345
Counter: 346
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority 2487
At location prog.c:66
--Src File: prog.c
Fragment 0:
node = (l)->head;


BasicTester, a patch instance with id 216:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = (l)->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 346
Counter: 347
Batcher Size:31
Preprocess the following candidate with BasicTester:
Priority 2486
At location prog.c:64
--Src File: prog.c
Fragment 0:
fclose((f));


BasicTester, a patch instance with id 217:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
fclose((f));

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 347
Counter: 348
Batcher Size:32
Preprocess the following candidate with BasicTester:
Priority 2478
At location prog.c:23
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*(l))->head;


BasicTester, a patch instance with id 218:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
(*l)->head->next = (*(l))->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 348
Counter: 349
Batcher Size:33
Preprocess the following candidate with BasicTester:
Priority 2477
At location prog.c:22
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));


BasicTester, a patch instance with id 219:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
newNode(&((*(l))->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 349
Counter: 350
Batcher Size:34
Preprocess the following candidate with BasicTester:
Priority 2475
At location prog.c:55
--Src File: prog.c
Fragment 0:
newList(&(l));


BasicTester, a patch instance with id 220:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
newList(&(l));

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 350
Counter: 351
Batcher Size:35
Preprocess the following candidate with BasicTester:
Priority 2468
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    e = (in)->next;
}


BasicTester, a patch instance with id 221:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (in)->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 351
Counter: 352
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority 2468
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    e = (e)->next;
}


BasicTester, a patch instance with id 222:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (e)->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 352
Counter: 353
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority 2468
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    e = (e);
}


BasicTester, a patch instance with id 223:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (e);
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 353
Counter: 354
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority 2468
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    e = (in);
}


BasicTester, a patch instance with id 224:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (in);
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 354
Counter: 355
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
newList(&l);
node = node->next;


BasicTester, a patch instance with id 225:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
newList(&l);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 355
Counter: 356
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
node = (l)->head;
node = node->next;


BasicTester, a patch instance with id 226:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = (l)->head;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 356
Counter: 357
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
insertSort(&l, atoi(x));
node = node->next;


BasicTester, a patch instance with id 227:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
insertSort(&l, atoi(x));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 357
Counter: 358
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
insertSort(&(l), atoi(x));
node = node->next;


BasicTester, a patch instance with id 228:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
insertSort(&(l), atoi(x));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 358
Counter: 359
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
printf("%d ", (node)->next->element);
node = node->next;


BasicTester, a patch instance with id 229:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
printf("%d ", (node)->next->element);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 359
Counter: 360
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
printf("%d ", node->next->element);
node = node->next;


BasicTester, a patch instance with id 230:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
printf("%d ", node->next->element);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 360
Counter: 361
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
node = node->next;


BasicTester, a patch instance with id 231:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
printf(" %d", (l)->size);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 361
Counter: 362
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
node = l->head;
node = node->next;


BasicTester, a patch instance with id 232:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = l->head;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 362
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        //prophet generated patch
        if (__get_mutant()==0) {
        node = (node);
        }
        else if (__get_mutant()==1) {
        node = (node)->next;
        }
        else if (__get_mutant()==2) {
        newList(&l);
        node = node->next;
        }
        else if (__get_mutant()==3) {
        node = (l)->head;
        node = node->next;
        }
        else if (__get_mutant()==4) {
        insertSort(&l, atoi(x));
        node = node->next;
        }
        else if (__get_mutant()==5) {
        insertSort(&(l), atoi(x));
        node = node->next;
        }
        else if (__get_mutant()==6) {
        printf("%d ", (node)->next->element);
        node = node->next;
        }
        else if (__get_mutant()==7) {
        printf("%d ", node->next->element);
        node = node->next;
        }
        else if (__get_mutant()==8) {
        printf(" %d", (l)->size);
        node = node->next;
        }
        else if (__get_mutant()==9) {
        node = l->head;
        node = node->next;
        }
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 199:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = (node);

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 200:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = (node)->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 225:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
newList(&l);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 226:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = (l)->head;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 227:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
insertSort(&l, atoi(x));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 228:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
insertSort(&(l), atoi(x));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 229:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
printf("%d ", (node)->next->element);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 230:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
printf("%d ", node->next->element);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 231:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
printf(" %d", (l)->size);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 232:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = l->head;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 363
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
newNode(&(node));
node = node->next;


BasicTester, a patch instance with id 233:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
newNode(&(node));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 363
Counter: 364
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
fclose(f);
node = node->next;


BasicTester, a patch instance with id 234:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
fclose(f);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 364
Counter: 365
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
node = node->next;


BasicTester, a patch instance with id 235:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if (f == ((void *)0))
    return 0;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 365
Counter: 366
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);
node = node->next;


BasicTester, a patch instance with id 236:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
printf(" %d", l->size);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 366
Counter: 367
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
node = (node)->next;
node = node->next;


BasicTester, a patch instance with id 237:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = (node)->next;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 367
Counter: 368
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
node = node->next;
node = node->next;


BasicTester, a patch instance with id 238:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = node->next;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 368
Counter: 369
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
node = (node);
node = node->next;


BasicTester, a patch instance with id 239:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = (node);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 369
Counter: 370
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
node = node->next;


BasicTester, a patch instance with id 240:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 370
Counter: 371
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
newList(&(l));
node = node->next;


BasicTester, a patch instance with id 241:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
newList(&(l));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 371
Counter: 372
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
node = node->next;


BasicTester, a patch instance with id 242:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if (argc < 2)
    return 0;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 372
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        //prophet generated patch
        if (__get_mutant()==0) {
        newNode(&(node));
        node = node->next;
        }
        else if (__get_mutant()==1) {
        fclose(f);
        node = node->next;
        }
        else if (__get_mutant()==2) {
        if (f == ((void *)0))
            return 0;
        node = node->next;
        }
        else if (__get_mutant()==3) {
        printf(" %d", l->size);
        node = node->next;
        }
        else if (__get_mutant()==4) {
        node = (node)->next;
        node = node->next;
        }
        else if (__get_mutant()==5) {
        node = node->next;
        node = node->next;
        }
        else if (__get_mutant()==6) {
        node = (node);
        node = node->next;
        }
        else if (__get_mutant()==7) {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
        node = node->next;
        }
        else if (__get_mutant()==8) {
        newList(&(l));
        node = node->next;
        }
        else if (__get_mutant()==9) {
        if (argc < 2)
            return 0;
        node = node->next;
        }
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 233:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
newNode(&(node));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 234:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
fclose(f);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 235:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if (f == ((void *)0))
    return 0;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 236:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
printf(" %d", l->size);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 237:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = (node)->next;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 238:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = node->next;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 239:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
node = (node);
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 240:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 241:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
newList(&(l));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 242:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
if (argc < 2)
    return 0;
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 373
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority -0
At location prog.c:69
--Src File: prog.c
Fragment 0:
fclose((f));
node = node->next;


BasicTester, a patch instance with id 243:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
fclose((f));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 373
Counter: 374
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
e->next = in;


BasicTester, a patch instance with id 244:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
newNode(&((*(l))->head));
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 374
Counter: 375
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
in->next = e->next;
e->next = in;


BasicTester, a patch instance with id 245:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->next = e->next;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 375
Counter: 376
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
in->next = (in);
e->next = in;


BasicTester, a patch instance with id 246:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->next = (in);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 376
Counter: 377
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
e = (e)->next;
e->next = in;


BasicTester, a patch instance with id 247:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e = (e)->next;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 377
Counter: 378
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
in->next = (e)->next;
e->next = in;


BasicTester, a patch instance with id 248:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->next = (e)->next;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 378
Counter: 379
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
in->next = (e);
e->next = in;


BasicTester, a patch instance with id 249:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->next = (e);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 379
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    //prophet generated patch
    if (__get_mutant()==0) {
    e->next = (e);
    }
    else if (__get_mutant()==1) {
    e->next = (e);
    }
    else if (__get_mutant()==2) {
    e->next = (in);
    }
    else if (__get_mutant()==3) {
    e->next = (in);
    }
    else if (__get_mutant()==4) {
    newNode(&((*(l))->head));
    e->next = in;
    }
    else if (__get_mutant()==5) {
    in->next = e->next;
    e->next = in;
    }
    else if (__get_mutant()==6) {
    in->next = (in);
    e->next = in;
    }
    else if (__get_mutant()==7) {
    e = (e)->next;
    e->next = in;
    }
    else if (__get_mutant()==8) {
    in->next = (e)->next;
    e->next = in;
    }
    else if (__get_mutant()==9) {
    in->next = (e);
    e->next = in;
    }
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 202:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = (e);

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 203:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = (e);

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 204:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = (in);

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 205:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = (in);

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 244:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
newNode(&((*(l))->head));
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 245:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->next = e->next;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 246:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->next = (in);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 247:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e = (e)->next;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 248:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->next = (e)->next;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 249:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->next = (e);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 380
Batcher Size:34
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
in->element = (v);
e->next = in;


BasicTester, a patch instance with id 250:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->element = (v);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 380
Counter: 381
Batcher Size:35
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
in->element = v;
e->next = in;


BasicTester, a patch instance with id 251:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->element = v;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 381
Counter: 382
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
in->element = (0);
e->next = in;


BasicTester, a patch instance with id 252:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->element = (0);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 382
Counter: 383
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
e->next = in;
e->next = in;


BasicTester, a patch instance with id 253:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = in;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 383
Counter: 384
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
e->next = (in);
e->next = in;


BasicTester, a patch instance with id 254:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = (in);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 384
Counter: 385
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
e->next = (e);
e->next = in;


BasicTester, a patch instance with id 255:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = (e);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 385
Counter: 386
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
e = e->next;
e->next = in;


BasicTester, a patch instance with id 256:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e = e->next;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 386
Counter: 387
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
e = (e);
e->next = in;


BasicTester, a patch instance with id 257:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e = (e);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 387
Counter: 388
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
e = (in);
e->next = in;


BasicTester, a patch instance with id 258:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e = (in);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 388
Counter: 389
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
in->next = (in)->next;
e->next = in;


BasicTester, a patch instance with id 259:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->next = (in)->next;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 389
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    //prophet generated patch
    if (__get_mutant()==0) {
    in->element = (v);
    e->next = in;
    }
    else if (__get_mutant()==1) {
    in->element = v;
    e->next = in;
    }
    else if (__get_mutant()==2) {
    in->element = (0);
    e->next = in;
    }
    else if (__get_mutant()==3) {
    e->next = in;
    e->next = in;
    }
    else if (__get_mutant()==4) {
    e->next = (in);
    e->next = in;
    }
    else if (__get_mutant()==5) {
    e->next = (e);
    e->next = in;
    }
    else if (__get_mutant()==6) {
    e = e->next;
    e->next = in;
    }
    else if (__get_mutant()==7) {
    e = (e);
    e->next = in;
    }
    else if (__get_mutant()==8) {
    e = (in);
    e->next = in;
    }
    else if (__get_mutant()==9) {
    in->next = (in)->next;
    e->next = in;
    }
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 250:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->element = (v);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 251:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->element = v;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 252:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->element = (0);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 253:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = in;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 254:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = (in);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 255:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e->next = (e);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 256:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e = e->next;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 257:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e = (e);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 258:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e = (in);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 259:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
in->next = (in)->next;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 390
Batcher Size:34
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
e = (in)->next;
e->next = in;


BasicTester, a patch instance with id 260:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e = (in)->next;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 390
Counter: 391
Batcher Size:35
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
printf("%d ", (in)->next->element);
e->next = in;


BasicTester, a patch instance with id 261:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
printf("%d ", (in)->next->element);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 391
Counter: 392
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
printf("%d ", (e)->next->element);
e->next = in;


BasicTester, a patch instance with id 262:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
printf("%d ", (e)->next->element);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 392
Counter: 393
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
newNode(&in);
e->next = in;


BasicTester, a patch instance with id 263:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
newNode(&in);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 393
Counter: 394
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
newNode(&(in));
e->next = in;


BasicTester, a patch instance with id 264:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
newNode(&(in));
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 394
Counter: 395
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority -2
At location prog.c:45
--Src File: prog.c
Fragment 0:
newNode(&(e));
e->next = in;


BasicTester, a patch instance with id 265:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
newNode(&(e));
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 395
Counter: 396
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
printf("%d ", (in)->next->element);
in->next = e->next;


BasicTester, a patch instance with id 266:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
printf("%d ", (in)->next->element);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 396
Counter: 397
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
printf("%d ", (e)->next->element);
in->next = e->next;


BasicTester, a patch instance with id 267:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
printf("%d ", (e)->next->element);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 397
Counter: 398
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
newNode(&in);
in->next = e->next;


BasicTester, a patch instance with id 268:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
newNode(&in);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 398
Counter: 399
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
newNode(&(in));
in->next = e->next;


BasicTester, a patch instance with id 269:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
newNode(&(in));
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 399
Counter: 400
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
in->next = e->next;


BasicTester, a patch instance with id 270:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
newNode(&((*(l))->head));
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 400
Counter: 401
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
newNode(&(e));
in->next = e->next;


BasicTester, a patch instance with id 271:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
newNode(&(e));
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 401
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    in->next = (e)->next;
    }
    else if (__get_mutant()==1) {
    in->next = (in)->next;
    }
    else if (__get_mutant()==2) {
    in->next = (in);
    }
    else if (__get_mutant()==3) {
    in->next = (e);
    }
    else if (__get_mutant()==4) {
    printf("%d ", (in)->next->element);
    in->next = e->next;
    }
    else if (__get_mutant()==5) {
    printf("%d ", (e)->next->element);
    in->next = e->next;
    }
    else if (__get_mutant()==6) {
    newNode(&in);
    in->next = e->next;
    }
    else if (__get_mutant()==7) {
    newNode(&(in));
    in->next = e->next;
    }
    else if (__get_mutant()==8) {
    newNode(&((*(l))->head));
    in->next = e->next;
    }
    else if (__get_mutant()==9) {
    newNode(&(e));
    in->next = e->next;
    }
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 206:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (e)->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 207:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (in)->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 208:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (in);

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 209:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (e);

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 266:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
printf("%d ", (in)->next->element);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 267:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
printf("%d ", (e)->next->element);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 268:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
newNode(&in);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 269:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
newNode(&(in));
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 270:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
newNode(&((*(l))->head));
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 271:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
newNode(&(e));
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 402
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
in->next = e->next;
in->next = e->next;


BasicTester, a patch instance with id 272:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = e->next;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 402
Counter: 403
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
in->next = (in)->next;
in->next = e->next;


BasicTester, a patch instance with id 273:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (in)->next;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 403
Counter: 404
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
in->next = (in);
in->next = e->next;


BasicTester, a patch instance with id 274:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (in);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 404
Counter: 405
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
in->next = (e)->next;
in->next = e->next;


BasicTester, a patch instance with id 275:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (e)->next;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 405
Counter: 406
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
in->next = (e);
in->next = e->next;


BasicTester, a patch instance with id 276:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (e);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 406
Counter: 407
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
in->element = v;
in->next = e->next;


BasicTester, a patch instance with id 277:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->element = v;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 407
Counter: 408
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
in->element = (0);
in->next = e->next;


BasicTester, a patch instance with id 278:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->element = (0);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 408
Counter: 409
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
in->element = (v);
in->next = e->next;


BasicTester, a patch instance with id 279:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->element = (v);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 409
Counter: 410
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
e->next = in;
in->next = e->next;


BasicTester, a patch instance with id 280:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e->next = in;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 410
Counter: 411
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
e->next = (in);
in->next = e->next;


BasicTester, a patch instance with id 281:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e->next = (in);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 411
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    in->next = e->next;
    in->next = e->next;
    }
    else if (__get_mutant()==1) {
    in->next = (in)->next;
    in->next = e->next;
    }
    else if (__get_mutant()==2) {
    in->next = (in);
    in->next = e->next;
    }
    else if (__get_mutant()==3) {
    in->next = (e)->next;
    in->next = e->next;
    }
    else if (__get_mutant()==4) {
    in->next = (e);
    in->next = e->next;
    }
    else if (__get_mutant()==5) {
    in->element = v;
    in->next = e->next;
    }
    else if (__get_mutant()==6) {
    in->element = (0);
    in->next = e->next;
    }
    else if (__get_mutant()==7) {
    in->element = (v);
    in->next = e->next;
    }
    else if (__get_mutant()==8) {
    e->next = in;
    in->next = e->next;
    }
    else if (__get_mutant()==9) {
    e->next = (in);
    in->next = e->next;
    }
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 272:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = e->next;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 273:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (in)->next;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 274:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (in);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 275:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (e)->next;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 276:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->next = (e);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 277:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->element = v;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 278:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->element = (0);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 279:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
in->element = (v);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 280:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e->next = in;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 281:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e->next = (in);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Going to sync the batch tester, clear all existing tasks!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    //prophet generated patch
    if (__get_mutant()==0) {
    newNode(&((*(l))->head));
    }
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 219:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
newNode(&((*(l))->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    //prophet generated patch
    if (__get_mutant()==0) {
    (*l)->head->next = (*(l))->head;
    }
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 218:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
(*l)->head->next = (*(l))->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    //prophet generated patch
    if (__get_mutant()==0) {
    newNode(&(in));
    }
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 212:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    
//Patch 0:
newNode(&(in));

//CodeSeg 1:
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    //prophet generated patch
    if (__get_mutant()==0) {
    in->element = (v);
    }
    else if (__get_mutant()==1) {
    in->element = (0);
    }
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 210:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->element = (v);

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 211:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->element = (0);

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        //prophet generated patch
        if (__get_mutant()==0) {
        in->next = (in)->next;
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==1) {
        in->element = v;
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==2) {
        in->next = (in);
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==3) {
        in->next = (e)->next;
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
        else if (__get_mutant()==4) {
        in->next = (e);
        if (e->next->element < v)
            e = e->next;
        else
            break;
        }
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 192:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->next = (in)->next;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 193:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->element = v;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 194:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->next = (in);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 195:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->next = (e)->next;
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 196:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        
//Patch 0:
in->next = (e);
if (e->next->element < v)
    e = e->next;
else
    break;

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            //prophet generated patch
            if (__get_mutant()==0) {
            {
                if ((__is_neg(8, &(e), sizeof (e), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in), sizeof (in), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
                    break;
                e = e->next;
            }
            }
            else if (__get_mutant()==1) {
            {
                if ((__is_neg(8, &(e), sizeof (e), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in), sizeof (in), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
                    return;
                e = e->next;
            }
            }
            else if (__get_mutant()==2) {
            {
                memset(e, 0, sizeof (*(e)));
                e = e->next;
            }
            }
            else if (__get_mutant()==3) {
            {
                memset(e->next, 0, sizeof (*(e->next)));
                e = e->next;
            }
            }
            else if (__get_mutant()==4) {
            {
                if (!(__is_neg(8, &(e), sizeof (e), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in), sizeof (in), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
                    e = e->next;
            }
            }
            else if (__get_mutant()==5) {
            {
                e = (in)->next;
            }
            }
            else if (__get_mutant()==6) {
            {
                e = (e)->next;
            }
            }
            else if (__get_mutant()==7) {
            {
                e = (e);
            }
            }
            else if (__get_mutant()==8) {
            {
                e = (in);
            }
            }
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 124:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    if ((__is_neg(8, &(e), sizeof (e), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in), sizeof (in), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
        break;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 125:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    if ((__is_neg(8, &(e), sizeof (e), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in), sizeof (in), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
        return;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
BasicTester, Testing instance id 197:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    memset(e, 0, sizeof (*(e)));
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 198:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    memset(e->next, 0, sizeof (*(e->next)));
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
CondTester, Testing instance id 126:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    if (!(__is_neg(8, &(e), sizeof (e), &(e->next), sizeof (e->next), &(v), sizeof (v), &(e->next->element), sizeof (e->next->element), &(l), sizeof (l), &(in), sizeof (in), &(e->next->next), sizeof (e->next->next), &(e->element), sizeof (e->element))))
        e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
BasicTester, Testing instance id 221:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (in)->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 222:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (e)->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 223:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (e);
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 224:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (in);
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            //prophet generated patch
            if (__get_mutant()==0) {
            {
                if ((__is_neg(4, &(in), sizeof (in), &(e), sizeof (e), &(v), sizeof (v), &(l), sizeof (l))))
                    return;
                break;
            }
            }
            else if (__get_mutant()==1) {
            {
                if ((__is_neg(4, &(in), sizeof (in), &(e), sizeof (e), &(v), sizeof (v), &(l), sizeof (l))))
                    break;
                break;
            }
            }
            else if (__get_mutant()==2) {
            {
                if (!(__is_neg(4, &(in), sizeof (in), &(e), sizeof (e), &(v), sizeof (v), &(l), sizeof (l))))
                    break;
            }
            }
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 121:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    if ((__is_neg(4, &(in), sizeof (in), &(e), sizeof (e), &(v), sizeof (v), &(l), sizeof (l))))
        return;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 122:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    if ((__is_neg(4, &(in), sizeof (in), &(e), sizeof (e), &(v), sizeof (v), &(l), sizeof (l))))
        break;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 123:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    if (!(__is_neg(4, &(in), sizeof (in), &(e), sizeof (e), &(v), sizeof (v), &(l), sizeof (l))))
        break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Branch 1: 0
Iteration 2
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 6
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 7
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 8
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 9
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    //prophet generated patch
    if (__get_mutant()==0) {
    e = (in)->next;
    e->next = in;
    }
    else if (__get_mutant()==1) {
    printf("%d ", (in)->next->element);
    e->next = in;
    }
    else if (__get_mutant()==2) {
    printf("%d ", (e)->next->element);
    e->next = in;
    }
    else if (__get_mutant()==3) {
    newNode(&in);
    e->next = in;
    }
    else if (__get_mutant()==4) {
    newNode(&(in));
    e->next = in;
    }
    else if (__get_mutant()==5) {
    newNode(&(e));
    e->next = in;
    }
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 260:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
e = (in)->next;
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 261:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
printf("%d ", (in)->next->element);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 262:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
printf("%d ", (e)->next->element);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 263:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
newNode(&in);
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 264:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
newNode(&(in));
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 265:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    
//Patch 0:
newNode(&(e));
e->next = in;

//CodeSeg 1:
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    //prophet generated patch
    if (__get_mutant()==0) {
    newList(&(l));
    }
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 220:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
newList(&(l));

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            //prophet generated patch
            if (__get_mutant()==0) {
            insertSort(&(l), atoi(x));
            }
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 213:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            
//Patch 0:
insertSort(&(l), atoi(x));

//CodeSeg 1:
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    fclose((f));
    }

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 217:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
fclose((f));

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    //prophet generated patch
    if (__get_mutant()==0) {
    node = (node);
    }
    else if (__get_mutant()==1) {
    node = (l)->head;
    }
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 215:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = (node);

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 216:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = (l)->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        //prophet generated patch
        if (__get_mutant()==0) {
        printf("%d ", (node)->next->element);
        }
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 201:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        
//Patch 0:
printf("%d ", (node)->next->element);

//CodeSeg 1:
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        //prophet generated patch
        if (__get_mutant()==0) {
        fclose((f));
        node = node->next;
        }
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 243:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        
//Patch 0:
fclose((f));
node = node->next;

//CodeSeg 1:
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    printf(" %d", (l)->size);
    }
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 214:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf(" %d", (l)->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
Counter: 412
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
e->next = (e);
in->next = e->next;


BasicTester, a patch instance with id 282:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e->next = (e);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 412
Going to sync the batch tester, clear all existing tasks!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    e->next = (e);
    in->next = e->next;
    }
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 282:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e->next = (e);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 413
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
e = e->next;
in->next = e->next;


BasicTester, a patch instance with id 283:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e = e->next;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 413
Counter: 414
Batcher Size:1
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
e = (in)->next;
in->next = e->next;


BasicTester, a patch instance with id 284:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e = (in)->next;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 414
Counter: 415
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
e = (in);
in->next = e->next;


BasicTester, a patch instance with id 285:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e = (in);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 415
Counter: 416
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
e = (e);
in->next = e->next;


BasicTester, a patch instance with id 286:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e = (e);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 416
Counter: 417
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority -3
At location prog.c:44
--Src File: prog.c
Fragment 0:
e = (e)->next;
in->next = e->next;


BasicTester, a patch instance with id 287:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e = (e)->next;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 417
Counter: 418
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
printf("%d ", (in)->next->element);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 288:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
printf("%d ", (in)->next->element);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 418
Counter: 419
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
printf("%d ", (e)->next->element);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 289:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
printf("%d ", (e)->next->element);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 419
Counter: 420
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
newNode(&in);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 290:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
newNode(&in);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 420
Counter: 421
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
newNode(&(e));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 291:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
newNode(&(e));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 421
Counter: 422
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 292:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
newNode(&((*(l))->head));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 422
Counter: 423
Batcher Size:10
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
in->next = (e)->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 293:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->next = (e)->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 423
Counter: 424
Batcher Size:11
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
in->next = (e);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 294:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->next = (e);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 424
Counter: 425
Batcher Size:12
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
in->element = v;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 295:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->element = v;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 425
Counter: 426
Batcher Size:13
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
in->element = (v);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 296:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->element = (v);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 426
Counter: 427
Batcher Size:14
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
in->element = (0);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 297:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->element = (0);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 427
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    //prophet generated patch
    if (__get_mutant()==0) {
    printf("%d ", (in)->next->element);
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==1) {
    printf("%d ", (e)->next->element);
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==2) {
    newNode(&in);
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==3) {
    newNode(&(e));
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==4) {
    newNode(&((*(l))->head));
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==5) {
    in->next = (e)->next;
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==6) {
    in->next = (e);
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==7) {
    in->element = v;
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==8) {
    in->element = (v);
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==9) {
    in->element = (0);
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 288:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
printf("%d ", (in)->next->element);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 289:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
printf("%d ", (e)->next->element);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 290:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
newNode(&in);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 291:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
newNode(&(e));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 292:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
newNode(&((*(l))->head));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 293:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->next = (e)->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 294:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->next = (e);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 295:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->element = v;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 296:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->element = (v);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 297:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->element = (0);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 428
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
e->next = in;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 298:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e->next = in;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 428
Counter: 429
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
e->next = (in);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 299:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e->next = (in);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 429
Counter: 430
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
e->next = (e);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 300:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e->next = (e);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 430
Counter: 431
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
e = e->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 301:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e = e->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 431
Counter: 432
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
e = (in)->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 302:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e = (in)->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 432
Counter: 433
Batcher Size:10
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
e = (in);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 303:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e = (in);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 433
Counter: 434
Batcher Size:11
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
e = (e)->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 304:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e = (e)->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 434
Counter: 435
Batcher Size:12
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
newNode(&(in));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 305:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
newNode(&(in));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 435
Counter: 436
Batcher Size:13
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
e = (e);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 306:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e = (e);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 436
Counter: 437
Batcher Size:14
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
in->next = e->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 307:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->next = e->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 437
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    //prophet generated patch
    if (__get_mutant()==0) {
    e->next = in;
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==1) {
    e->next = (in);
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==2) {
    e->next = (e);
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==3) {
    e = e->next;
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==4) {
    e = (in)->next;
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==5) {
    e = (in);
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==6) {
    e = (e)->next;
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==7) {
    newNode(&(in));
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==8) {
    e = (e);
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==9) {
    in->next = e->next;
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 298:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e->next = in;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 299:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e->next = (in);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 300:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e->next = (e);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 301:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e = e->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 302:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e = (in)->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 303:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e = (in);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 304:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e = (e)->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 305:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
newNode(&(in));
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 306:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
e = (e);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 307:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->next = e->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 438
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
in->next = (in)->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 308:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->next = (in)->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 438
Counter: 439
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority -4
At location prog.c:38
--Src File: prog.c
Fragment 0:
in->next = (in);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }


BasicTester, a patch instance with id 309:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->next = (in);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 439
Counter: 440
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority -5
At location prog.c:37
--Src File: prog.c
Fragment 0:
in->element = v;
struct Entry *e = (*l)->head;


BasicTester, a patch instance with id 310:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
in->element = v;
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 440
Counter: 441
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority -5
At location prog.c:37
--Src File: prog.c
Fragment 0:
printf("%d ", (in)->next->element);
struct Entry *e = (*l)->head;


BasicTester, a patch instance with id 311:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
printf("%d ", (in)->next->element);
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 441
Counter: 442
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority -5
At location prog.c:37
--Src File: prog.c
Fragment 0:
newNode(&in);
struct Entry *e = (*l)->head;


BasicTester, a patch instance with id 312:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
newNode(&in);
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 442
Counter: 443
Batcher Size:10
Preprocess the following candidate with BasicTester:
Priority -5
At location prog.c:37
--Src File: prog.c
Fragment 0:
newNode(&(in));
struct Entry *e = (*l)->head;


BasicTester, a patch instance with id 313:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
newNode(&(in));
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 443
Counter: 444
Batcher Size:11
Preprocess the following candidate with BasicTester:
Priority -5
At location prog.c:37
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
struct Entry *e = (*l)->head;


BasicTester, a patch instance with id 314:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
newNode(&((*(l))->head));
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 444
Counter: 445
Batcher Size:12
Preprocess the following candidate with BasicTester:
Priority -5
At location prog.c:37
--Src File: prog.c
Fragment 0:
in->next = (in)->next;
struct Entry *e = (*l)->head;


BasicTester, a patch instance with id 315:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
in->next = (in)->next;
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 445
Counter: 446
Batcher Size:13
Preprocess the following candidate with BasicTester:
Priority -5
At location prog.c:37
--Src File: prog.c
Fragment 0:
in->next = (in);
struct Entry *e = (*l)->head;


BasicTester, a patch instance with id 316:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
in->next = (in);
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 446
Counter: 447
Batcher Size:14
Preprocess the following candidate with BasicTester:
Priority -5
At location prog.c:37
--Src File: prog.c
Fragment 0:
in->element = (v);
struct Entry *e = (*l)->head;


BasicTester, a patch instance with id 317:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
in->element = (v);
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 447
Counter: 448
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority -5
At location prog.c:37
--Src File: prog.c
Fragment 0:
in->element = (0);
struct Entry *e = (*l)->head;


BasicTester, a patch instance with id 318:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
in->element = (0);
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 448
Counter: 449
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority -6
At location prog.c:36
--Src File: prog.c
Fragment 0:
in->element = (v);
in->element = v;


BasicTester, a patch instance with id 319:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->element = (v);
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 449
Counter: 450
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority -6
At location prog.c:36
--Src File: prog.c
Fragment 0:
in->element = (0);
in->element = v;


BasicTester, a patch instance with id 320:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->element = (0);
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 450
Counter: 451
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority -6
At location prog.c:36
--Src File: prog.c
Fragment 0:
newNode(&in);
in->element = v;


BasicTester, a patch instance with id 321:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
newNode(&in);
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 451
Counter: 452
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority -6
At location prog.c:36
--Src File: prog.c
Fragment 0:
newNode(&(in));
in->element = v;


BasicTester, a patch instance with id 322:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
newNode(&(in));
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 452
Counter: 453
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority -6
At location prog.c:36
--Src File: prog.c
Fragment 0:
in->element = v;
in->element = v;


BasicTester, a patch instance with id 323:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->element = v;
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 453
Counter: 454
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority -6
At location prog.c:36
--Src File: prog.c
Fragment 0:
in->next = (in);
in->element = v;


BasicTester, a patch instance with id 324:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->next = (in);
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 454
Counter: 455
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority -6
At location prog.c:36
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
in->element = v;


BasicTester, a patch instance with id 325:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
newNode(&((*(l))->head));
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 455
Counter: 456
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority -6
At location prog.c:36
--Src File: prog.c
Fragment 0:
printf("%d ", (in)->next->element);
in->element = v;


BasicTester, a patch instance with id 326:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
printf("%d ", (in)->next->element);
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 456
Counter: 457
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority -6
At location prog.c:36
--Src File: prog.c
Fragment 0:
in->next = (in)->next;
in->element = v;


BasicTester, a patch instance with id 327:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->next = (in)->next;
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 457
Counter: 458
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority -8
At location prog.c:34
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
struct Entry *in;


BasicTester, a patch instance with id 328:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    
//Patch 0:
newNode(&((*(l))->head));
struct Entry *in;

//CodeSeg 1:
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 458
Counter: 459
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
node = (l)->head;
return 0;


BasicTester, a patch instance with id 329:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
node = (l)->head;
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 459
Counter: 460
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
node = (node);
return 0;


BasicTester, a patch instance with id 330:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
node = (node);
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 460
Counter: 461
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
return 0;


BasicTester, a patch instance with id 331:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if (argc < 2)
    return 0;
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 461
Counter: 462
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);
return 0;


BasicTester, a patch instance with id 332:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
printf(" %d", l->size);
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 462
Counter: 463
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
insertSort(&l, atoi(x));
return 0;


BasicTester, a patch instance with id 333:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
insertSort(&l, atoi(x));
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 463
Counter: 464
Batcher Size:31
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
fclose((f));
return 0;


BasicTester, a patch instance with id 334:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
fclose((f));
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 464
Counter: 465
Batcher Size:32
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
printf("%d ", (node)->next->element);
return 0;


BasicTester, a patch instance with id 335:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
printf("%d ", (node)->next->element);
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 465
Counter: 466
Batcher Size:33
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
printf("%d ", node->next->element);
return 0;


BasicTester, a patch instance with id 336:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
printf("%d ", node->next->element);
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 466
Counter: 467
Batcher Size:34
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
node = l->head;
return 0;


BasicTester, a patch instance with id 337:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
node = l->head;
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 467
Counter: 468
Batcher Size:35
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
newNode(&(node));
return 0;


BasicTester, a patch instance with id 338:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
newNode(&(node));
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 468
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    //prophet generated patch
    if (__get_mutant()==0) {
    node = (l)->head;
    return 0;
    }
    else if (__get_mutant()==1) {
    node = (node);
    return 0;
    }
    else if (__get_mutant()==2) {
    if (argc < 2)
        return 0;
    return 0;
    }
    else if (__get_mutant()==3) {
    printf(" %d", l->size);
    return 0;
    }
    else if (__get_mutant()==4) {
    insertSort(&l, atoi(x));
    return 0;
    }
    else if (__get_mutant()==5) {
    fclose((f));
    return 0;
    }
    else if (__get_mutant()==6) {
    printf("%d ", (node)->next->element);
    return 0;
    }
    else if (__get_mutant()==7) {
    printf("%d ", node->next->element);
    return 0;
    }
    else if (__get_mutant()==8) {
    node = l->head;
    return 0;
    }
    else if (__get_mutant()==9) {
    newNode(&(node));
    return 0;
    }


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 329:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
node = (l)->head;
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 330:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
node = (node);
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 331:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if (argc < 2)
    return 0;
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 332:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
printf(" %d", l->size);
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 333:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
insertSort(&l, atoi(x));
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 334:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
fclose((f));
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 335:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
printf("%d ", (node)->next->element);
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 336:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
printf("%d ", node->next->element);
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 337:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
node = l->head;
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 338:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
newNode(&(node));
return 0;

//CodeSeg 1:


}

Testing negative cases!
Counter: 469
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
insertSort(&(l), atoi(x));
return 0;


BasicTester, a patch instance with id 339:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
insertSort(&(l), atoi(x));
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 469
Counter: 470
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
newList(&(l));
return 0;


BasicTester, a patch instance with id 340:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
newList(&(l));
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 470
Counter: 471
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
fclose(f);
return 0;


BasicTester, a patch instance with id 341:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
fclose(f);
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 471
Counter: 472
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
return 0;


BasicTester, a patch instance with id 342:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
printf(" %d", (l)->size);
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 472
Counter: 473
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
return 0;


BasicTester, a patch instance with id 343:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if (f == ((void *)0))
    return 0;
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 473
Counter: 474
Batcher Size:31
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
node = node->next;
return 0;


BasicTester, a patch instance with id 344:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
node = node->next;
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 474
Counter: 475
Batcher Size:32
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
newList(&l);
return 0;


BasicTester, a patch instance with id 345:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
newList(&l);
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 475
Counter: 476
Batcher Size:33
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
return 0;


BasicTester, a patch instance with id 346:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 476
Counter: 477
Batcher Size:34
Preprocess the following candidate with BasicTester:
Priority -10
At location prog.c:72
--Src File: prog.c
Fragment 0:
node = (node)->next;
return 0;


BasicTester, a patch instance with id 347:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
node = (node)->next;
return 0;

//CodeSeg 1:


}

Spawn 1 instances, now Total 477
Counter: 478
Batcher Size:35
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
printf(" %d", l->size);


BasicTester, a patch instance with id 348:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if (f == ((void *)0))
    return 0;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 478
Counter: 479
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
printf(" %d", l->size);


BasicTester, a patch instance with id 349:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 479
Counter: 480
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
fclose((f));
printf(" %d", l->size);


BasicTester, a patch instance with id 350:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
fclose((f));
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 480
Counter: 481
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
newList(&l);
printf(" %d", l->size);


BasicTester, a patch instance with id 351:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
newList(&l);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 481
Counter: 482
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
newList(&(l));
printf(" %d", l->size);


BasicTester, a patch instance with id 352:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
newList(&(l));
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 482
Counter: 483
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
insertSort(&l, atoi(x));
printf(" %d", l->size);


BasicTester, a patch instance with id 353:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
insertSort(&l, atoi(x));
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 483
Counter: 484
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
node = (l)->head;
printf(" %d", l->size);


BasicTester, a patch instance with id 354:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
node = (l)->head;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 484
Counter: 485
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
node = node->next;
printf(" %d", l->size);


BasicTester, a patch instance with id 355:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
node = node->next;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 485
Counter: 486
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);
printf(" %d", l->size);


BasicTester, a patch instance with id 356:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf(" %d", l->size);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 486
Counter: 487
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
printf("%d ", node->next->element);
printf(" %d", l->size);


BasicTester, a patch instance with id 357:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf("%d ", node->next->element);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 487
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    if (f == ((void *)0))
        return 0;
    printf(" %d", l->size);
    }
    else if (__get_mutant()==1) {
    if (x[0] != '"') {
        insertSort(&l, atoi(x));
    }
    printf(" %d", l->size);
    }
    else if (__get_mutant()==2) {
    fclose((f));
    printf(" %d", l->size);
    }
    else if (__get_mutant()==3) {
    newList(&l);
    printf(" %d", l->size);
    }
    else if (__get_mutant()==4) {
    newList(&(l));
    printf(" %d", l->size);
    }
    else if (__get_mutant()==5) {
    insertSort(&l, atoi(x));
    printf(" %d", l->size);
    }
    else if (__get_mutant()==6) {
    node = (l)->head;
    printf(" %d", l->size);
    }
    else if (__get_mutant()==7) {
    node = node->next;
    printf(" %d", l->size);
    }
    else if (__get_mutant()==8) {
    printf(" %d", l->size);
    printf(" %d", l->size);
    }
    else if (__get_mutant()==9) {
    printf("%d ", node->next->element);
    printf(" %d", l->size);
    }
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 348:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if (f == ((void *)0))
    return 0;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 349:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 350:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
fclose((f));
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 351:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
newList(&l);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 352:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
newList(&(l));
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 353:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
insertSort(&l, atoi(x));
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 354:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
node = (l)->head;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 355:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
node = node->next;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 356:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf(" %d", l->size);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 357:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf("%d ", node->next->element);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
Counter: 488
Batcher Size:35
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
printf("%d ", (node)->next->element);
printf(" %d", l->size);


BasicTester, a patch instance with id 358:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf("%d ", (node)->next->element);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 488
Counter: 489
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
printf(" %d", l->size);


BasicTester, a patch instance with id 359:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf(" %d", (l)->size);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 489
Counter: 490
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
node = l->head;
printf(" %d", l->size);


BasicTester, a patch instance with id 360:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
node = l->head;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 490
Counter: 491
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
newNode(&(node));
printf(" %d", l->size);


BasicTester, a patch instance with id 361:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
newNode(&(node));
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 491
Counter: 492
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
insertSort(&(l), atoi(x));
printf(" %d", l->size);


BasicTester, a patch instance with id 362:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
insertSort(&(l), atoi(x));
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 492
Counter: 493
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
fclose(f);
printf(" %d", l->size);


BasicTester, a patch instance with id 363:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
fclose(f);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 493
Counter: 494
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
node = (node)->next;
printf(" %d", l->size);


BasicTester, a patch instance with id 364:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
node = (node)->next;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 494
Counter: 495
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
printf(" %d", l->size);


BasicTester, a patch instance with id 365:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if (argc < 2)
    return 0;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 495
Counter: 496
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority -11
At location prog.c:71
--Src File: prog.c
Fragment 0:
node = (node);
printf(" %d", l->size);


BasicTester, a patch instance with id 366:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
node = (node);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Spawn 1 instances, now Total 496
Counter: 497
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
node = (node);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 367:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
node = (node);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 497
Counter: 498
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
printf("%d ", node->next->element);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 368:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
printf("%d ", node->next->element);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 498
Counter: 499
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
printf("%d ", (node)->next->element);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 369:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
printf("%d ", (node)->next->element);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 499
Going to sync the batch tester, clear all existing tasks!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    //prophet generated patch
    if (__get_mutant()==0) {
    newNode(&((*(l))->head));
    struct Entry *in;
    }
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building failed! Going to build saperately!
BasicTester, Testing instance id 328:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    
//Patch 0:
newNode(&((*(l))->head));
struct Entry *in;

//CodeSeg 1:
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    //prophet generated patch
    if (__get_mutant()==0) {
    in->element = (v);
    in->element = v;
    }
    else if (__get_mutant()==1) {
    in->element = (0);
    in->element = v;
    }
    else if (__get_mutant()==2) {
    newNode(&in);
    in->element = v;
    }
    else if (__get_mutant()==3) {
    newNode(&(in));
    in->element = v;
    }
    else if (__get_mutant()==4) {
    in->element = v;
    in->element = v;
    }
    else if (__get_mutant()==5) {
    in->next = (in);
    in->element = v;
    }
    else if (__get_mutant()==6) {
    newNode(&((*(l))->head));
    in->element = v;
    }
    else if (__get_mutant()==7) {
    printf("%d ", (in)->next->element);
    in->element = v;
    }
    else if (__get_mutant()==8) {
    in->next = (in)->next;
    in->element = v;
    }
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 319:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->element = (v);
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 320:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->element = (0);
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 321:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
newNode(&in);
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 322:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
newNode(&(in));
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 323:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->element = v;
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 324:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->next = (in);
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 325:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
newNode(&((*(l))->head));
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 326:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
printf("%d ", (in)->next->element);
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 327:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    
//Patch 0:
in->next = (in)->next;
in->element = v;

//CodeSeg 1:
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    //prophet generated patch
    if (__get_mutant()==0) {
    in->element = v;
    struct Entry *e = (*l)->head;
    }
    else if (__get_mutant()==1) {
    printf("%d ", (in)->next->element);
    struct Entry *e = (*l)->head;
    }
    else if (__get_mutant()==2) {
    newNode(&in);
    struct Entry *e = (*l)->head;
    }
    else if (__get_mutant()==3) {
    newNode(&(in));
    struct Entry *e = (*l)->head;
    }
    else if (__get_mutant()==4) {
    newNode(&((*(l))->head));
    struct Entry *e = (*l)->head;
    }
    else if (__get_mutant()==5) {
    in->next = (in)->next;
    struct Entry *e = (*l)->head;
    }
    else if (__get_mutant()==6) {
    in->next = (in);
    struct Entry *e = (*l)->head;
    }
    else if (__get_mutant()==7) {
    in->element = (v);
    struct Entry *e = (*l)->head;
    }
    else if (__get_mutant()==8) {
    in->element = (0);
    struct Entry *e = (*l)->head;
    }
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building failed! Going to build saperately!
BasicTester, Testing instance id 310:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
in->element = v;
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 311:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
printf("%d ", (in)->next->element);
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 312:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
newNode(&in);
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 313:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
newNode(&(in));
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 314:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
newNode(&((*(l))->head));
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 315:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
in->next = (in)->next;
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 316:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
in->next = (in);
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 317:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
in->element = (v);
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 318:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    
//Patch 0:
in->element = (0);
struct Entry *e = (*l)->head;

//CodeSeg 1:
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    //prophet generated patch
    if (__get_mutant()==0) {
    in->next = (in)->next;
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    else if (__get_mutant()==1) {
    in->next = (in);
    while (e->next != (*l)->head)
        {
            if (e->next->element < v)
                e = e->next;
            else
                break;
        }
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 308:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->next = (in)->next;
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 309:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    
//Patch 0:
in->next = (in);
while (e->next != (*l)->head)
    {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }

//CodeSeg 1:
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    e = e->next;
    in->next = e->next;
    }
    else if (__get_mutant()==1) {
    e = (in)->next;
    in->next = e->next;
    }
    else if (__get_mutant()==2) {
    e = (in);
    in->next = e->next;
    }
    else if (__get_mutant()==3) {
    e = (e);
    in->next = e->next;
    }
    else if (__get_mutant()==4) {
    e = (e)->next;
    in->next = e->next;
    }
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 283:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e = e->next;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 284:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e = (in)->next;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 285:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e = (in);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 286:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e = (e);
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 287:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    
//Patch 0:
e = (e)->next;
in->next = e->next;

//CodeSeg 1:
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    //prophet generated patch
    if (__get_mutant()==0) {
    node = (node);
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==1) {
    printf("%d ", node->next->element);
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==2) {
    printf("%d ", (node)->next->element);
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 367:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
node = (node);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 368:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
printf("%d ", node->next->element);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 369:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
printf("%d ", (node)->next->element);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    printf("%d ", (node)->next->element);
    printf(" %d", l->size);
    }
    else if (__get_mutant()==1) {
    printf(" %d", (l)->size);
    printf(" %d", l->size);
    }
    else if (__get_mutant()==2) {
    node = l->head;
    printf(" %d", l->size);
    }
    else if (__get_mutant()==3) {
    newNode(&(node));
    printf(" %d", l->size);
    }
    else if (__get_mutant()==4) {
    insertSort(&(l), atoi(x));
    printf(" %d", l->size);
    }
    else if (__get_mutant()==5) {
    fclose(f);
    printf(" %d", l->size);
    }
    else if (__get_mutant()==6) {
    node = (node)->next;
    printf(" %d", l->size);
    }
    else if (__get_mutant()==7) {
    if (argc < 2)
        return 0;
    printf(" %d", l->size);
    }
    else if (__get_mutant()==8) {
    node = (node);
    printf(" %d", l->size);
    }
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 358:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf("%d ", (node)->next->element);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 359:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
printf(" %d", (l)->size);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 360:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
node = l->head;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 361:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
newNode(&(node));
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 362:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
insertSort(&(l), atoi(x));
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 363:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
fclose(f);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 364:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
node = (node)->next;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 365:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
if (argc < 2)
    return 0;
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 366:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    
//Patch 0:
node = (node);
printf(" %d", l->size);

//CodeSeg 1:
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    //prophet generated patch
    if (__get_mutant()==0) {
    insertSort(&(l), atoi(x));
    return 0;
    }
    else if (__get_mutant()==1) {
    newList(&(l));
    return 0;
    }
    else if (__get_mutant()==2) {
    fclose(f);
    return 0;
    }
    else if (__get_mutant()==3) {
    printf(" %d", (l)->size);
    return 0;
    }
    else if (__get_mutant()==4) {
    if (f == ((void *)0))
        return 0;
    return 0;
    }
    else if (__get_mutant()==5) {
    node = node->next;
    return 0;
    }
    else if (__get_mutant()==6) {
    newList(&l);
    return 0;
    }
    else if (__get_mutant()==7) {
    if (x[0] != '"') {
        insertSort(&l, atoi(x));
    }
    return 0;
    }
    else if (__get_mutant()==8) {
    node = (node)->next;
    return 0;
    }


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 339:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
insertSort(&(l), atoi(x));
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 340:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
newList(&(l));
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 341:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
fclose(f);
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 342:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
printf(" %d", (l)->size);
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 343:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if (f == ((void *)0))
    return 0;
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 344:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
node = node->next;
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 345:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
newList(&l);
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 346:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
return 0;

//CodeSeg 1:


}

Testing negative cases!
BasicTester, Testing instance id 347:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    
//Patch 0:
node = (node)->next;
return 0;

//CodeSeg 1:


}

Testing negative cases!
Counter: 500
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 370:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 500
Counter: 501
Batcher Size:1
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
node = (l)->head;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 371:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
node = (l)->head;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 501
Counter: 502
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
newList(&l);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 372:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
newList(&l);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 502
Counter: 503
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 373:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if (f == ((void *)0))
    return 0;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 503
Counter: 504
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 374:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if (argc < 2)
    return 0;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 504
Counter: 505
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
fclose((f));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 375:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
fclose((f));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 505
Counter: 506
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
fclose(f);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 376:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
fclose(f);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 506
Counter: 507
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 377:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
printf(" %d", (l)->size);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 507
Counter: 508
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
newList(&(l));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 378:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
newList(&(l));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 508
Counter: 509
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
node = (node)->next;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 379:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
node = (node)->next;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 509
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    //prophet generated patch
    if (__get_mutant()==0) {
    if (x[0] != '"') {
        insertSort(&l, atoi(x));
    }
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==1) {
    node = (l)->head;
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==2) {
    newList(&l);
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==3) {
    if (f == ((void *)0))
        return 0;
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==4) {
    if (argc < 2)
        return 0;
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==5) {
    fclose((f));
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==6) {
    fclose(f);
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==7) {
    printf(" %d", (l)->size);
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==8) {
    newList(&(l));
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==9) {
    node = (node)->next;
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 370:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 371:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
node = (l)->head;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 372:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
newList(&l);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 373:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if (f == ((void *)0))
    return 0;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 374:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
if (argc < 2)
    return 0;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 375:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
fclose((f));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 376:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
fclose(f);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 377:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
printf(" %d", (l)->size);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 378:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
newList(&(l));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 379:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
node = (node)->next;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 510
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
newNode(&(node));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 380:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
newNode(&(node));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 510
Counter: 511
Batcher Size:1
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 381:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
printf(" %d", l->size);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 511
Counter: 512
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
insertSort(&(l), atoi(x));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 382:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
insertSort(&(l), atoi(x));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 512
Counter: 513
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
node = node->next;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 383:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
node = node->next;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 513
Counter: 514
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
node = l->head;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 384:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
node = l->head;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 514
Counter: 515
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority -12
At location prog.c:67
--Src File: prog.c
Fragment 0:
insertSort(&l, atoi(x));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }


BasicTester, a patch instance with id 385:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
insertSort(&l, atoi(x));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 515
Counter: 516
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
fclose(f);
node = l->head;


BasicTester, a patch instance with id 386:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
fclose(f);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 516
Counter: 517
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
node = l->head;


BasicTester, a patch instance with id 387:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if (argc < 2)
    return 0;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 517
Counter: 518
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
newNode(&(node));
node = l->head;


BasicTester, a patch instance with id 388:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
newNode(&(node));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 518
Counter: 519
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
node = (node);
node = l->head;


BasicTester, a patch instance with id 389:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = (node);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 519
Counter: 520
Batcher Size:10
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
printf("%d ", node->next->element);
node = l->head;


BasicTester, a patch instance with id 390:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
printf("%d ", node->next->element);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 520
Counter: 521
Batcher Size:11
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
printf("%d ", (node)->next->element);
node = l->head;


BasicTester, a patch instance with id 391:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
printf("%d ", (node)->next->element);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 521
Counter: 522
Batcher Size:12
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);
node = l->head;


BasicTester, a patch instance with id 392:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
printf(" %d", l->size);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 522
Counter: 523
Batcher Size:13
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
node = l->head;


BasicTester, a patch instance with id 393:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
printf(" %d", (l)->size);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 523
Counter: 524
Batcher Size:14
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
node = l->head;
node = l->head;


BasicTester, a patch instance with id 394:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = l->head;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 524
Counter: 525
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
node = (node)->next;
node = l->head;


BasicTester, a patch instance with id 395:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = (node)->next;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 525
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    //prophet generated patch
    if (__get_mutant()==0) {
    fclose(f);
    node = l->head;
    }
    else if (__get_mutant()==1) {
    if (argc < 2)
        return 0;
    node = l->head;
    }
    else if (__get_mutant()==2) {
    newNode(&(node));
    node = l->head;
    }
    else if (__get_mutant()==3) {
    node = (node);
    node = l->head;
    }
    else if (__get_mutant()==4) {
    printf("%d ", node->next->element);
    node = l->head;
    }
    else if (__get_mutant()==5) {
    printf("%d ", (node)->next->element);
    node = l->head;
    }
    else if (__get_mutant()==6) {
    printf(" %d", l->size);
    node = l->head;
    }
    else if (__get_mutant()==7) {
    printf(" %d", (l)->size);
    node = l->head;
    }
    else if (__get_mutant()==8) {
    node = l->head;
    node = l->head;
    }
    else if (__get_mutant()==9) {
    node = (node)->next;
    node = l->head;
    }
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 386:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
fclose(f);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 387:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if (argc < 2)
    return 0;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 388:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
newNode(&(node));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 389:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = (node);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 390:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
printf("%d ", node->next->element);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 391:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
printf("%d ", (node)->next->element);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 392:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
printf(" %d", l->size);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 393:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
printf(" %d", (l)->size);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 394:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = l->head;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 395:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = (node)->next;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 526
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
newList(&(l));
node = l->head;


BasicTester, a patch instance with id 396:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
newList(&(l));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 526
Counter: 527
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
newList(&l);
node = l->head;


BasicTester, a patch instance with id 397:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
newList(&l);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 527
Counter: 528
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
insertSort(&l, atoi(x));
node = l->head;


BasicTester, a patch instance with id 398:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
insertSort(&l, atoi(x));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 528
Counter: 529
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
node = (l)->head;
node = l->head;


BasicTester, a patch instance with id 399:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = (l)->head;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 529
Counter: 530
Batcher Size:10
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
node = node->next;
node = l->head;


BasicTester, a patch instance with id 400:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = node->next;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 530
Counter: 531
Batcher Size:11
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
node = l->head;


BasicTester, a patch instance with id 401:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if (f == ((void *)0))
    return 0;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 531
Counter: 532
Batcher Size:12
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
insertSort(&(l), atoi(x));
node = l->head;


BasicTester, a patch instance with id 402:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
insertSort(&(l), atoi(x));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 532
Counter: 533
Batcher Size:13
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
node = l->head;


BasicTester, a patch instance with id 403:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 533
Counter: 534
Batcher Size:14
Preprocess the following candidate with BasicTester:
Priority -13
At location prog.c:66
--Src File: prog.c
Fragment 0:
fclose((f));
node = l->head;


BasicTester, a patch instance with id 404:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
fclose((f));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 534
Counter: 535
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
node = (l)->head;
fclose(f);


BasicTester, a patch instance with id 405:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
node = (l)->head;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 535
Counter: 536
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
printf("%d ", (node)->next->element);
fclose(f);


BasicTester, a patch instance with id 406:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
printf("%d ", (node)->next->element);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 536
Counter: 537
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
printf("%d ", node->next->element);
fclose(f);


BasicTester, a patch instance with id 407:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
printf("%d ", node->next->element);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 537
Counter: 538
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);
fclose(f);


BasicTester, a patch instance with id 408:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
printf(" %d", l->size);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 538
Counter: 539
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
insertSort(&(l), atoi(x));
fclose(f);


BasicTester, a patch instance with id 409:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
insertSort(&(l), atoi(x));
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 539
Counter: 540
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
fclose(f);


BasicTester, a patch instance with id 410:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if (f == ((void *)0))
    return 0;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 540
Counter: 541
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
fclose(f);


BasicTester, a patch instance with id 411:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if (argc < 2)
    return 0;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 541
Counter: 542
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
fclose((f));
fclose(f);


BasicTester, a patch instance with id 412:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
fclose((f));
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 542
Counter: 543
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
node = (node)->next;
fclose(f);


BasicTester, a patch instance with id 413:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
node = (node)->next;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 543
Counter: 544
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
fclose(f);
fclose(f);


BasicTester, a patch instance with id 414:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
fclose(f);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 544
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    node = (l)->head;
    fclose(f);
    }
    else if (__get_mutant()==1) {
    printf("%d ", (node)->next->element);
    fclose(f);
    }
    else if (__get_mutant()==2) {
    printf("%d ", node->next->element);
    fclose(f);
    }
    else if (__get_mutant()==3) {
    printf(" %d", l->size);
    fclose(f);
    }
    else if (__get_mutant()==4) {
    insertSort(&(l), atoi(x));
    fclose(f);
    }
    else if (__get_mutant()==5) {
    if (f == ((void *)0))
        return 0;
    fclose(f);
    }
    else if (__get_mutant()==6) {
    if (argc < 2)
        return 0;
    fclose(f);
    }
    else if (__get_mutant()==7) {
    fclose((f));
    fclose(f);
    }
    else if (__get_mutant()==8) {
    node = (node)->next;
    fclose(f);
    }
    else if (__get_mutant()==9) {
    fclose(f);
    fclose(f);
    }

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 405:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
node = (l)->head;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 406:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
printf("%d ", (node)->next->element);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 407:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
printf("%d ", node->next->element);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 408:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
printf(" %d", l->size);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 409:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
insertSort(&(l), atoi(x));
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 410:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if (f == ((void *)0))
    return 0;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 411:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if (argc < 2)
    return 0;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 412:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
fclose((f));
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 413:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
node = (node)->next;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 414:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
fclose(f);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 545
Batcher Size:15
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
newNode(&(node));
fclose(f);


BasicTester, a patch instance with id 415:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
newNode(&(node));
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 545
Counter: 546
Batcher Size:16
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
newList(&l);
fclose(f);


BasicTester, a patch instance with id 416:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
newList(&l);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 546
Counter: 547
Batcher Size:17
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
newList(&(l));
fclose(f);


BasicTester, a patch instance with id 417:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
newList(&(l));
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 547
Counter: 548
Batcher Size:18
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
insertSort(&l, atoi(x));
fclose(f);


BasicTester, a patch instance with id 418:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
insertSort(&l, atoi(x));
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 548
Counter: 549
Batcher Size:19
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
node = l->head;
fclose(f);


BasicTester, a patch instance with id 419:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
node = l->head;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 549
Counter: 550
Batcher Size:20
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
fclose(f);


BasicTester, a patch instance with id 420:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 550
Counter: 551
Batcher Size:21
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
node = (node);
fclose(f);


BasicTester, a patch instance with id 421:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
node = (node);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 551
Counter: 552
Batcher Size:22
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
fclose(f);


BasicTester, a patch instance with id 422:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
printf(" %d", (l)->size);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 552
Counter: 553
Batcher Size:23
Preprocess the following candidate with BasicTester:
Priority -14
At location prog.c:64
--Src File: prog.c
Fragment 0:
node = node->next;
fclose(f);


BasicTester, a patch instance with id 423:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
node = node->next;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 553
Counter: 554
Batcher Size:24
Preprocess the following candidate with BasicTester:
Priority -16
At location prog.c:30
--Src File: prog.c
Fragment 0:
*n = malloc(sizeof(struct Entry));
(*n)->next = ((void *)0);


BasicTester, a patch instance with id 424:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    
//Patch 0:
*n = malloc(sizeof(struct Entry));
(*n)->next = ((void *)0);

//CodeSeg 1:
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 554
Counter: 555
Batcher Size:25
Preprocess the following candidate with BasicTester:
Priority -16
At location prog.c:30
--Src File: prog.c
Fragment 0:
(*n)->next = ((void *)0);
(*n)->next = ((void *)0);


BasicTester, a patch instance with id 425:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    
//Patch 0:
(*n)->next = ((void *)0);
(*n)->next = ((void *)0);

//CodeSeg 1:
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 555
Counter: 556
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 426:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 556
Counter: 557
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
newNode(&(node));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 427:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
newNode(&(node));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 557
Counter: 558
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
node = l->head;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 428:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
node = l->head;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 558
Counter: 559
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
insertSort(&l, atoi(x));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 429:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
insertSort(&l, atoi(x));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 559
Counter: 560
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
fclose((f));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 430:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
fclose((f));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 560
Counter: 561
Batcher Size:31
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
insertSort(&(l), atoi(x));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 431:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
insertSort(&(l), atoi(x));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 561
Counter: 562
Batcher Size:32
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
node = (l)->head;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 432:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
node = (l)->head;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 562
Counter: 563
Batcher Size:33
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
node = (node);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 433:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
node = (node);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 563
Counter: 564
Batcher Size:34
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
newList(&l);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 434:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
newList(&l);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 564
Counter: 565
Batcher Size:35
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
newList(&(l));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 435:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
newList(&(l));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 565
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    //prophet generated patch
    if (__get_mutant()==0) {
    if (x[0] != '"') {
        insertSort(&l, atoi(x));
    }
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==1) {
    newNode(&(node));
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==2) {
    node = l->head;
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==3) {
    insertSort(&l, atoi(x));
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==4) {
    fclose((f));
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==5) {
    insertSort(&(l), atoi(x));
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==6) {
    node = (l)->head;
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==7) {
    node = (node);
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==8) {
    newList(&l);
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==9) {
    newList(&(l));
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 426:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 427:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
newNode(&(node));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 428:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
node = l->head;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 429:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
insertSort(&l, atoi(x));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 430:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
fclose((f));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 431:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
insertSort(&(l), atoi(x));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 432:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
node = (l)->head;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 433:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
node = (node);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 434:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
newList(&l);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 435:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
newList(&(l));
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 566
Batcher Size:26
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 436:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if (f == ((void *)0))
    return 0;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 566
Counter: 567
Batcher Size:27
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 437:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if (argc < 2)
    return 0;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 567
Counter: 568
Batcher Size:28
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
printf("%d ", node->next->element);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 438:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
printf("%d ", node->next->element);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 568
Counter: 569
Batcher Size:29
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
node = node->next;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 439:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
node = node->next;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 569
Counter: 570
Batcher Size:30
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 440:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
printf(" %d", l->size);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 570
Counter: 571
Batcher Size:31
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
node = (node)->next;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 441:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
node = (node)->next;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 571
Counter: 572
Batcher Size:32
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
fclose(f);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 442:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
fclose(f);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 572
Counter: 573
Batcher Size:33
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
printf("%d ", (node)->next->element);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 443:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
printf("%d ", (node)->next->element);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 573
Counter: 574
Batcher Size:34
Preprocess the following candidate with BasicTester:
Priority -18
At location prog.c:58
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }


BasicTester, a patch instance with id 444:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
printf(" %d", (l)->size);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 574
Counter: 575
Batcher Size:35
Preprocess the following candidate with BasicTester:
Priority -19
At location prog.c:57
--Src File: prog.c
Fragment 0:
insertSort(&(l), atoi(x));
struct Entry *node;


BasicTester, a patch instance with id 445:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
insertSort(&(l), atoi(x));
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 575
Counter: 576
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -19
At location prog.c:57
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
struct Entry *node;


BasicTester, a patch instance with id 446:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if (argc < 2)
    return 0;
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 576
Counter: 577
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority -19
At location prog.c:57
--Src File: prog.c
Fragment 0:
newList(&l);
struct Entry *node;


BasicTester, a patch instance with id 447:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
newList(&l);
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 577
Counter: 578
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority -19
At location prog.c:57
--Src File: prog.c
Fragment 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
struct Entry *node;


BasicTester, a patch instance with id 448:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 578
Counter: 579
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority -19
At location prog.c:57
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
struct Entry *node;


BasicTester, a patch instance with id 449:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
printf(" %d", (l)->size);
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 579
Counter: 580
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority -19
At location prog.c:57
--Src File: prog.c
Fragment 0:
insertSort(&l, atoi(x));
struct Entry *node;


BasicTester, a patch instance with id 450:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
insertSort(&l, atoi(x));
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 580
Counter: 581
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority -19
At location prog.c:57
--Src File: prog.c
Fragment 0:
newList(&(l));
struct Entry *node;


BasicTester, a patch instance with id 451:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
newList(&(l));
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 581
Counter: 582
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority -19
At location prog.c:57
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);
struct Entry *node;


BasicTester, a patch instance with id 452:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
printf(" %d", l->size);
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 582
Counter: 583
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority -19
At location prog.c:57
--Src File: prog.c
Fragment 0:
fclose((f));
struct Entry *node;


BasicTester, a patch instance with id 453:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
fclose((f));
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 583
Counter: 584
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority -19
At location prog.c:57
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
struct Entry *node;


BasicTester, a patch instance with id 454:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if (f == ((void *)0))
    return 0;
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 584
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    //prophet generated patch
    if (__get_mutant()==0) {
    insertSort(&(l), atoi(x));
    struct Entry *node;
    }
    else if (__get_mutant()==1) {
    if (argc < 2)
        return 0;
    struct Entry *node;
    }
    else if (__get_mutant()==2) {
    newList(&l);
    struct Entry *node;
    }
    else if (__get_mutant()==3) {
    if (x[0] != '"') {
        insertSort(&l, atoi(x));
    }
    struct Entry *node;
    }
    else if (__get_mutant()==4) {
    printf(" %d", (l)->size);
    struct Entry *node;
    }
    else if (__get_mutant()==5) {
    insertSort(&l, atoi(x));
    struct Entry *node;
    }
    else if (__get_mutant()==6) {
    newList(&(l));
    struct Entry *node;
    }
    else if (__get_mutant()==7) {
    printf(" %d", l->size);
    struct Entry *node;
    }
    else if (__get_mutant()==8) {
    fclose((f));
    struct Entry *node;
    }
    else if (__get_mutant()==9) {
    if (f == ((void *)0))
        return 0;
    struct Entry *node;
    }
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building failed! Going to build saperately!
BasicTester, Testing instance id 445:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
insertSort(&(l), atoi(x));
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 446:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if (argc < 2)
    return 0;
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 447:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
newList(&l);
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 448:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 449:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
printf(" %d", (l)->size);
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 450:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
insertSort(&l, atoi(x));
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 451:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
newList(&(l));
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 452:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
printf(" %d", l->size);
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 453:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
fclose((f));
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 454:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
if (f == ((void *)0))
    return 0;
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 585
Batcher Size:35
Preprocess the following candidate with BasicTester:
Priority -19
At location prog.c:57
--Src File: prog.c
Fragment 0:
fclose(f);
struct Entry *node;


BasicTester, a patch instance with id 455:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
fclose(f);
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 585
Counter: 586
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -20
At location prog.c:56
--Src File: prog.c
Fragment 0:
newList(&l);
char x[20];


BasicTester, a patch instance with id 456:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
newList(&l);
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 586
BasicTester, Testing instance id 456:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
newList(&l);
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 587
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -20
At location prog.c:56
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
char x[20];


BasicTester, a patch instance with id 457:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
printf(" %d", (l)->size);
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 587
BasicTester, Testing instance id 457:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
printf(" %d", (l)->size);
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 588
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -20
At location prog.c:56
--Src File: prog.c
Fragment 0:
fclose((f));
char x[20];


BasicTester, a patch instance with id 458:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
fclose((f));
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 588
BasicTester, Testing instance id 458:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
fclose((f));
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 589
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -20
At location prog.c:56
--Src File: prog.c
Fragment 0:
newList(&(l));
char x[20];


BasicTester, a patch instance with id 459:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
newList(&(l));
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 589
BasicTester, Testing instance id 459:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
newList(&(l));
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 590
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -20
At location prog.c:56
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
char x[20];


BasicTester, a patch instance with id 460:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
if (f == ((void *)0))
    return 0;
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 590
BasicTester, Testing instance id 460:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
if (f == ((void *)0))
    return 0;
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 591
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -20
At location prog.c:56
--Src File: prog.c
Fragment 0:
fclose(f);
char x[20];


BasicTester, a patch instance with id 461:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
fclose(f);
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 591
BasicTester, Testing instance id 461:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
fclose(f);
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 592
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -20
At location prog.c:56
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
char x[20];


BasicTester, a patch instance with id 462:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
if (argc < 2)
    return 0;
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 592
BasicTester, Testing instance id 462:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
if (argc < 2)
    return 0;
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 593
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -20
At location prog.c:56
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);
char x[20];


BasicTester, a patch instance with id 463:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
printf(" %d", l->size);
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 593
BasicTester, Testing instance id 463:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    
//Patch 0:
printf(" %d", l->size);
char x[20];

//CodeSeg 1:
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 594
Batcher Size:36
Preprocess the following candidate with BasicTester:
Priority -21
At location prog.c:24
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*l)->head;
return;


BasicTester, a patch instance with id 464:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
(*l)->head->next = (*l)->head;
return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 594
Counter: 595
Batcher Size:37
Preprocess the following candidate with BasicTester:
Priority -21
At location prog.c:24
--Src File: prog.c
Fragment 0:
*l = malloc(sizeof(struct List));
return;


BasicTester, a patch instance with id 465:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
*l = malloc(sizeof(struct List));
return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 595
Counter: 596
Batcher Size:38
Preprocess the following candidate with BasicTester:
Priority -21
At location prog.c:24
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*(l))->head;
return;


BasicTester, a patch instance with id 466:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
(*l)->head->next = (*(l))->head;
return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 596
Counter: 597
Batcher Size:39
Preprocess the following candidate with BasicTester:
Priority -21
At location prog.c:24
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
return;


BasicTester, a patch instance with id 467:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
newNode(&((*(l))->head));
return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 597
Counter: 598
Batcher Size:40
Preprocess the following candidate with BasicTester:
Priority -21
At location prog.c:24
--Src File: prog.c
Fragment 0:
newNode(&((*l)->head));
return;


BasicTester, a patch instance with id 468:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
newNode(&((*l)->head));
return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 598
Counter: 599
Batcher Size:41
Preprocess the following candidate with BasicTester:
Priority -22
At location prog.c:23
--Src File: prog.c
Fragment 0:
*l = malloc(sizeof(struct List));
(*l)->head->next = (*l)->head;


BasicTester, a patch instance with id 469:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
*l = malloc(sizeof(struct List));
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 599
Counter: 600
Batcher Size:42
Preprocess the following candidate with BasicTester:
Priority -22
At location prog.c:23
--Src File: prog.c
Fragment 0:
newNode(&((*l)->head));
(*l)->head->next = (*l)->head;


BasicTester, a patch instance with id 470:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
newNode(&((*l)->head));
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 600
Counter: 601
Batcher Size:43
Preprocess the following candidate with BasicTester:
Priority -22
At location prog.c:23
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
(*l)->head->next = (*l)->head;


BasicTester, a patch instance with id 471:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
newNode(&((*(l))->head));
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 601
Counter: 602
Batcher Size:44
Preprocess the following candidate with BasicTester:
Priority -22
At location prog.c:23
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*l)->head;
(*l)->head->next = (*l)->head;


BasicTester, a patch instance with id 472:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
(*l)->head->next = (*l)->head;
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 602
Counter: 603
Batcher Size:45
Preprocess the following candidate with BasicTester:
Priority -22
At location prog.c:23
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*(l))->head;
(*l)->head->next = (*l)->head;


BasicTester, a patch instance with id 473:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
(*l)->head->next = (*(l))->head;
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 603
Counter: 604
Batcher Size:46
Preprocess the following candidate with BasicTester:
Priority -23
At location prog.c:22
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*l)->head;
newNode(&((*l)->head));


BasicTester, a patch instance with id 474:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
(*l)->head->next = (*l)->head;
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 604
Counter: 605
Batcher Size:47
Preprocess the following candidate with BasicTester:
Priority -23
At location prog.c:22
--Src File: prog.c
Fragment 0:
*l = malloc(sizeof(struct List));
newNode(&((*l)->head));


BasicTester, a patch instance with id 475:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
*l = malloc(sizeof(struct List));
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 605
Counter: 606
Batcher Size:48
Preprocess the following candidate with BasicTester:
Priority -23
At location prog.c:22
--Src File: prog.c
Fragment 0:
(*l)->head->next = (*(l))->head;
newNode(&((*l)->head));


BasicTester, a patch instance with id 476:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
(*l)->head->next = (*(l))->head;
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 606
Counter: 607
Batcher Size:49
Preprocess the following candidate with BasicTester:
Priority -23
At location prog.c:22
--Src File: prog.c
Fragment 0:
newNode(&((*(l))->head));
newNode(&((*l)->head));


BasicTester, a patch instance with id 477:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
newNode(&((*(l))->head));
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 607
Counter: 608
Batcher Size:50
Preprocess the following candidate with BasicTester:
Priority -23
At location prog.c:22
--Src File: prog.c
Fragment 0:
newNode(&((*l)->head));
newNode(&((*l)->head));


BasicTester, a patch instance with id 478:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
newNode(&((*l)->head));
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 608
Counter: 609
Batcher Size:51
Preprocess the following candidate with BasicTester:
Priority -25
At location prog.c:55
--Src File: prog.c
Fragment 0:
printf(" %d", l->size);
newList(&l);


BasicTester, a patch instance with id 479:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
printf(" %d", l->size);
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 609
Counter: 610
Batcher Size:52
Preprocess the following candidate with BasicTester:
Priority -25
At location prog.c:55
--Src File: prog.c
Fragment 0:
printf(" %d", (l)->size);
newList(&l);


BasicTester, a patch instance with id 480:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
printf(" %d", (l)->size);
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 610
Counter: 611
Batcher Size:53
Preprocess the following candidate with BasicTester:
Priority -25
At location prog.c:55
--Src File: prog.c
Fragment 0:
newList(&l);
newList(&l);


BasicTester, a patch instance with id 481:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
newList(&l);
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 611
Counter: 612
Batcher Size:54
Preprocess the following candidate with BasicTester:
Priority -25
At location prog.c:55
--Src File: prog.c
Fragment 0:
fclose((f));
newList(&l);


BasicTester, a patch instance with id 482:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
fclose((f));
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 612
Counter: 613
Batcher Size:55
Preprocess the following candidate with BasicTester:
Priority -25
At location prog.c:55
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
newList(&l);


BasicTester, a patch instance with id 483:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if (f == ((void *)0))
    return 0;
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 613
Counter: 614
Batcher Size:56
Preprocess the following candidate with BasicTester:
Priority -25
At location prog.c:55
--Src File: prog.c
Fragment 0:
fclose(f);
newList(&l);


BasicTester, a patch instance with id 484:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
fclose(f);
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 614
Counter: 615
Batcher Size:57
Preprocess the following candidate with BasicTester:
Priority -25
At location prog.c:55
--Src File: prog.c
Fragment 0:
newList(&(l));
newList(&l);


BasicTester, a patch instance with id 485:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
newList(&(l));
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 615
Counter: 616
Batcher Size:58
Preprocess the following candidate with BasicTester:
Priority -25
At location prog.c:55
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
newList(&l);


BasicTester, a patch instance with id 486:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if (argc < 2)
    return 0;
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 616
Counter: 617
Batcher Size:59
Preprocess the following candidate with BasicTester:
Priority -26
At location prog.c:54
--Src File: prog.c
Fragment 0:
fclose((f));
struct List *l;


BasicTester, a patch instance with id 487:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
fclose((f));
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 617
Counter: 618
Batcher Size:60
Preprocess the following candidate with BasicTester:
Priority -26
At location prog.c:54
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
struct List *l;


BasicTester, a patch instance with id 488:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
if (argc < 2)
    return 0;
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 618
Counter: 619
Batcher Size:61
Preprocess the following candidate with BasicTester:
Priority -26
At location prog.c:54
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
struct List *l;


BasicTester, a patch instance with id 489:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
if (f == ((void *)0))
    return 0;
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 619
Counter: 620
Batcher Size:62
Preprocess the following candidate with BasicTester:
Priority -26
At location prog.c:54
--Src File: prog.c
Fragment 0:
fclose(f);
struct List *l;


BasicTester, a patch instance with id 490:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
fclose(f);
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 620
Counter: 621
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority -27
At location prog.c:53
--Src File: prog.c
Fragment 0:
fclose(f);
if (f == ((void *)0))
    return 0;


BasicTester, a patch instance with id 491:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
fclose(f);
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 621
Counter: 622
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority -27
At location prog.c:53
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
if (f == ((void *)0))
    return 0;


BasicTester, a patch instance with id 492:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if (argc < 2)
    return 0;
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 622
Counter: 623
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority -27
At location prog.c:53
--Src File: prog.c
Fragment 0:
fclose((f));
if (f == ((void *)0))
    return 0;


BasicTester, a patch instance with id 493:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
fclose((f));
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 623
Counter: 624
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority -27
At location prog.c:53
--Src File: prog.c
Fragment 0:
if (f == ((void *)0))
    return 0;
if (f == ((void *)0))
    return 0;


BasicTester, a patch instance with id 494:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if (f == ((void *)0))
    return 0;
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 624
Counter: 625
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority -28
At location prog.c:52
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
FILE *f = fopen(argv[1], "r");


BasicTester, a patch instance with id 495:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    
//Patch 0:
if (argc < 2)
    return 0;
FILE *f = fopen(argv[1], "r");

//CodeSeg 1:
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 625
Counter: 626
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    printf("%d ", (in)->next->element);
    break;
}


BasicTester, a patch instance with id 496:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    printf("%d ", (in)->next->element);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 626
Counter: 627
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    in->next = (in);
    break;
}


BasicTester, a patch instance with id 497:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->next = (in);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 627
Counter: 628
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    e->next = (e);
    break;
}


BasicTester, a patch instance with id 498:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e->next = (e);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 628
Counter: 629
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    in->next = (e);
    break;
}


BasicTester, a patch instance with id 499:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->next = (e);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 629
Counter: 630
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    in->next = (in)->next;
    break;
}


BasicTester, a patch instance with id 500:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->next = (in)->next;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 630
Counter: 631
Batcher Size:73
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    newNode(&in);
    break;
}


BasicTester, a patch instance with id 501:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    newNode(&in);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 631
Counter: 632
Batcher Size:74
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    e = e->next;
    break;
}


BasicTester, a patch instance with id 502:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e = e->next;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 632
Counter: 633
Batcher Size:75
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    e = (in);
    break;
}


BasicTester, a patch instance with id 503:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e = (in);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 633
Counter: 634
Batcher Size:76
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    in->next = e->next;
    break;
}


BasicTester, a patch instance with id 504:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->next = e->next;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 634
Counter: 635
Batcher Size:77
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    newNode(&((*(l))->head));
    break;
}


BasicTester, a patch instance with id 505:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    newNode(&((*(l))->head));
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 635
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            //prophet generated patch
            if (__get_mutant()==0) {
            {
                printf("%d ", (in)->next->element);
                break;
            }
            }
            else if (__get_mutant()==1) {
            {
                in->next = (in);
                break;
            }
            }
            else if (__get_mutant()==2) {
            {
                e->next = (e);
                break;
            }
            }
            else if (__get_mutant()==3) {
            {
                in->next = (e);
                break;
            }
            }
            else if (__get_mutant()==4) {
            {
                in->next = (in)->next;
                break;
            }
            }
            else if (__get_mutant()==5) {
            {
                newNode(&in);
                break;
            }
            }
            else if (__get_mutant()==6) {
            {
                e = e->next;
                break;
            }
            }
            else if (__get_mutant()==7) {
            {
                e = (in);
                break;
            }
            }
            else if (__get_mutant()==8) {
            {
                in->next = e->next;
                break;
            }
            }
            else if (__get_mutant()==9) {
            {
                newNode(&((*(l))->head));
                break;
            }
            }
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 496:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    printf("%d ", (in)->next->element);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 497:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->next = (in);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 498:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e->next = (e);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 499:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->next = (e);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 500:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->next = (in)->next;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 501:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    newNode(&in);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 502:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e = e->next;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 503:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e = (in);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 504:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->next = e->next;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 505:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    newNode(&((*(l))->head));
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 636
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    in->element = (0);
    break;
}


BasicTester, a patch instance with id 506:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->element = (0);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 636
Counter: 637
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    printf("%d ", (e)->next->element);
    break;
}


BasicTester, a patch instance with id 507:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    printf("%d ", (e)->next->element);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 637
Counter: 638
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    in->element = (v);
    break;
}


BasicTester, a patch instance with id 508:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->element = (v);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 638
Counter: 639
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    e = (e);
    break;
}


BasicTester, a patch instance with id 509:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e = (e);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 639
Counter: 640
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    e->next = (in);
    break;
}


BasicTester, a patch instance with id 510:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e->next = (in);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 640
Counter: 641
Batcher Size:73
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    in->next = (e)->next;
    break;
}


BasicTester, a patch instance with id 511:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->next = (e)->next;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 641
Counter: 642
Batcher Size:74
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    newNode(&(e));
    break;
}


BasicTester, a patch instance with id 512:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    newNode(&(e));
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 642
Counter: 643
Batcher Size:75
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    e->next = in;
    break;
}


BasicTester, a patch instance with id 513:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e->next = in;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 643
Counter: 644
Batcher Size:76
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    in->element = v;
    break;
}


BasicTester, a patch instance with id 514:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->element = v;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 644
Counter: 645
Batcher Size:77
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    e = (in)->next;
    break;
}


BasicTester, a patch instance with id 515:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e = (in)->next;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 645
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            //prophet generated patch
            if (__get_mutant()==0) {
            {
                in->element = (0);
                break;
            }
            }
            else if (__get_mutant()==1) {
            {
                printf("%d ", (e)->next->element);
                break;
            }
            }
            else if (__get_mutant()==2) {
            {
                in->element = (v);
                break;
            }
            }
            else if (__get_mutant()==3) {
            {
                e = (e);
                break;
            }
            }
            else if (__get_mutant()==4) {
            {
                e->next = (in);
                break;
            }
            }
            else if (__get_mutant()==5) {
            {
                in->next = (e)->next;
                break;
            }
            }
            else if (__get_mutant()==6) {
            {
                newNode(&(e));
                break;
            }
            }
            else if (__get_mutant()==7) {
            {
                e->next = in;
                break;
            }
            }
            else if (__get_mutant()==8) {
            {
                in->element = v;
                break;
            }
            }
            else if (__get_mutant()==9) {
            {
                e = (in)->next;
                break;
            }
            }
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 506:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->element = (0);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 507:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    printf("%d ", (e)->next->element);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 508:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->element = (v);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 509:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e = (e);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 510:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e->next = (in);
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 511:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->next = (e)->next;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 512:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    newNode(&(e));
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 513:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e->next = in;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 514:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    in->element = v;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 515:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e = (in)->next;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 646
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    newNode(&(in));
    break;
}


BasicTester, a patch instance with id 516:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    newNode(&(in));
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 646
Counter: 647
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority -31
At location prog.c:42
--Src File: prog.c
Fragment 0:
{
    e = (e)->next;
    break;
}


BasicTester, a patch instance with id 517:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e = (e)->next;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 647
Counter: 648
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    e->next = (in);
    e = e->next;
}


BasicTester, a patch instance with id 518:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e->next = (in);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 648
Counter: 649
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    e = (in);
    e = e->next;
}


BasicTester, a patch instance with id 519:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (in);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 649
Counter: 650
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    newNode(&(in));
    e = e->next;
}


BasicTester, a patch instance with id 520:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    newNode(&(in));
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 650
Counter: 651
Batcher Size:73
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    printf("%d ", (in)->next->element);
    e = e->next;
}


BasicTester, a patch instance with id 521:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    printf("%d ", (in)->next->element);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 651
Counter: 652
Batcher Size:74
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    in->element = v;
    e = e->next;
}


BasicTester, a patch instance with id 522:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->element = v;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 652
Counter: 653
Batcher Size:75
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    in->next = (e);
    e = e->next;
}


BasicTester, a patch instance with id 523:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->next = (e);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 653
Counter: 654
Batcher Size:76
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    e->next = in;
    e = e->next;
}


BasicTester, a patch instance with id 524:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e->next = in;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 654
Counter: 655
Batcher Size:77
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    e->next = (e);
    e = e->next;
}


BasicTester, a patch instance with id 525:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e->next = (e);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 655
Counter: 656
Batcher Size:78
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    e = (in)->next;
    e = e->next;
}


BasicTester, a patch instance with id 526:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (in)->next;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 656
Counter: 657
Batcher Size:79
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    printf("%d ", (e)->next->element);
    e = e->next;
}


BasicTester, a patch instance with id 527:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    printf("%d ", (e)->next->element);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 657
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            //prophet generated patch
            if (__get_mutant()==0) {
            {
                e->next = (in);
                e = e->next;
            }
            }
            else if (__get_mutant()==1) {
            {
                e = (in);
                e = e->next;
            }
            }
            else if (__get_mutant()==2) {
            {
                newNode(&(in));
                e = e->next;
            }
            }
            else if (__get_mutant()==3) {
            {
                printf("%d ", (in)->next->element);
                e = e->next;
            }
            }
            else if (__get_mutant()==4) {
            {
                in->element = v;
                e = e->next;
            }
            }
            else if (__get_mutant()==5) {
            {
                in->next = (e);
                e = e->next;
            }
            }
            else if (__get_mutant()==6) {
            {
                e->next = in;
                e = e->next;
            }
            }
            else if (__get_mutant()==7) {
            {
                e->next = (e);
                e = e->next;
            }
            }
            else if (__get_mutant()==8) {
            {
                e = (in)->next;
                e = e->next;
            }
            }
            else if (__get_mutant()==9) {
            {
                printf("%d ", (e)->next->element);
                e = e->next;
            }
            }
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 518:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e->next = (in);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 519:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (in);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 520:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    newNode(&(in));
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 521:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    printf("%d ", (in)->next->element);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 522:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->element = v;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 523:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->next = (e);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 524:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e->next = in;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 525:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e->next = (e);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 526:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (in)->next;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 527:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    printf("%d ", (e)->next->element);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Going to sync the batch tester, clear all existing tasks!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    //prophet generated patch
    if (__get_mutant()==0) {
    (*l)->head->next = (*l)->head;
    newNode(&((*l)->head));
    }
    else if (__get_mutant()==1) {
    *l = malloc(sizeof(struct List));
    newNode(&((*l)->head));
    }
    else if (__get_mutant()==2) {
    (*l)->head->next = (*(l))->head;
    newNode(&((*l)->head));
    }
    else if (__get_mutant()==3) {
    newNode(&((*(l))->head));
    newNode(&((*l)->head));
    }
    else if (__get_mutant()==4) {
    newNode(&((*l)->head));
    newNode(&((*l)->head));
    }
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 474:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
(*l)->head->next = (*l)->head;
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 475:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
*l = malloc(sizeof(struct List));
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 476:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
(*l)->head->next = (*(l))->head;
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 477:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
newNode(&((*(l))->head));
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 478:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    
//Patch 0:
newNode(&((*l)->head));
newNode(&((*l)->head));

//CodeSeg 1:
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    //prophet generated patch
    if (__get_mutant()==0) {
    *l = malloc(sizeof(struct List));
    (*l)->head->next = (*l)->head;
    }
    else if (__get_mutant()==1) {
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    }
    else if (__get_mutant()==2) {
    newNode(&((*(l))->head));
    (*l)->head->next = (*l)->head;
    }
    else if (__get_mutant()==3) {
    (*l)->head->next = (*l)->head;
    (*l)->head->next = (*l)->head;
    }
    else if (__get_mutant()==4) {
    (*l)->head->next = (*(l))->head;
    (*l)->head->next = (*l)->head;
    }
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 469:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
*l = malloc(sizeof(struct List));
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 470:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
newNode(&((*l)->head));
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 471:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
newNode(&((*(l))->head));
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 472:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
(*l)->head->next = (*l)->head;
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 473:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    
//Patch 0:
(*l)->head->next = (*(l))->head;
(*l)->head->next = (*l)->head;

//CodeSeg 1:
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    //prophet generated patch
    if (__get_mutant()==0) {
    (*l)->head->next = (*l)->head;
    return;
    }
    else if (__get_mutant()==1) {
    *l = malloc(sizeof(struct List));
    return;
    }
    else if (__get_mutant()==2) {
    (*l)->head->next = (*(l))->head;
    return;
    }
    else if (__get_mutant()==3) {
    newNode(&((*(l))->head));
    return;
    }
    else if (__get_mutant()==4) {
    newNode(&((*l)->head));
    return;
    }
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 464:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
(*l)->head->next = (*l)->head;
return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 465:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
*l = malloc(sizeof(struct List));
return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 466:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
(*l)->head->next = (*(l))->head;
return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 467:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
newNode(&((*(l))->head));
return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 468:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    
//Patch 0:
newNode(&((*l)->head));
return;

//CodeSeg 1:
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    //prophet generated patch
    if (__get_mutant()==0) {
    *n = malloc(sizeof(struct Entry));
    (*n)->next = ((void *)0);
    }
    else if (__get_mutant()==1) {
    (*n)->next = ((void *)0);
    (*n)->next = ((void *)0);
    }
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 424:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    
//Patch 0:
*n = malloc(sizeof(struct Entry));
(*n)->next = ((void *)0);

//CodeSeg 1:
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 425:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    
//Patch 0:
(*n)->next = ((void *)0);
(*n)->next = ((void *)0);

//CodeSeg 1:
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            //prophet generated patch
            if (__get_mutant()==0) {
            {
                newNode(&(in));
                break;
            }
            }
            else if (__get_mutant()==1) {
            {
                e = (e)->next;
                break;
            }
            }
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 516:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    newNode(&(in));
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 517:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            
//Patch 0:
{
    e = (e)->next;
    break;
}

//CodeSeg 1:
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    //prophet generated patch
    if (__get_mutant()==0) {
    if (argc < 2)
        return 0;
    FILE *f = fopen(argv[1], "r");
    }
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building failed! Going to build saperately!
BasicTester, Testing instance id 495:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    
//Patch 0:
if (argc < 2)
    return 0;
FILE *f = fopen(argv[1], "r");

//CodeSeg 1:
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    //prophet generated patch
    if (__get_mutant()==0) {
    fclose(f);
    if (f == ((void *)0))
        return 0;
    }
    else if (__get_mutant()==1) {
    if (argc < 2)
        return 0;
    if (f == ((void *)0))
        return 0;
    }
    else if (__get_mutant()==2) {
    fclose((f));
    if (f == ((void *)0))
        return 0;
    }
    else if (__get_mutant()==3) {
    if (f == ((void *)0))
        return 0;
    if (f == ((void *)0))
        return 0;
    }
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 491:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
fclose(f);
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 492:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if (argc < 2)
    return 0;
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 493:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
fclose((f));
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 494:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if (f == ((void *)0))
    return 0;
if (f == ((void *)0))
    return 0;

//CodeSeg 1:
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    //prophet generated patch
    if (__get_mutant()==0) {
    fclose((f));
    struct List *l;
    }
    else if (__get_mutant()==1) {
    if (argc < 2)
        return 0;
    struct List *l;
    }
    else if (__get_mutant()==2) {
    if (f == ((void *)0))
        return 0;
    struct List *l;
    }
    else if (__get_mutant()==3) {
    fclose(f);
    struct List *l;
    }
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building failed! Going to build saperately!
BasicTester, Testing instance id 487:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
fclose((f));
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 488:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
if (argc < 2)
    return 0;
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 489:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
if (f == ((void *)0))
    return 0;
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 490:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    
//Patch 0:
fclose(f);
struct List *l;

//CodeSeg 1:
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    //prophet generated patch
    if (__get_mutant()==0) {
    printf(" %d", l->size);
    newList(&l);
    }
    else if (__get_mutant()==1) {
    printf(" %d", (l)->size);
    newList(&l);
    }
    else if (__get_mutant()==2) {
    newList(&l);
    newList(&l);
    }
    else if (__get_mutant()==3) {
    fclose((f));
    newList(&l);
    }
    else if (__get_mutant()==4) {
    if (f == ((void *)0))
        return 0;
    newList(&l);
    }
    else if (__get_mutant()==5) {
    fclose(f);
    newList(&l);
    }
    else if (__get_mutant()==6) {
    newList(&(l));
    newList(&l);
    }
    else if (__get_mutant()==7) {
    if (argc < 2)
        return 0;
    newList(&l);
    }
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 479:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
printf(" %d", l->size);
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 480:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
printf(" %d", (l)->size);
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 481:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
newList(&l);
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 482:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
fclose((f));
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 483:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if (f == ((void *)0))
    return 0;
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 484:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
fclose(f);
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 485:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
newList(&(l));
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 486:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    
//Patch 0:
if (argc < 2)
    return 0;
newList(&l);

//CodeSeg 1:
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    //prophet generated patch
    if (__get_mutant()==0) {
    fclose(f);
    struct Entry *node;
    }
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building failed! Going to build saperately!
BasicTester, Testing instance id 455:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    
//Patch 0:
fclose(f);
struct Entry *node;

//CodeSeg 1:
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    //prophet generated patch
    if (__get_mutant()==0) {
    if (f == ((void *)0))
        return 0;
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==1) {
    if (argc < 2)
        return 0;
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==2) {
    printf("%d ", node->next->element);
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==3) {
    node = node->next;
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==4) {
    printf(" %d", l->size);
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==5) {
    node = (node)->next;
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==6) {
    fclose(f);
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==7) {
    printf("%d ", (node)->next->element);
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    else if (__get_mutant()==8) {
    printf(" %d", (l)->size);
    while (fscanf(f, "%s", x) == 1)
        {
            if (x[0] != '"') {
                insertSort(&l, atoi(x));
            }
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 436:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if (f == ((void *)0))
    return 0;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 437:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
if (argc < 2)
    return 0;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 438:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
printf("%d ", node->next->element);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 439:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
node = node->next;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 440:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
printf(" %d", l->size);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 441:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
node = (node)->next;
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 442:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
fclose(f);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 443:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
printf("%d ", (node)->next->element);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 444:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    
//Patch 0:
printf(" %d", (l)->size);
while (fscanf(f, "%s", x) == 1)
    {
        if (x[0] != '"') {
            insertSort(&l, atoi(x));
        }
    }

//CodeSeg 1:
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    //prophet generated patch
    if (__get_mutant()==0) {
    newNode(&(node));
    fclose(f);
    }
    else if (__get_mutant()==1) {
    newList(&l);
    fclose(f);
    }
    else if (__get_mutant()==2) {
    newList(&(l));
    fclose(f);
    }
    else if (__get_mutant()==3) {
    insertSort(&l, atoi(x));
    fclose(f);
    }
    else if (__get_mutant()==4) {
    node = l->head;
    fclose(f);
    }
    else if (__get_mutant()==5) {
    if (x[0] != '"') {
        insertSort(&l, atoi(x));
    }
    fclose(f);
    }
    else if (__get_mutant()==6) {
    node = (node);
    fclose(f);
    }
    else if (__get_mutant()==7) {
    printf(" %d", (l)->size);
    fclose(f);
    }
    else if (__get_mutant()==8) {
    node = node->next;
    fclose(f);
    }

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 415:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
newNode(&(node));
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 416:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
newList(&l);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 417:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
newList(&(l));
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 418:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
insertSort(&l, atoi(x));
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 419:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
node = l->head;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 420:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 421:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
node = (node);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 422:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
printf(" %d", (l)->size);
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 423:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    
//Patch 0:
node = node->next;
fclose(f);

//CodeSeg 1:

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    //prophet generated patch
    if (__get_mutant()==0) {
    newList(&(l));
    node = l->head;
    }
    else if (__get_mutant()==1) {
    newList(&l);
    node = l->head;
    }
    else if (__get_mutant()==2) {
    insertSort(&l, atoi(x));
    node = l->head;
    }
    else if (__get_mutant()==3) {
    node = (l)->head;
    node = l->head;
    }
    else if (__get_mutant()==4) {
    node = node->next;
    node = l->head;
    }
    else if (__get_mutant()==5) {
    if (f == ((void *)0))
        return 0;
    node = l->head;
    }
    else if (__get_mutant()==6) {
    insertSort(&(l), atoi(x));
    node = l->head;
    }
    else if (__get_mutant()==7) {
    if (x[0] != '"') {
        insertSort(&l, atoi(x));
    }
    node = l->head;
    }
    else if (__get_mutant()==8) {
    fclose((f));
    node = l->head;
    }
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 396:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
newList(&(l));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 397:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
newList(&l);
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 398:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
insertSort(&l, atoi(x));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 399:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = (l)->head;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 400:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
node = node->next;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 401:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if (f == ((void *)0))
    return 0;
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 402:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
insertSort(&(l), atoi(x));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 403:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
if (x[0] != '"') {
    insertSort(&l, atoi(x));
}
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 404:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    
//Patch 0:
fclose((f));
node = l->head;

//CodeSeg 1:
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    //prophet generated patch
    if (__get_mutant()==0) {
    newNode(&(node));
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==1) {
    printf(" %d", l->size);
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==2) {
    insertSort(&(l), atoi(x));
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==3) {
    node = node->next;
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==4) {
    node = l->head;
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    else if (__get_mutant()==5) {
    insertSort(&l, atoi(x));
    while (node->next != l->head)
        {
            printf("%d ", node->next->element);
            node = node->next;
        }
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 380:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
newNode(&(node));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 381:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
printf(" %d", l->size);
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 382:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
insertSort(&(l), atoi(x));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 383:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
node = node->next;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 384:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
node = l->head;
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 385:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            e = e->next;
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    
//Patch 0:
insertSort(&l, atoi(x));
while (node->next != l->head)
    {
        printf("%d ", node->next->element);
        node = node->next;
    }

//CodeSeg 1:
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Counter: 658
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    in->next = (in);
    e = e->next;
}


BasicTester, a patch instance with id 528:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->next = (in);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 658
Counter: 659
Batcher Size:1
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    e = e->next;
    e = e->next;
}


BasicTester, a patch instance with id 529:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = e->next;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 659
Counter: 660
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    in->next = (in)->next;
    e = e->next;
}


BasicTester, a patch instance with id 530:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->next = (in)->next;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 660
Counter: 661
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    newNode(&(e));
    e = e->next;
}


BasicTester, a patch instance with id 531:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    newNode(&(e));
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 661
Counter: 662
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    newNode(&in);
    e = e->next;
}


BasicTester, a patch instance with id 532:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    newNode(&in);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 662
Counter: 663
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    e = (e)->next;
    e = e->next;
}


BasicTester, a patch instance with id 533:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (e)->next;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 663
Counter: 664
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    in->next = e->next;
    e = e->next;
}


BasicTester, a patch instance with id 534:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->next = e->next;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 664
Counter: 665
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    in->element = (0);
    e = e->next;
}


BasicTester, a patch instance with id 535:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->element = (0);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 665
Counter: 666
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    in->element = (v);
    e = e->next;
}


BasicTester, a patch instance with id 536:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->element = (v);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 666
Counter: 667
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    e = (e);
    e = e->next;
}


BasicTester, a patch instance with id 537:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (e);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 667
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            //prophet generated patch
            if (__get_mutant()==0) {
            {
                in->next = (in);
                e = e->next;
            }
            }
            else if (__get_mutant()==1) {
            {
                e = e->next;
                e = e->next;
            }
            }
            else if (__get_mutant()==2) {
            {
                in->next = (in)->next;
                e = e->next;
            }
            }
            else if (__get_mutant()==3) {
            {
                newNode(&(e));
                e = e->next;
            }
            }
            else if (__get_mutant()==4) {
            {
                newNode(&in);
                e = e->next;
            }
            }
            else if (__get_mutant()==5) {
            {
                e = (e)->next;
                e = e->next;
            }
            }
            else if (__get_mutant()==6) {
            {
                in->next = e->next;
                e = e->next;
            }
            }
            else if (__get_mutant()==7) {
            {
                in->element = (0);
                e = e->next;
            }
            }
            else if (__get_mutant()==8) {
            {
                in->element = (v);
                e = e->next;
            }
            }
            else if (__get_mutant()==9) {
            {
                e = (e);
                e = e->next;
            }
            }
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 528:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->next = (in);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 529:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = e->next;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 530:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->next = (in)->next;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 531:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    newNode(&(e));
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 532:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    newNode(&in);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 533:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (e)->next;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 534:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->next = e->next;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 535:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->element = (0);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 536:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->element = (v);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 537:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    e = (e);
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Going to sync the batch tester, clear all existing tasks!
Counter: 668
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    in->next = (e)->next;
    e = e->next;
}


BasicTester, a patch instance with id 538:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->next = (e)->next;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 668
Counter: 669
Batcher Size:1
Preprocess the following candidate with BasicTester:
Priority -32
At location prog.c:40
--Src File: prog.c
Fragment 0:
{
    newNode(&((*(l))->head));
    e = e->next;
}


BasicTester, a patch instance with id 539:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    newNode(&((*(l))->head));
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Spawn 1 instances, now Total 669
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            //prophet generated patch
            if (__get_mutant()==0) {
            {
                in->next = (e)->next;
                e = e->next;
            }
            }
            else if (__get_mutant()==1) {
            {
                newNode(&((*(l))->head));
                e = e->next;
            }
            }
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 538:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    in->next = (e)->next;
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
BasicTester, Testing instance id 539:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Entry{
    int  element;
    struct Entry*  next;
};

struct List {
    int size;
    struct Entry*  head;
};
void newList(struct List **_out) ;
void reverse(struct List **l);
void newNode(struct Entry** out);
void insertSort(struct List** l, int v);
int hasLoop(struct List *l);

void newList(struct List** l) {
    *l = malloc( sizeof(struct List)  );
    newNode(&((*l)->head));
    (*l)->head->next = (*l)->head;
    return;
}

void newNode( struct Entry** n){
    *n = malloc(sizeof(struct Entry));
//    (*n)->element = v;
    (*n)->next = NULL;
}

void  insertSort (struct List** l, int v) {
    struct Entry* in;
    newNode(&in);
    in->element = v;
    struct Entry* e = (*l)->head;
    while ( e->next != (*l)->head) {
        if (e->next->element < v)
            
//Patch 0:
{
    newNode(&((*(l))->head));
    e = e->next;
}

//CodeSeg 1:
        else
            break;
    }
    in->next = e->next;
    e->next = in;
  //  (*l)->size = (*l)->size + 1;
}


int main(int argc, char *argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL) return 0;
    struct List *l;
    newList(&l);
    char x[20];
    struct Entry* node;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] != '"') {
            //newNode(atoi(x),&node);
            insertSort(&l,atoi(x));
        }
    }
    fclose(f);

    node = l->head;
    while (node->next != l->head) {
        printf("%d ",node->next->element);
        node = node->next;
    }
    printf(" %d",l->size);
    return 0;


}

Testing negative cases!
Repair process ends without working fix!!
Total 669 different repair schemas!!!!
Total 1458 different repair candidate templates for scoring!!!
Total number of compiles: 168
Total number of test eval: 1040
